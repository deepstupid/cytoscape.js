(function(E){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=E();else if("function"==typeof define&&define.amd)define([],E);else{var _;_="undefined"==typeof window?"undefined"==typeof global?"undefined"==typeof self?this:self:global:window,_.cytoscape=E()}})(function(){return function E(_,D,T){function I(R,F){if(!D[R]){if(!_[R]){var $="function"==typeof require&&require;if(!F&&$)return $(R,!0);if(L)return L(R,!0);var M=new Error("Cannot find module '"+R+"'");throw M.code="MODULE_NOT_FOUND",M}var U=D[R]={exports:{}};_[R][0].call(U.exports,function(Z){var G=_[R][1][Z];return I(G?G:Z)},U,U.exports,E,_,D,T)}return D[R].exports}var L="function"==typeof require&&require;for(var O=0;O<T.length;O++)I(T[O]);return I}({1:[function(){},{}],2:[function(E,_){"use strict";var D=E("./util"),T=E("./is"),I=E("./promise"),L=function(R,F,$){if(!(this instanceof L))return new L(R,F,$);var M=this._private=D.extend({duration:1000},F,$);M.target=R,M.style=M.style||M.css,M.started=!1,M.playing=!1,M.hooked=!1,M.applying=!1,M.progress=0,M.completes=[],M.frames=[],M.complete&&T.fn(M.complete)&&M.completes.push(M.complete),this.length=1,this[0]=this},O=L.prototype;D.extend(O,{instanceString:function(){return"animation"},hook:function(){var R=this._private;if(!R.hooked){// add to target's animation queue
var F,$=R.target._private.animation;F=R.queue?$.queue:$.current,F.push(this),T.elementOrCollection(R.target)&&R.target.cy().addToAnimationPool(R.target),R.hooked=!0}return this},play:function(){var R=this._private;// autorewind
// the animation loop will start the animation...
return 1===R.progress&&(R.progress=0),R.playing=!0,R.started=!1,R.stopped=!1,this.hook(),this},playing:function(){return this._private.playing},apply:function(){var R=this._private;// the animation loop will apply the animation at this progress
return R.applying=!0,R.started=!1,R.stopped=!1,this.hook(),this},applying:function(){return this._private.applying},pause:function(){var R=this._private;return R.playing=!1,R.started=!1,this},stop:function(){var R=this._private;// to be removed from animation queues
return R.playing=!1,R.started=!1,R.stopped=!0,this},rewind:function(){return this.progress(0)},fastforward:function(){return this.progress(1)},time:function(R){var F=this._private;return void 0===R?F.progress*F.duration:this.progress(R/F.duration)},progress:function(R){var F=this._private,$=F.playing;return void 0===R?F.progress:($&&this.pause(),F.progress=R,F.started=!1,$&&this.play(),this)},completed:function(){return 1===this._private.progress},reverse:function(){var R=this._private,F=R.playing;F&&this.pause(),R.progress=1-R.progress,R.started=!1;var $=function(K,J){var ee=R[K];R[K]=R[J],R[J]=ee};$("zoom","startZoom"),$("pan","startPan"),$("position","startPosition");// swap styles
for(var M=0;M<R.style.length;M++){var U=R.style[M],Z=U.name,G=R.startStyle[Z];R.startStyle[Z]=U,R.style[M]=G}return F&&this.play(),this},promise:function(R){var F=this._private,$;switch(R){case"frame":$=F.frames;break;default:case"complete":case"completed":$=F.completes;}return new I(function(M){$.push(function(){M()})})}}),O.complete=O.completed,_.exports=L},{"./is":83,"./promise":85,"./util":99}],3:[function(E,_){"use strict";var D=E("../../is");_.exports={// Implemented from pseudocode from wikipedia
aStar:function(T){var I=this;T=T||{};// Reconstructs the path from Start to End, acumulating the result in pathAcum
var L=function(me,fe,xe,ve){// Base case
if(me==fe)return ve.push(R.getElementById(fe)),ve;if(fe in xe){// We know which node is before the last one
var be=xe[fe],we=ee[fe];return ve.push(R.getElementById(fe)),ve.push(R.getElementById(we)),L(me,be,xe,ve)}// We should not reach here!
return void 0},O=function(me,fe){if(0===me.length)// Should never be the case
return void 0;var xe=0,ve=fe[me[0]];for(var be=1;be<me.length;be++){var we=fe[me[be]];we<ve&&(ve=we,xe=be)}return xe},R=this._private.cy;// Returns the index of the element in openSet which has minimum fScore
// root - mandatory!
if(null!=T&&null!=T.root)var F=D.string(T.root)?// use it as a selector, e.g. "#rootID
this.filter(T.root)[0]:T.root[0];else return void 0;// goal - mandatory!
if(null!=T.goal)var $=D.string(T.goal)?// use it as a selector, e.g. "#goalID
this.filter(T.goal)[0]:T.goal[0];else return void 0;// Heuristic function - optional
if(null!=T.heuristic&&D.fn(T.heuristic))var M=T.heuristic;else var M=function(){return 0};// use constant if unspecified
// Weight function - optional
if(null!=T.weight&&D.fn(T.weight))var U=T.weight;else// If not specified, assume each edge has equal weight (1)
var U=function(){return 1};// directed - optional
if(null!=T.directed)var Z=T.directed;else var Z=!1;var G=[],K=[F.id()],J={},ee={},te={},ae={};te[F.id()]=0,ae[F.id()]=M(F);// Main loop
// Counter
for(var ne=this.edges().stdFilter(function(me){return!me.isLoop()}),re=this.nodes(),oe=0;0<K.length;){var se=O(K,ae),le=R.getElementById(K[se]);// If we've found our goal, then we are done
if(oe++,le.id()==$.id()){var pe=L(F.id(),$.id(),J,[]);return pe.reverse(),{found:!0,distance:te[le.id()],path:I.spawn(pe),steps:oe}}// Add cMin to processed nodes
G.push(le.id()),K.splice(se,1);// Update scores for neighbors of cMin
// Take into account if graph is directed or not
var ue=le.connectedEdges();Z&&(ue=ue.stdFilter(function(me){return me.data("source")===le.id()})),ue=ue.intersect(ne);for(var ge=0;ge<ue.length;ge++){var ce=ue[ge],he=ce.connectedNodes().stdFilter(function(me){return me.id()!==le.id()}).intersect(re);// if node is in closedSet, ignore it
if(-1==G.indexOf(he.id())){// New tentative score for node w
var ye=te[le.id()]+U(ce);// Update gScore for node w if:
//   w not present in openSet
// OR
//   tentative gScore is less than previous value
// w not in openSet
if(-1==K.indexOf(he.id())){te[he.id()]=ye,ae[he.id()]=ye+M(he),K.push(he.id()),J[he.id()]=le.id(),ee[he.id()]=ce.id();continue}// w already in openSet, but with greater gScore
ye<te[he.id()]&&(te[he.id()]=ye,ae[he.id()]=ye+M(he),J[he.id()]=le.id())}}// End of neighbors update
}// End of main loop
// If we've reached here, then we've not reached our goal
return{found:!1,distance:void 0,path:void 0,steps:oe}}}},{"../../is":83}],4:[function(E,_){"use strict";var D=E("../../is"),T=E("../../util");_.exports={// Implemented from pseudocode from wikipedia
bellmanFord:function(I){var L=this;// Weight function - optional
if(I=I||{},null!=I.weight&&D.fn(I.weight))var O=I.weight;else// If not specified, assume each edge has equal weight (1)
var O=function(){return 1};// directed - optional
if(null!=I.directed)var R=I.directed;else var R=!1;// root - mandatory!
if(null==I.root)return void 0;if(D.string(I.root))// use it as a selector, e.g. "#rootID
var F=this.filter(I.root)[0];else var F=I.root[0];var $=this._private.cy,M=this.edges().stdFilter(function(ue){return!ue.isLoop()}),U=this.nodes(),Z=U.length,G={};// mapping: node id -> position in nodes array
for(var K=0;K<Z;K++)G[U[K].id()]=K;// Initializations
var J=[],ee=[],te=[];for(var K=0;K<Z;K++)J[K]=U[K].id()===F.id()?0:1/0,ee[K]=void 0;// Edges relaxation
var ae=!1;for(var K=1;K<Z;K++){ae=!1;for(var ne=0;ne<M.length;ne++){var re=G[M[ne].source().id()],oe=G[M[ne].target().id()],se=O(M[ne]),le=J[re]+se;// If undirected graph, we need to take into account the 'reverse' edge
if(le<J[oe]&&(J[oe]=le,ee[oe]=re,te[oe]=M[ne],ae=!0),!R){var le=J[oe]+se;le<J[re]&&(J[re]=le,ee[re]=oe,te[re]=M[ne],ae=!0)}}if(!ae)break}if(ae)// Check for negative weight cycles
for(var ne=0;ne<M.length;ne++){var re=G[M[ne].source().id()],oe=G[M[ne].target().id()],se=O(M[ne]);if(J[re]+se<J[oe])return T.error("Graph contains a negative weight cycle for Bellman-Ford"),{pathTo:void 0,distanceTo:void 0,hasNegativeWeightCycle:!0}}// Build result object
var pe=[];for(var K=0;K<Z;K++)pe.push(U[K].id());return{distanceTo:function(ue){if(D.string(ue))// to is a selector string
var ge=$.filter(ue)[0].id();else// to is a node
var ge=ue.id();return J[G[ge]]},pathTo:function(ue){if(D.string(ue))// to is a selector string
var ge=$.filter(ue)[0].id();else// to is a node
var ge=ue.id();// This returns a reversed path
var ce=function(he,ye,me,fe,xe,ve){for(;;){if(xe.push($.getElementById(fe[me])),xe.push(ve[me]),ye===me)// reached starting node
return xe;// If no path exists, discart acumulated path and return undefined
var be=he[me];if("undefined"==typeof be)return void 0;me=be}}(ee,G[F.id()],G[ge],pe,[],te);// Get it in the correct order and return it
return null!=ce&&ce.reverse(),L.spawn(ce)},hasNegativeWeightCycle:!1}}// bellmanFord
}},{"../../is":83,"../../util":99}],5:[function(E,_){"use strict";var D=E("../../is"),T=E("../../heap"),I={// Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
betweennessCentrality:function(L){L=L||{};// Weight - optional
var O,R;D.fn(L.weight)?(R=L.weight,O=!0):O=!1;// Directed - default false
var F=null!=L.directed&&L.directed,$=this._private.cy,M=this.nodes(),U={},Z={},G=0,K={set:function(xe,ve){Z[xe]=ve,ve>G&&(G=ve)},get:function(xe){return Z[xe]}};// starting
// A contains the neighborhoods of every node
for(var J=0;J<M.length;J++){var ee=M[J],te=ee.id();U[te]=F?ee.outgoers().nodes():ee.openNeighborhood().nodes(),K.set(te,0)}for(var ae=0;ae<M.length;ae++){var ne=M[ae].id(),re=[],oe={},se={},le={},pe=new T(function(xe,ve){return le[xe]-le[ve]});// stack
// queue
// init dictionaries
for(var J=0;J<M.length;J++){var te=M[J].id();oe[te]=[],se[te]=0,le[te]=1/0}for(se[ne]=1,le[ne]=0,pe.push(ne);!pe.empty();){var ee=pe.pop();if(re.push(ee),O)for(var ue=0;ue<U[ee].length;ue++){var ge=U[ee][ue],ce=$.getElementById(ee),he;he=0<ce.edgesTo(ge).length?ce.edgesTo(ge)[0]:ge.edgesTo(ce)[0];var ye=R(he);ge=ge.id(),le[ge]>le[ee]+ye&&(le[ge]=le[ee]+ye,0>pe.nodes.indexOf(ge)?pe.push(ge):pe.updateItem(ge),se[ge]=0,oe[ge]=[]),le[ge]==le[ee]+ye&&(se[ge]=se[ge]+se[ee],oe[ge].push(ee))}else for(var ue=0;ue<U[ee].length;ue++){var ge=U[ee][ue].id();le[ge]==1/0&&(pe.push(ge),le[ge]=le[ee]+1),le[ge]==le[ee]+1&&(se[ge]=se[ge]+se[ee],oe[ge].push(ee))}}var me={};for(var J=0;J<M.length;J++)me[M[J].id()]=0;for(;0<re.length;){var ge=re.pop();for(var ue=0;ue<oe[ge].length;ue++){var ee=oe[ge][ue];me[ee]=me[ee]+se[ee]/se[ge]*(1+me[ge]),ge!=M[ae].id()&&K.set(ge,K.get(ge)+me[ge])}}}var fe={betweenness:function(xe){if(D.string(xe))var xe=$.filter(xe).id();else var xe=xe.id();return K.get(xe)},betweennessNormalized:function(xe){if(0==G)return 0;if(D.string(xe))var xe=$.filter(xe).id();else var xe=xe.id();return K.get(xe)/G}};// alias
return fe.betweennessNormalised=fe.betweennessNormalized,fe}// betweennessCentrality
};// elesfn
// nice, short mathemathical alias
I.bc=I.betweennessCentrality,_.exports=I},{"../../heap":81,"../../is":83}],6:[function(E,_){"use strict";var D=E("../../is"),T=function(L){// from pseudocode on wikipedia
return L={bfs:L.bfs||!L.dfs,dfs:L.dfs||!L.bfs},function(R,F,$){var M;D.plainObject(R)&&!D.elementOrCollection(R)&&(M=R,R=M.roots||M.root,F=M.visit,$=M.directed),$=2!==arguments.length||D.fn(F)?$:F,F=D.fn(F)?F:function(){};var U=this._private.cy,Z=R=D.string(R)?this.filter(R):R,G=[],K=[],J={},ee={},te={},ae=0,re=this.nodes(),oe=this.edges(),ne;// enqueue v
for(var se=0;se<Z.length;se++)Z[se].isNode()&&(G.unshift(Z[se]),L.bfs&&(te[Z[se].id()]=!0,K.push(Z[se])),ee[Z[se].id()]=0);for(;0!==G.length;){var Z=L.bfs?G.shift():G.pop();if(L.dfs){if(te[Z.id()])continue;te[Z.id()]=!0,K.push(Z)}var le=ee[Z.id()],pe=J[Z.id()],ue=null==pe?void 0:pe.connectedNodes().not(Z)[0],ge=F(Z,pe,ue,ae++,le);if(!0===ge){ne=Z;break}if(!1===ge)break;var ce=Z.connectedEdges($?function(ve){return ve.data("source")===Z.id()}:void 0).intersect(oe);for(var se=0;se<ce.length;se++){var he=ce[se],ye=he.connectedNodes(function(ve){return ve.id()!==Z.id()}).intersect(re);0===ye.length||te[ye.id()]||(ye=ye[0],G.push(ye),L.bfs&&(te[ye.id()]=!0,K.push(ye)),J[ye.id()]=he,ee[ye.id()]=ee[Z.id()]+1)}}var me=[];for(var se=0;se<K.length;se++){var fe=K[se],xe=J[fe.id()];xe&&me.push(xe),me.push(fe)}return{path:U.collection(me,{unique:!0}),found:U.collection(ne)}}},I={breadthFirstSearch:T({bfs:!0}),depthFirstSearch:T({dfs:!0})};// search, spanning trees, etc
// nice, short mathemathical alias
I.bfs=I.breadthFirstSearch,I.dfs=I.depthFirstSearch,_.exports=I},{"../../is":83}],7:[function(E,_){"use strict";var D=E("../../is"),T={closenessCentralityNormalized:function(I){I=I||{};var L=this.cy(),O=I.harmonic;O===void 0&&(O=!0);var R={},F=0,$=this.nodes(),M=this.floydWarshall({weight:I.weight,directed:I.directed});// Compute closeness for every node and find the maximum closeness
for(var U=0;U<$.length;U++){var Z=0;for(var G=0;G<$.length;G++)if(U!=G){var K=M.distance($[U],$[G]);Z+=O?1/K:K}O||(Z=1/Z),F<Z&&(F=Z),R[$[U].id()]=Z}return{closeness:function(J){if(0==F)return 0;if(D.string(J))// from is a selector string
var J=L.filter(J)[0].id();else// from is a node
var J=J.id();return R[J]/F}}},// Implemented from pseudocode from wikipedia
closenessCentrality:function(I){// root - mandatory!
if(I=I||{},null==I.root)return void 0;// weight - optional
if(D.string(I.root))// use it as a selector, e.g. "#rootID
var L=this.filter(I.root)[0];else var L=I.root[0];if(null!=I.weight&&D.fn(I.weight))var O=I.weight;else var O=function(){return 1};// directed - optional
if(null!=I.directed&&D.bool(I.directed))var R=I.directed;else var R=!1;var F=I.harmonic;void 0===F&&(F=!0);// we need distance from this node to every other node
var $=this.dijkstra({root:L,weight:O,directed:R}),M=0,U=this.nodes();for(var Z=0;Z<U.length;Z++)if(U[Z].id()!=L.id()){var G=$.distanceTo(U[Z]);M+=F?1/G:G}return F?M:1/M}// closenessCentrality
};// elesfn
// nice, short mathemathical alias
T.cc=T.closenessCentrality,T.ccn=T.closenessCentralityNormalised=T.closenessCentralityNormalized,_.exports=T},{"../../is":83}],8:[function(E,_){"use strict";var D=E("../../is"),T=E("../../util"),I={degreeCentralityNormalized:function(L){L=L||{};var O=this.cy();// directed - optional
if(null!=L.directed)var R=L.directed;else var R=!1;var F=this.nodes(),$=F.length;if(!R){var M={},U=0;for(var Z=0;Z<$;Z++){var G=F[Z],K=this.degreeCentrality(T.extend({},L,{root:G}));// add current node to the current options object and call degreeCentrality
U<K.degree&&(U=K.degree),M[G.id()]=K.degree}return{degree:function(ne){if(0==U)return 0;if(D.string(ne))// from is a selector string
var ne=O.filter(ne)[0].id();else// from is a node
var ne=ne.id();return M[ne]/U}}}var J={},ee={},te=0,ae=0;for(var Z=0;Z<$;Z++){var G=F[Z],K=this.degreeCentrality(T.extend({},L,{root:G}));// add current node to the current options object and call degreeCentrality
te<K.indegree&&(te=K.indegree),ae<K.outdegree&&(ae=K.outdegree),J[G.id()]=K.indegree,ee[G.id()]=K.outdegree}return{indegree:function(ne){if(0==te)return 0;if(D.string(ne))// from is a selector string
var ne=O.filter(ne)[0].id();else// from is a node
var ne=ne.id();return J[ne]/te},outdegree:function(ne){if(0==ae)return 0;if(D.string(ne))// from is a selector string
var ne=O.filter(ne)[0].id();else// from is a node
var ne=ne.id();return ee[ne]/ae}}},// degreeCentralityNormalized
// Implemented from the algorithm in Opsahl's paper
// "Node centrality in weighted networks: Generalizing degree and shortest paths"
// check the heading 2 "Degree"
degreeCentrality:function(L){L=L||{};var O=this;// root - mandatory!
if(null!=L&&null!=L.root)var R=D.string(L.root)?this.filter(L.root)[0]:L.root[0];else return void 0;// weight - optional
if(null!=L.weight&&D.fn(L.weight))var F=L.weight;else// If not specified, assume each edge has equal weight (1)
var F=function(){return 1};// directed - optional
if(null!=L.directed)var $=L.directed;else var $=!1;// alpha - optional
if(null!=L.alpha&&D.number(L.alpha))var M=L.alpha;else M=0;if(!$){var U=R.connectedEdges().intersection(O),Z=U.length,G=0;// Now, sum edge weights
for(var K=0;K<U.length;K++){var J=U[K];G+=F(J)}return{degree:Math.pow(Z,1-M)*Math.pow(G,M)}}var ee=R.connectedEdges("edge[target = \""+R.id()+"\"]").intersection(O),te=R.connectedEdges("edge[source = \""+R.id()+"\"]").intersection(O),ae=ee.length,ne=te.length,re=0,oe=0;// Now, sum incoming edge weights
for(var K=0;K<ee.length;K++){var J=ee[K];re+=F(J)}// Now, sum outgoing edge weights
for(var K=0;K<te.length;K++){var J=te[K];oe+=F(J)}return{indegree:Math.pow(ae,1-M)*Math.pow(re,M),outdegree:Math.pow(ne,1-M)*Math.pow(oe,M)}}// degreeCentrality
};// elesfn
// nice, short mathemathical alias
I.dc=I.degreeCentrality,I.dcn=I.degreeCentralityNormalised=I.degreeCentralityNormalized,_.exports=I},{"../../is":83,"../../util":99}],9:[function(E,_){"use strict";var D=E("../../is"),T=E("../../heap");_.exports={dijkstra:function(I,L,O){var R;D.plainObject(I)&&!D.elementOrCollection(I)&&(R=I,I=R.root,L=R.weight,O=R.directed);var F=this._private.cy;L=D.fn(L)?L:function(){return 1};// if not specified, assume each edge has equal weight (1)
var $=D.string(I)?this.filter(I)[0]:I[0],M={},U={},Z={},G=this.edges().filter(function(ye){return!ye.isLoop()}),K=this.nodes(),J=function(ye){return M[ye.id()]},ee=function(ye,me){M[ye.id()]=me,te.updateItem(ye)},te=new T(function(ye,me){return J(ye)-J(me)});for(var ae=0;ae<K.length;ae++){var ne=K[ae];M[ne.id()]=ne.same($)?0:1/0,te.push(ne)}for(var re=function(ye,me){var fe=(O?ye.edgesTo(me):ye.edgesWith(me)).intersect(G),xe=1/0,ve;for(var be=0;be<fe.length;be++){var we=fe[be],Ee=L(we);(Ee<xe||!ve)&&(xe=Ee,ve=we)}return{edge:ve,dist:xe}};0<te.size();){var oe=te.pop(),se=J(oe),le=oe.id();if(Z[le]=se,se===Math.Infinite)break;var pe=oe.neighborhood().intersect(K);for(var ae=0;ae<pe.length;ae++){var ue=pe[ae],ge=ue.id(),ce=re(oe,ue),he=se+ce.dist;he<J(ue)&&(ee(ue,he),U[ge]={node:oe,edge:ce.edge})}// for
}// while
return{distanceTo:function(ye){var me=D.string(ye)?K.filter(ye)[0]:ye[0];return Z[me.id()]},pathTo:function(ye){var me=D.string(ye)?K.filter(ye)[0]:ye[0],fe=[],xe=me;if(0<me.length)for(fe.unshift(me);U[xe.id()];){var ve=U[xe.id()];fe.unshift(ve.edge),fe.unshift(ve.node),xe=ve.node}return F.collection(fe)}}}}},{"../../heap":81,"../../is":83}],10:[function(E,_){"use strict";var D=E("../../is");_.exports={// Implemented from pseudocode from wikipedia
floydWarshall:function(T){T=T||{};var I=this.cy();// Weight function - optional
if(null!=T.weight&&D.fn(T.weight))var L=T.weight;else// If not specified, assume each edge has equal weight (1)
var L=function(){return 1};// directed - optional
if(null!=T.directed)var O=T.directed;else var O=!1;var R=this.edges().stdFilter(function(le){return!le.isLoop()}),F=this.nodes(),$=F.length,M={};// mapping: node id -> position in nodes array
for(var U=0;U<$;U++)M[F[U].id()]=U;// Initialize distance matrix
var Z=[];for(var U=0;U<$;U++){var G=Array($);for(var K=0;K<$;K++)G[K]=U==K?0:1/0;Z.push(G)}// Initialize matrix used for path reconstruction
// Initialize distance matrix
var J=[],ee=[],te=function(le){for(var pe=0;pe<$;pe++){var ue=Array($);for(var ge=0;ge<$;ge++)ue[ge]=void 0;le.push(ue)}};te(J),te(ee);// Process edges
for(var U=0;U<R.length;U++){var ae=M[R[U].source().id()],ne=M[R[U].target().id()],re=L(R[U]);// Check if already process another edge between same 2 nodes
Z[ae][ne]>re&&(Z[ae][ne]=re,J[ae][ne]=ne,ee[ae][ne]=R[U])}// If undirected graph, process 'reversed' edges
if(!O)for(var U=0;U<R.length;U++){var ae=M[R[U].target().id()],ne=M[R[U].source().id()],re=L(R[U]);Z[ae][ne]>re&&(Z[ae][ne]=re,J[ae][ne]=ne,ee[ae][ne]=R[U])}// Main loop
for(var oe=0;oe<$;oe++)for(var U=0;U<$;U++)for(var K=0;K<$;K++)Z[U][oe]+Z[oe][K]<Z[U][K]&&(Z[U][K]=Z[U][oe]+Z[oe][K],J[U][K]=J[U][oe]);// Build result object
var se=[];for(var U=0;U<$;U++)se.push(F[U].id());return{distance:function(le,pe){if(D.string(le))// from is a selector string
var ue=I.filter(le)[0].id();else// from is a node
var ue=le.id();if(D.string(pe))// to is a selector string
var ge=I.filter(pe)[0].id();else// to is a node
var ge=pe.id();return Z[M[ue]][M[ge]]},path:function(le,pe){if(D.string(le))// from is a selector string
var ue=I.filter(le)[0].id();else// from is a node
var ue=le.id();if(D.string(pe))// to is a selector string
var ge=I.filter(pe)[0].id();else// to is a node
var ge=pe.id();var ce=function(he,ye,me,fe,xe){if(he===ye)return I.getElementById(fe[he]);if(void 0===me[he][ye])return void 0;for(var ve=[I.getElementById(fe[he])],be=he;he!==ye;){be=he,he=me[he][ye];var we=xe[be][he];ve.push(we),ve.push(I.getElementById(fe[he]))}return ve}(M[ue],M[ge],J,se,ee);return I.collection(ce)}}}// floydWarshall
}},{"../../is":83}],11:[function(E,_){"use strict";var D=E("../../util"),T={};[E("./bfs-dfs"),E("./dijkstra"),E("./kruskal"),E("./a-star"),E("./floyd-warshall"),E("./bellman-ford"),E("./kerger-stein"),E("./page-rank"),E("./degree-centrality"),E("./closeness-centrality"),E("./betweenness-centrality")].forEach(function(I){D.extend(T,I)}),_.exports=T},{"../../util":99,"./a-star":3,"./bellman-ford":4,"./betweenness-centrality":5,"./bfs-dfs":6,"./closeness-centrality":7,"./degree-centrality":8,"./dijkstra":9,"./floyd-warshall":10,"./kerger-stein":12,"./kruskal":13,"./page-rank":14}],12:[function(E,_){"use strict";var D=E("../../util");_.exports={// Computes the minimum cut of an undirected graph
// Returns the correct answer with high probability
kargerStein:function(T){var I=this;T=T||{};// Function which colapses 2 (meta) nodes into one
// Updates the remaining edge lists
// Receives as a paramater the edge which causes the collapse
var L=function(ve,be,we){var Ee=we[ve],Se=Ee[1],_e=Ee[2],Pe=be[Se],Ce=be[_e],De=we.filter(function(Ie){return be[Ie[1]]===Pe&&be[Ie[2]]===Ce?!1:be[Ie[1]]===Ce&&be[Ie[2]]===Pe?!1:!0});// Delete all edges between partition1 and partition2
// All edges pointing to partition2 should now point to partition1
for(var Te=0;Te<De.length;Te++){var ke=De[Te];ke[1]===Ce?(De[Te]=ke.slice(0),De[Te][1]=Pe):ke[2]===Ce&&(De[Te]=ke.slice(0),De[Te][2]=Pe)}// Move all nodes from partition2 to partition1
for(var Te=0;Te<be.length;Te++)be[Te]===Ce&&(be[Te]=Pe);return De},O=function(ve,be,we,Ee){// Stop condition
if(we<=Ee)return be;// Choose an edge randomly
var Se=Math.floor(Math.random()*be.length),_e=L(Se,ve,be);// Colapse graph based on edge
return O(ve,_e,we-1,Ee)},R=this._private.cy,F=this.edges().stdFilter(function(ve){return!ve.isLoop()}),$=this.nodes(),M=$.length,U=F.length,Z=Math.ceil(Math.pow(Math.log(M)/Math.LN2,2)),G=Math.floor(M/Math.sqrt(2));// Contracts a graph until we reach a certain number of meta nodes
if(2>M)return D.error("At least 2 nodes are required for Karger-Stein algorithm"),void 0;// Create numerical identifiers for each node
// mapping: node id -> position in nodes array
// for reverse mapping, simply use nodes array
var K={};for(var J=0;J<M;J++)K[$[J].id()]=J;// Now store edge destination as indexes
// Format for each edge (edge index, source node index, target node index)
var ee=[];for(var J=0;J<U;J++){var te=F[J];ee.push([J,K[te.source().id()],K[te.target().id()]])}// We will store the best cut found here
var ae=1/0,ne,re=[];// Initial meta node partition
for(var J=0;J<M;J++)re.push(J);// Main loop
for(var oe=0;oe<=Z;oe++){// Create new meta node partition
var se=re.slice(0),le=O(se,ee,M,G),pe=se.slice(0),ue=O(se,le,G,2),ge=O(pe,le,G,2);// Contract until stop point (stopSize nodes)
// Create a copy of the colapsed nodes state
// Run 2 iterations starting in the stop state
// Is any of the 2 results the best cut so far?
ue.length<=ge.length&&ue.length<ae?(ae=ue.length,ne=[ue,se]):ge.length<=ue.length&&ge.length<ae&&(ae=ge.length,ne=[ge,pe])}// end of main loop
// Construct result
var ce=ne[0].map(function(ve){return F[ve[0]]}),he=[],ye=[],me=ne[1][0];// traverse metaNodeMap for best cut
for(var J=0;J<ne[1].length;J++){var fe=ne[1][J];fe===me?he.push($[J]):ye.push($[J])}var xe={cut:I.spawn(R,ce),partition1:I.spawn(he),partition2:I.spawn(ye)};return xe}}},{"../../util":99}],13:[function(E,_){"use strict";var D=E("../../is");// search, spanning trees, etc
_.exports={// kruskal's algorithm (finds min spanning tree, assuming undirected graph)
// implemented from pseudocode from wikipedia
kruskal:function(T){// if not specified, assume each edge has equal weight (1)
function I(te){for(var ae=0;ae<R.length;ae++){var ne=R[ae];if(ne.anySame(te))return{eles:ne,index:ae}}}var L=this.cy();T=D.fn(T)?T:function(){return 1};var O=L.collection(L,[]),R=[],F=this.nodes();for(var $=0;$<F.length;$++)R.push(F[$].collection());var M=this.edges(),U=M.toArray().sort(function(te,ae){var ne=T(te),re=T(ae);return ne-re});for(var $=0;$<U.length;$++){var Z=U[$],G=Z.source()[0],K=Z.target()[0],J=I(G),ee=I(K);J.index!==ee.index&&(O=O.add(Z),R[J.index]=J.eles.add(ee.eles),R.splice(ee.index,1))}return F.add(O)}}},{"../../is":83}],14:[function(E,_){"use strict";var D=E("../../is");_.exports={pageRank:function(T){T=T||{};var I=function(fe){var xe=fe.length,ve=0;// First, get sum of all elements
for(var be=0;be<xe;be++)ve+=fe[be];// Now, divide each by the sum of all elements
for(var be=0;be<xe;be++)fe[be]=fe[be]/ve};// dampingFactor - optional
if(null!=T&&null!=T.dampingFactor)var L=T.dampingFactor;else var L=0.8;// Default damping factor
// desired precision - optional
if(null!=T&&null!=T.precision)var O=T.precision;else var O=0.000001;// Default precision
// Max number of iterations - optional
if(null!=T&&null!=T.iterations)var R=T.iterations;else var R=200;// Default number of iterations
// Weight function - optional
if(null!=T&&null!=T.weight&&D.fn(T.weight))var F=T.weight;else// If not specified, assume each edge has equal weight (1)
var F=function(){return 1};var $=this._private.cy,M=this.edges().stdFilter(function(fe){return!fe.isLoop()}),U=this.nodes(),Z=U.length,G=M.length,K={};// Create numerical identifiers for each node
// mapping: node id -> position in nodes array
// for reverse mapping, simply use nodes array
for(var J=0;J<Z;J++)K[U[J].id()]=J;// Construct transposed adjacency matrix
// First lets have a zeroed matrix of the right size
// We'll also keep track of the sum of each column
var ee=[],te=[],ae=(1-L)/Z;// Create null matric
for(var J=0;J<Z;J++){var ne=[];for(var re=0;re<Z;re++)ne.push(0);ee.push(ne),te.push(0)}// Now, process edges
for(var J=0;J<G;J++){var oe=M[J],se=K[oe.source().id()],le=K[oe.target().id()],pe=F(oe);// Update matrix
ee[le][se]+=pe,te[se]+=pe}// Add additional probability based on damping factor
// Also, take into account columns that have sum = 0
// Shorthand
// Traverse matrix, column by column
for(var re=0;re<Z;re++)if(0===te[re])// No 'links' out from node jth, assume equal probability for each possible node
for(var J=0;J<Z;J++)ee[J][re]=1/Z+ae;else// Node jth has outgoing link, compute normalized probabilities
for(var J=0;J<Z;J++)ee[J][re]=ee[J][re]/te[re]+ae;// Compute dominant eigenvector using power method
var ue=[],ge=[],ce;// Start with a vector of all 1's
// Also, initialize a null vector which will be used as shorthand
for(var J=0;J<Z;J++)ue.push(1),ge.push(0);for(var he=0;he<R;he++){// New array with all 0's
var ye=ge.slice(0);// Multiply matrix with previous result
for(var J=0;J<Z;J++)for(var re=0;re<Z;re++)ye[J]+=ee[J][re]*ue[re];I(ye),ce=ue,ue=ye;var me=0;// Compute difference (squared module) of both vectors
for(var J=0;J<Z;J++)me+=Math.pow(ce[J]-ue[J],2);// If difference is less than the desired threshold, stop iterating
if(me<O)break}// Construct result
return{rank:function(fe){if(D.string(fe))// is a selector string
var xe=$.filter(fe)[0].id();else// is a node object
var xe=fe.id();return ue[K[xe]]}}}// pageRank
}},{"../../is":83}],15:[function(E,_){"use strict";var D=E("../define"),T={animate:D.animate(),animation:D.animation(),animated:D.animated(),clearQueue:D.clearQueue(),delay:D.delay(),delayAnimation:D.delayAnimation(),stop:D.stop()};_.exports=T},{"../define":44}],16:[function(E,_){"use strict";var D=E("../util");_.exports={classes:function(T){T=T.match(/\S+/g)||[];var I=this,L=[],O={};// fill in classes map
for(var R=0;R<T.length;R++){var F=T[R];O[F]=!0}// check and update each ele
for(var $=0;$<I.length;$++){var M=I[$],U=M._private,Z=U.classes,G=!1;// check if ele has all of the passed classes
for(var R=0;R<T.length;R++){var F=T[R],K=Z[F];if(!K){G=!0;break}}// check if ele has classes outside of those passed
if(!G){var T=Object.keys(Z);for(var R=0;R<T.length;R++){var J=T[R],K=Z[J],ee=O[J];// i.e. this class is passed to the function
if(K&&!ee){G=!0;break}}}G&&(U.classes=D.copy(O),L.push(M))}// trigger update style on those eles that had class changes
return 0<L.length&&this.spawn(L).updateStyle().trigger("class"),I},addClass:function(T){return this.toggleClass(T,!0)},hasClass:function(T){var I=this[0];return null!=I&&I._private.classes[T]},toggleClass:function(T,I){var L=T.match(/\S+/g)||[],O=this,R=[];// eles who had classes changed
for(var F=0,$=O.length;F<$;F++){var M=O[F],U=!1;for(var Z=0;Z<L.length;Z++){var G=L[Z],K=M._private.classes,J=K[G],ee=I||void 0===I&&!J;ee?(K[G]=!0,!J&&!U&&(R.push(M),U=!0)):(K[G]=!1,J&&!U&&(R.push(M),U=!0))}// for j classes
}// for i eles
// trigger update style on those eles that had class changes
return 0<R.length&&this.spawn(R).updateStyle().trigger("class"),O},removeClass:function(T){return this.toggleClass(T,!1)},flashClass:function(T,I){var L=this;if(null==I)I=250;else if(0===I)return L;// nothing to do really
return L.addClass(T),setTimeout(function(){L.removeClass(T)},I),L}}},{"../util":99}],17:[function(E,_){"use strict";var D={allAre:function(T){return this.filter(T).length===this.length},is:function(T){return 0<this.filter(T).length},some:function(T,I){for(var L=0;L<this.length;L++){var O=I?T.apply(I,[this[L],L,this]):T(this[L],L,this);if(O)return!0}return!1},every:function(T,I){for(var L=0;L<this.length;L++){var O=I?T.apply(I,[this[L],L,this]):T(this[L],L,this);if(!O)return!1}return!0},same:function(T){// cheap extra check
return T=this.cy().collection(T),this.length===T.length&&this.intersect(T).length===this.length},anySame:function(T){return T=this.cy().collection(T),0<this.intersect(T).length},allAreNeighbors:function(T){return T=this.cy().collection(T),this.neighborhood().intersect(T).length===T.length}};D.allAreNeighbours=D.allAreNeighbors,_.exports=D},{}],18:[function(E,_){"use strict";var D={parent:function(T){var I=[],L=this._private.cy;for(var O=0;O<this.length;O++){var R=this[O],F=L.getElementById(R._private.data.parent);0<F.size()&&I.push(F)}return this.spawn(I,{unique:!0}).filter(T)},parents:function(T){for(var I=[],L=this.parent();L.nonempty();){for(var O=0;O<L.length;O++){var R=L[O];I.push(R)}L=L.parent()}return this.spawn(I,{unique:!0}).filter(T)},commonAncestors:function(T){var I;for(var L=0;L<this.length;L++){var O=this[L],R=O.parents();I=I||R,I=I.intersect(R)}return I.filter(T)},orphans:function(T){return this.stdFilter(function(I){return I.isNode()&&I.parent().empty()}).filter(T)},nonorphans:function(T){return this.stdFilter(function(I){return I.isNode()&&I.parent().nonempty()}).filter(T)},children:function(T){var I=[];for(var L=0;L<this.length;L++){var O=this[L];I=I.concat(O._private.children)}return this.spawn(I,{unique:!0}).filter(T)},siblings:function(T){return this.parent().children().not(this).filter(T)},isParent:function(){var T=this[0];if(T)return 0!==T._private.children.length},isChild:function(){var T=this[0];if(T)return void 0!==T._private.data.parent&&0!==T.parent().length},descendants:function(T){function I(O){for(var R=0;R<O.length;R++){var F=O[R];L.push(F),F.children().nonempty()&&I(F.children())}}var L=[];return I(this.children()),this.spawn(L,{unique:!0}).filter(T)}};// aliases
D.ancestors=D.parents,_.exports=D},{}],19:[function(E,_){"use strict";var D=E("../define"),T,I;T=I={data:D.data({field:"data",bindingEvent:"data",allowBinding:!0,allowSetting:!0,settingEvent:"data",settingTriggersEvent:!0,triggerFnName:"trigger",allowGetting:!0,immutableKeys:{id:!0,source:!0,target:!0,parent:!0},updateStyle:!0}),removeData:D.removeData({field:"data",event:"data",triggerFnName:"trigger",triggerEvent:!0,immutableKeys:{id:!0,source:!0,target:!0,parent:!0},updateStyle:!0}),scratch:D.data({field:"scratch",bindingEvent:"scratch",allowBinding:!0,allowSetting:!0,settingEvent:"scratch",settingTriggersEvent:!0,triggerFnName:"trigger",allowGetting:!0,updateStyle:!0}),removeScratch:D.removeData({field:"scratch",event:"scratch",triggerFnName:"trigger",triggerEvent:!0,updateStyle:!0}),rscratch:D.data({field:"rscratch",allowBinding:!1,allowSetting:!0,settingTriggersEvent:!1,allowGetting:!0}),removeRscratch:D.removeData({field:"rscratch",triggerEvent:!1}),id:function(){var L=this[0];if(L)return L._private.data.id}},T.attr=T.data,T.removeAttr=T.removeData,_.exports=I},{"../define":44}],20:[function(E,_){"use strict";function D(O){return function(R){var F=this;if((void 0===R&&(R=!0),0!==F.length)&&F.isNode()&&!F.removed()){var $=0,M=F[0],U=M._private.edges;for(var Z=0;Z<U.length;Z++){var G=U[Z];(R||!G.isLoop())&&($+=O(M,G))}return $}}}function T(O,R){return function(F){var $,M=this.nodes();for(var U=0;U<M.length;U++){var Z=M[U],G=Z[O](F);G!==void 0&&($==void 0||R(G,$))&&($=G)}return $}}var I=E("../util"),L={};I.extend(L,{degree:D(function(O,R){return R.source().same(R.target())?2:1}),indegree:D(function(O,R){return R.target().same(O)?1:0}),outdegree:D(function(O,R){return R.source().same(O)?1:0})}),I.extend(L,{minDegree:T("degree",function(O,R){return O<R}),maxDegree:T("degree",function(O,R){return O>R}),minIndegree:T("indegree",function(O,R){return O<R}),maxIndegree:T("indegree",function(O,R){return O>R}),minOutdegree:T("outdegree",function(O,R){return O<R}),maxOutdegree:T("outdegree",function(O,R){return O>R})}),I.extend(L,{totalDegree:function(O){var R=0,F=this.nodes();for(var $=0;$<F.length;$++)R+=F[$].degree(O);return R}}),_.exports=L},{"../util":99}],21:[function(E,_){"use strict";var D=E("../define"),T=E("../is"),I=E("../util"),L=E("../math"),O,R;O=R={position:D.data({field:"position",bindingEvent:"position",allowBinding:!0,allowSetting:!0,settingEvent:"position",settingTriggersEvent:!0,triggerFnName:"rtrigger",allowGetting:!0,validKeys:["x","y"],onSet:function(oe){var se=oe.updateCompoundBounds();se.rtrigger("position")},canSet:function(oe){return!oe.locked()&&!oe.isParent()}}),// position but no notification to renderer
silentPosition:D.data({field:"position",bindingEvent:"position",allowBinding:!1,allowSetting:!0,settingEvent:"position",settingTriggersEvent:!1,triggerFnName:"trigger",allowGetting:!0,validKeys:["x","y"],onSet:function(oe){oe.updateCompoundBounds()},canSet:function(oe){return!oe.locked()&&!oe.isParent()}}),positions:function(oe,se){if(T.plainObject(oe))this.position(oe);else if(T.fn(oe)){for(var le=0;le<this.length;le++){var pe=this[le],oe=oe(pe,le);if(oe&&!pe.locked()&&!pe.isParent()){var ue=pe._private.position;ue.x=oe.x,ue.y=oe.y}}var ge=this.updateCompoundBounds(),ce=0<ge.length?this.add(ge):this;se?ce.trigger("position"):ce.rtrigger("position")}return this;// chaining
},silentPositions:function(oe){return this.positions(oe,!0)},// get/set the rendered (i.e. on screen) positon of the element
renderedPosition:function(oe,se){var le=this[0],pe=this.cy(),ue=pe.zoom(),ge=pe.pan(),ce=T.plainObject(oe)?oe:void 0,he=ce!==void 0||se!==void 0&&T.string(oe);if(le&&le.isNode()){// must have an element and must be a node to return position
if(he){for(var ye=0;ye<this.length;ye++){var le=this[ye];void 0===se?void 0!==ce&&(le._private.position={x:(ce.x-ge.x)/ue,y:(ce.y-ge.y)/ue}):le._private.position[oe]=(se-ge[oe])/ue}this.rtrigger("position")}else{// getting
var me=le._private.position;return(ce={x:me.x*ue+ge.x,y:me.y*ue+ge.y},void 0===oe)?ce:ce[oe];// then return the specified dimension
}}else if(!he)return void 0;// for empty collection case
return this;// chaining
},// get/set the position relative to the parent
relativePosition:function(oe,se){var le=this[0],pe=this.cy(),ue=T.plainObject(oe)?oe:void 0,ge=ue!==void 0||se!==void 0&&T.string(oe),ce=pe.hasCompoundNodes();if(le&&le.isNode()){// must have an element and must be a node to return position
if(ge){for(var he=0;he<this.length;he++){var le=this[he],ye=ce?le.parent():null,me=ye&&0<ye.length,fe=me;me&&(ye=ye[0]);var xe=fe?ye._private.position:{x:0,y:0};void 0===se?void 0!==ue&&(le._private.position={x:ue.x+xe.x,y:ue.y+xe.y}):le._private.position[oe]=se+xe[oe]}this.rtrigger("position")}else{// getting
var ve=le._private.position,ye=ce?le.parent():null,me=ye&&0<ye.length,fe=me;me&&(ye=ye[0]);var xe=fe?ye._private.position:{x:0,y:0};return(ue={x:ve.x-xe.x,y:ve.y-xe.y},void 0===oe)?ue:ue[oe];// then return the specified dimension
}}else if(!ge)return void 0;// for empty collection case
return this;// chaining
},renderedBoundingBox:function(oe){var se=this.boundingBox(oe),le=this.cy(),pe=le.zoom(),ue=le.pan(),ge=se.x1*pe+ue.x,ce=se.x2*pe+ue.x,he=se.y1*pe+ue.y,ye=se.y2*pe+ue.y;return{x1:ge,x2:ce,y1:he,y2:ye,w:ce-ge,h:ye-he}},updateCompoundBounds:function(){function oe(ce){if(ce.isParent()){var he=ce._private,ye=ce.children(),me="include"===ce.pstyle("compound-sizing-wrt-labels").value,fe=ye.boundingBox({includeLabels:me,includeShadows:!1,includeOverlays:!1,// updating the compound bounds happens outside of the regular
// cache cycle (i.e. before fired events)
useCache:!1}),xe={top:ce.pstyle("padding-top").pfValue,bottom:ce.pstyle("padding-bottom").pfValue,left:ce.pstyle("padding-left").pfValue,right:ce.pstyle("padding-right").pfValue},ve=he.position;he.autoWidth=fe.w,ve.x=(fe.x1+fe.x2-xe.left+xe.right)/2,he.autoHeight=fe.h,ve.y=(fe.y1+fe.y2-xe.top+xe.bottom)/2,le.push(ce)}}// go up, level by level
var se=this.cy();// save cycles for non compound graphs or when style disabled
if(!se.styleEnabled()||!se.hasCompoundNodes())return se.collection();for(var le=[],pe=this;pe.nonempty();){// update each parent node in this level
for(var ue=0;ue<pe.length;ue++){var ge=pe[ue];oe(ge)}// next level
pe=pe.parent()}// return changed
return this.spawn(le)}};var F=function(oe){return oe===1/0||oe===-(1/0)?0:oe},$=function(oe,se,le,pe,ue){// don't update with zero area boxes
if(0!=pe-se&&0!=ue-le){var ge=oe.x1;oe.x1=se<ge?se:ge;var ce=oe.x2;oe.x2=pe>ce?pe:ce;var he=oe.y1;oe.y1=le<he?le:he;var ye=oe.y2;oe.y2=ue>ye?ue:ye}},M=function(oe,se){return $(oe,se.x1,se.y1,se.x2,se.y2)},U=function(oe,se,le){return I.getPrefixedProperty(oe,se,le)},Z=function(oe,se,le){var pe=se._private,ue=pe.rstyle,ge=ue.arrowWidth/2,ce=se.pstyle(le+"-arrow-shape").value,he,ye;"none"!==ce&&("source"===le?(he=ue.srcX,ye=ue.srcY):"target"===le?(he=ue.tgtX,ye=ue.tgtY):(he=ue.midX,ye=ue.midY),$(oe,he-ge,ye-ge,he+ge,ye+ge))},G=function(oe,se,le,pe){const ue=le?le+"-":"";var ge=se._private,ce=ge.rstyle,he=se.pstyle(ue+"label").strValue;if(he){var ye=se.pstyle("text-halign"),me=se.pstyle("text-valign"),fe=U(ce,"labelWidth",le),xe=U(ce,"labelHeight",le),ve=U(ce,"labelX",le),be=U(ce,"labelY",le),we=se.pstyle(ue+"text-margin-x").pfValue,Ee=se.pstyle(ue+"text-margin-y").pfValue,Se=se.isEdge(),_e=se.pstyle(ue+"text-rotation"),Pe=se.pstyle("text-shadow-blur").pfValue/2,Ce=se.pstyle("text-shadow-offset-x").pfValue,De=se.pstyle("text-shadow-offset-y").pfValue,Te=se.pstyle("text-shadow-opacity").value,ke=se.pstyle("text-outline-width").pfValue,Ie=se.pstyle("text-border-width").pfValue,Ne=Ie/2,ze=xe,Be=fe,Le=Be/2,Oe=ze/2,Ae,je,Re,qe;if(Se)Ae=ve-Le,je=ve+Le,Re=be-Oe,qe=be+Oe;else{switch(ye.value){case"left":Ae=ve-Be,je=ve;break;case"center":Ae=ve-Le,je=ve+Le;break;case"right":Ae=ve,je=ve+Be;}switch(me.value){case"top":Re=be-ze,qe=be;break;case"center":Re=be-Oe,qe=be+Oe;break;case"bottom":Re=be,qe=be+ze;}}var Ve=Se&&"autorotate"===_e.strValue,Fe=null!=_e.pfValue&&0!==_e.pfValue;if(Ve||Fe){var Xe=Ve?U(ge.rstyle,"labelAngle",le):_e.pfValue,Ye=Math.cos(Xe),We=Math.sin(Xe),He=function(Ge,Ke){return Ge=Ge-ve,Ke=Ke-be,{x:Ge*Ye-Ke*We+ve,y:Ge*We+Ke*Ye+be}},$e=He(Ae,Re),Me=He(Ae,qe),Ue=He(je,Re),Ze=He(je,qe);Ae=Math.min($e.x,Me.x,Ue.x,Ze.x),je=Math.max($e.x,Me.x,Ue.x,Ze.x),Re=Math.min($e.y,Me.y,Ue.y,Ze.y),qe=Math.max($e.y,Me.y,Ue.y,Ze.y)}Ae+=we-Math.max(ke,Ne),je+=we+Math.max(ke,Ne),Re+=Ee-Math.max(ke,Ne),qe+=Ee+Math.max(ke,Ne),$(oe,Ae,Re,je,qe),pe.includeShadows&&0<Te&&(Ae+=-Pe+Ce,je+=+Pe+Ce,Re+=-Pe+De,qe+=+Pe+De,$(oe,Ae,Re,je,qe))}return oe},K=function(oe,se){var le=oe._private.cy,pe=le._private,ue=pe.styleEnabled,ge={x1:1/0,y1:1/0,x2:-(1/0),y2:-(1/0)},ce=oe._private,he=ue?oe.pstyle("display").value:"element",ye=oe.isNode(),me=oe.isEdge(),Se="none"!==he,fe,xe,ve,be,we,Ee;if(Se){var _e=0,Pe=0;ue&&se.includeOverlays&&(_e=oe.pstyle("overlay-opacity").value,0!=_e&&(Pe=oe.pstyle("overlay-padding").value));var Ce=0,De=0;if(ue&&(Ce=oe.pstyle("width").pfValue,De=Ce/2),ye&&se.includeNodes){var Te=ce.position;we=Te.x,Ee=Te.y;var Ce=oe.outerWidth(),ke=Ce/2,Ie=oe.outerHeight(),Ne=Ie/2;fe=we-ke-Pe,xe=we+ke+Pe,ve=Ee-Ne-Pe,be=Ee+Ne+Pe,$(ge,fe,ve,xe,be)}else if(me&&se.includeEdges){var ze=ce.rstyle||{};// handle edge dimensions (rough box estimate)
//////////////////////////////////////////////
// precise haystacks
////////////////////
if(ue&&(fe=Math.min(ze.srcX,ze.midX,ze.tgtX),xe=Math.max(ze.srcX,ze.midX,ze.tgtX),ve=Math.min(ze.srcY,ze.midY,ze.tgtY),be=Math.max(ze.srcY,ze.midY,ze.tgtY),fe-=De,xe+=De,ve-=De,be+=De,$(ge,fe,ve,xe,be)),ue&&"haystack"===oe.pstyle("curve-style").strValue){var Be=ze.haystackPts;if(fe=Be[0].x,ve=Be[0].y,xe=Be[1].x,be=Be[1].y,fe>xe){var Le=fe;fe=xe,xe=Le}if(ve>be){var Le=ve;ve=be,be=Le}$(ge,fe-De,ve-De,xe+De,be+De)}else{var Oe=ze.bezierPts||ze.linePts||[];for(var Ae=0;Ae<Oe.length;Ae++){var je=Oe[Ae];fe=je.x-De,xe=je.x+De,ve=je.y-De,be=je.y+De,$(ge,fe,ve,xe,be)}// fallback on source and target positions
//////////////////////////////////////////
if(0===Oe.length){var Re=ce.source,qe=Re._private,Ve=qe.position,Fe=ce.target,Xe=Fe._private,Ye=Xe.position;if(fe=Ve.x,xe=Ye.x,ve=Ve.y,be=Ye.y,fe>xe){var Le=fe;fe=xe,xe=Le}if(ve>be){var Le=ve;ve=be,be=Le}// take into account edge width
fe-=De,xe+=De,ve-=De,be+=De,$(ge,fe,ve,xe,be)}}}// edges
// shadow and overlay
/////////////////////
if(ue){if(fe=ge.x1,xe=ge.x2,ve=ge.y1,be=ge.y2,se.includeShadows&&0<oe.pstyle("shadow-opacity").value){var We=oe.pstyle("shadow-blur").pfValue/2,He=oe.pstyle("shadow-offset-x").pfValue,$e=oe.pstyle("shadow-offset-y").pfValue;$(ge,fe-We+He,ve-We+$e,xe+We+He,be+We+$e)}$(ge,fe-Pe,ve-Pe,xe+Pe,be+Pe)}// handle edge arrow size
/////////////////////////
ue&&se.includeEdges&&me&&(Z(ge,oe,"mid-source",se),Z(ge,oe,"mid-target",se),Z(ge,oe,"source",se),Z(ge,oe,"target",se)),ue&&se.includeLabels&&(G(ge,oe,null,se),me&&(G(ge,oe,"source",se),G(ge,oe,"target",se)))}// if displayed
return ge.x1=F(ge.x1),ge.y1=F(ge.y1),ge.x2=F(ge.x2),ge.y2=F(ge.y2),ge.w=F(ge.x2-ge.x1),ge.h=F(ge.y2-ge.y1),0<ge.w&&0<ge.h&&Se&&L.expandBoundingBox(ge,1),ge},J=function(oe){return oe?"t":"f"},ee=function(oe){var se="";return se+=J(oe.incudeNodes),se+=J(oe.includeEdges),se+=J(oe.includeLabels),se+=J(oe.includeShadows),se+=J(oe.includeOverlays),se},te=function(oe,se){var le=oe._private,ue=oe.cy().headless(),ge=se===ae?ne:ee(se),pe;return se.useCache&&!ue&&le.bbCache&&le.bbCache[ge]?pe=le.bbCache[ge]:(pe=K(oe,se),!ue&&(le.bbCache=le.bbCache||{},le.bbCache[ge]=pe)),pe},ae={includeNodes:!0,includeEdges:!0,includeLabels:!0,includeShadows:!0,includeOverlays:!0,useCache:!0},ne=ee(ae);// get the bounding box of the elements (in raw model position)
R.recalculateRenderedStyle=function(oe){var se=this.cy(),le=se.renderer(),pe=se.styleEnabled();return le&&pe&&le.recalculateRenderedStyle(this,oe),this},R.boundingBox=function(oe){// the main usecase is ele.boundingBox() for a single element with no/def options
// specified s.t. the cache is used, so check for this case to make it faster by
// avoiding the overhead of the rest of the function
if(1===this.length&&this[0]._private.bbCache&&(void 0===oe||void 0===oe.useCache||!0===oe.useCache))return void 0==oe&&(oe=ae),te(this[0],oe);var se={x1:1/0,y1:1/0,x2:-(1/0),y2:-(1/0)};oe=oe||I.staticEmptyObject();var le={includeNodes:I.default(oe.includeNodes,ae.includeNodes),includeEdges:I.default(oe.includeEdges,ae.includeEdges),includeLabels:I.default(oe.includeLabels,ae.includeLabels),includeShadows:I.default(oe.includeShadows,ae.includeShadows),includeOverlays:I.default(oe.includeOverlays,ae.includeOverlays),useCache:I.default(oe.useCache,ae.useCache)},pe=this,ue=pe.cy(),ge=ue.styleEnabled();ge&&this.recalculateRenderedStyle(le.useCache);for(var ce=0;ce<pe.length;ce++){var he=pe[ce];ge&&he.isEdge()&&"bezier"===he.pstyle("curve-style").strValue&&he.parallelEdges().recalculateRenderedStyle(le.useCache),M(se,te(he,le))}return se.x1=F(se.x1),se.y1=F(se.y1),se.x2=F(se.x2),se.y2=F(se.y2),se.w=F(se.x2-se.x1),se.h=F(se.y2-se.y1),se};var re=function(oe){oe.uppercaseName=I.capitalize(oe.name),oe.autoName="auto"+oe.uppercaseName,oe.labelName="label"+oe.uppercaseName,oe.outerName="outer"+oe.uppercaseName,oe.uppercaseOuterName=I.capitalize(oe.outerName),O[oe.name]=function(){var le=this[0],pe=le._private,ue=pe.cy,ge=ue._private.styleEnabled;if(le)if(ge){if(le.isParent())return pe[oe.autoName]||0;var ce=le.pstyle(oe.name);switch(ce.strValue){case"label":return pe.rstyle[oe.labelName]||0;default:return ce.pfValue;}}else return 1},O["outer"+oe.uppercaseName]=function(){var le=this[0],pe=le._private,ue=pe.cy,ge=ue._private.styleEnabled;if(le){if(ge){var ce=le[oe.name](),he=le.pstyle("border-width").pfValue,ye=le.pstyle(oe.paddings[0]).pfValue+le.pstyle(oe.paddings[1]).pfValue;return ce+he+ye}return 1}},O["rendered"+oe.uppercaseName]=function(){var le=this[0];if(le){var pe=le[oe.name]();return pe*this.cy().zoom()}},O["rendered"+oe.uppercaseOuterName]=function(){var le=this[0];if(le){var pe=le[oe.outerName]();return pe*this.cy().zoom()}}};re({name:"width",paddings:["padding-left","padding-right"]}),re({name:"height",paddings:["padding-top","padding-bottom"]}),O.modelPosition=O.point=O.position,O.modelPositions=O.points=O.positions,O.renderedPoint=O.renderedPosition,O.relativePoint=O.relativePosition,O.boundingbox=O.boundingBox,O.renderedBoundingbox=O.renderedBoundingBox,_.exports=R},{"../define":44,"../is":83,"../math":84,"../util":99}],22:[function(E,_){"use strict";var D=E("../util"),T=E("../is");// represents a node or an edge
_.exports=function(I,L,O){var R=this;if(O=!!(void 0===O||O),void 0===I||void 0===L||!T.core(I))return void D.error("An element must have a core reference and parameters set");var F=L.data,$=L.group||(F&&null!=F.source&&null!=F.target?"edges":"nodes");// validate group
if("nodes"!==$&&"edges"!==$)return void D.error("An element must be of type `nodes` or `edges`; you specified `"+$+"`");// make the element array-like, just like a collection
// renderedPosition overrides if specified
if(this.length=1,this[0]=this,this._private={cy:I,single:!0,// indicates this is an element
data:F||{},// data object
position:L.position||{},// (x, y) position pair
autoWidth:void 0,// width and height of nodes calculated by the renderer when set to special 'auto' value
autoHeight:void 0,listeners:[],// array of bound listeners
group:$,// string; 'nodes' or 'edges'
style:{},// properties as set by the style
rstyle:{},// properties for style sent from the renderer to the core
styleCxts:[],// applied style contexts from the styler
removed:!0,// whether it's inside the vis; true if removed (set true here since we call restore)
selected:!!L.selected,// whether it's selected
selectable:void 0===L.selectable||!!L.selectable,// whether it's selectable
locked:!!L.locked,// whether the element is locked (cannot be moved)
grabbed:!1,// whether the element is grabbed by the mouse; renderer sets this privately
grabbable:void 0===L.grabbable||!!L.grabbable,// whether the element can be grabbed
active:!1,// whether the element is active from user interaction
classes:{},// map ( className => true )
animation:{// object for currently-running animations
current:[],queue:[]},rscratch:{},// object in which the renderer can store information
scratch:L.scratch||{},// scratch objects
edges:[],// array of connected edges
children:[],// array of children
traversalCache:{}// cache of output of traversal functions
},L.renderedPosition){var M=L.renderedPosition,U=I.pan(),Z=I.zoom();this._private.position={x:(M.x-U.x)/Z,y:(M.y-U.y)/Z}}var G=L.classes;if(T.string(G)){var G=G.split(/\s+/),K=R._private.classes;for(var J=0,ee=G.length;J<ee;J++){var te=G[J];te&&""!==te&&(K[te]=!0)}}(L.style||L.css)&&I.style().applyBypass(this,L.style||L.css),(void 0===O||O)&&this.restore()}},{"../is":83,"../util":99}],23:[function(E,_){"use strict";var D=E("../define"),T={on:D.on(),// .on( events [, selector] [, data], handler)
one:D.on({unbindSelfOnTrigger:!0}),once:D.on({unbindAllBindersOnTrigger:!0}),off:D.off(),// .off( events [, selector] [, handler] )
trigger:D.trigger(),// .trigger( events [, extraParams] )
rtrigger:function(I,L){// for internal use only
if(0!==this.length)return this.cy().notify({type:I,eles:this}),this.trigger(I,L),this;// empty collections don't need to notify anything
// notify renderer
}};// aliases:
D.eventAliasesOn(T),_.exports=T},{"../define":44}],24:[function(E,_){"use strict";var D=E("../is"),T=E("../selector"),I={nodes:function(O){return this.filter(function(R){return R.isNode()}).filter(O)},edges:function(O){return this.filter(function(R){return R.isEdge()}).filter(O)},filter:function(O,R){if(O===void 0)// check this first b/c it's the most common/performant case
return this;if(D.string(O)||D.elementOrCollection(O))return T(O).filter(this);if(D.fn(O)){var F=this.spawn(),$=this;for(var M=0;M<$.length;M++){var U=$[M],Z=R?O.apply(R,[U,M,$]):O(U,M,$);Z&&F.merge(U)}return F}return this.spawn();// if not handled by above, give 'em an empty collection
},not:function(O){if(!O)return this;D.string(O)&&(O=this.filter(O));var R=[];for(var F=0;F<this.length;F++){var $=this[F],M=O._private.ids[$.id()];M||R.push($)}return this.spawn(R)},absoluteComplement:function(){var O=this._private.cy;return O.mutableElements().not(this)},intersect:function(O){// if a selector is specified, then filter by it instead
if(D.string(O))return this.filter(O);var R=[],F=this,$=O,M=this.length<O.length,U=M?$._private.ids:F._private.ids,Z=M?F:$;// var ids1 = col1Smaller ? col1._private.ids : col2._private.ids;
for(var G=0;G<Z.length;G++){var K=Z[G]._private.data.id,J=U[K];J&&R.push(J)}return this.spawn(R)},xor:function(O){var R=this._private.cy;D.string(O)&&(O=R.$(O));var F=[],$=this,M=O,U=function(Z,G){for(var K=0;K<Z.length;K++){var J=Z[K],ee=J._private.data.id,te=G._private.ids[ee];te||F.push(J)}};return U($,M),U(M,$),this.spawn(F)},diff:function(O){var R=this._private.cy;D.string(O)&&(O=R.$(O));var F=[],$=[],M=[],U=this,Z=O,G=function(K,J,ee){for(var te=0;te<K.length;te++){var ae=K[te],ne=ae._private.data.id,re=J._private.ids[ne];re?M.push(ae):ee.push(ae)}};return G(U,Z,F),G(Z,U,$),{left:this.spawn(F,{unique:!0}),right:this.spawn($,{unique:!0}),both:this.spawn(M,{unique:!0})}},add:function(O){var R=this._private.cy;if(!O)return this;if(D.string(O)){var F=O;O=R.mutableElements().filter(F)}var $=[];for(var M=0;M<this.length;M++)$.push(this[M]);for(var M=0;M<O.length;M++){var U=!this._private.ids[O[M].id()];U&&$.push(O[M])}return this.spawn($)},// in place merge on calling collection
merge:function(O){var R=this._private,F=R.cy;if(!O)return this;if(O&&D.string(O)){var $=O;O=F.mutableElements().filter($)}for(var M=0;M<O.length;M++){var U=O[M],Z=U._private.data.id,G=!R.ids[Z];if(G){var K=this.length++;this[K]=U,R.ids[Z]=U,R.indexes[Z]=K}else{// replace
var K=R.indexes[Z];this[K]=U,R.ids[Z]=U}}return this;// chaining
},// remove single ele in place in calling collection
unmergeOne:function(O){O=O[0];var R=this._private,F=O._private.data.id,$=R.indexes[F];if(null==$)return this;// no need to remove
// remove ele
this[$]=void 0,R.ids[F]=void 0,R.indexes[F]=void 0;var M=$===this.length-1;// replace empty spot with last ele in collection
if(1<this.length&&!M){var U=this.length-1,Z=this[U],G=Z._private.data.id;this[U]=void 0,this[$]=Z,R.indexes[G]=$}// the collection is now 1 ele smaller
return this.length--,this},// remove eles in place on calling collection
unmerge:function(O){var R=this._private.cy;if(!O)return this;if(O&&D.string(O)){var F=O;O=R.mutableElements().filter(F)}for(var $=0;$<O.length;$++)this.unmergeOne(O[$]);return this;// chaining
},map:function(O,R){var F=[],$=this;for(var M=0;M<$.length;M++){var U=$[M],Z=R?O.apply(R,[U,M,$]):O(U,M,$);F.push(Z)}return F},max:function(O,R){var F=-(1/0),$,M=this;for(var U=0;U<M.length;U++){var Z=M[U],G=R?O.apply(R,[Z,U,M]):O(Z,U,M);G>F&&(F=G,$=Z)}return{value:F,ele:$}},min:function(O,R){var F=1/0,$,M=this;for(var U=0;U<M.length;U++){var Z=M[U],G=R?O.apply(R,[Z,U,M]):O(Z,U,M);G<F&&(F=G,$=Z)}return{value:F,ele:$}}},L=I;// aliases
L.u=L["|"]=L["+"]=L.union=L.or=L.add,L["\\"]=L["!"]=L["-"]=L.difference=L.relativeComplement=L.subtract=L.not,L.n=L["&"]=L["."]=L.and=L.intersection=L.intersect,L["^"]=L["(+)"]=L["(-)"]=L.symmetricDifference=L.symdiff=L.xor,L.fnFilter=L.filterFn=L.stdFilter=L.filter,L.complement=L.abscomp=L.absoluteComplement,_.exports=I},{"../is":83,"../selector":86}],25:[function(E,_){"use strict";_.exports={isNode:function(){return"nodes"===this.group()},isEdge:function(){return"edges"===this.group()},isLoop:function(){return this.isEdge()&&this.source().id()===this.target().id()},isSimple:function(){return this.isEdge()&&this.source().id()!==this.target().id()},group:function(){var D=this[0];if(D)return D._private.group}}},{}],26:[function(E,_){"use strict";var D=E("../util"),T=E("../is"),I=E("./element"),L={generate:function(F,$,M){for(var U=null==M?D.uuid():M;F.hasElementWithId(U);)U=D.uuid();return U}},O=function(F,$,M){if(void 0===F||!T.core(F))return void D.error("A collection must have a reference to the core");var U={},Z={},G=!1;if(!$)$=[];else if(0<$.length&&T.plainObject($[0])&&!T.element($[0])){G=!0;// make elements from json and restore all at once later
var K=[],J={};for(var ee=0,te=$.length;ee<te;ee++){var ae=$[ee];null==ae.data&&(ae.data={});var ne=ae.data;// make sure newly created elements have valid ids
if(null==ne.id)ne.id=L.generate(F,ae);else if(F.hasElementWithId(ne.id)||J[ne.id])continue;// can't create element if prior id already exists
var re=new I(F,ae,!1);K.push(re),J[ne.id]=!0}$=K}this.length=0;for(var ee=0,te=$.length;ee<te;ee++){var oe=$[ee];if(oe){var se=oe._private.data.id;M&&(!M.unique||U[se])||(U[se]=oe,Z[se]=this.length,this[this.length]=oe,this.length++)}}this._private={cy:F,ids:U,indexes:Z},G&&this.restore()},R=I.prototype=O.prototype;// factory for generating edge ids when no id is specified for a new element
// represents a set of nodes, edges, or both together
// Functions
////////////////////////////////////////////////////////////////////////////////////////////////////
// keep the prototypes in sync (an element has the same functions as a collection)
// and use elefn and elesfn as shorthands to the prototypes
R.instanceString=function(){return"collection"},R.spawn=function(F,$,M){return T.core(F)||(M=$,$=F,F=this.cy()),new O(F,$,M)},R.spawnSelf=function(){return this.spawn(this)},R.cy=function(){return this._private.cy},R.element=function(){return this[0]},R.collection=function(){return T.collection(this)?this:new O(this._private.cy,[this])},R.unique=function(){return new O(this._private.cy,this,{unique:!0})},R.hasElementWithId=function(F){return!!this._private.ids[F]},R.getElementById=function(F){var $=this._private.cy,M=this._private.ids[F];return M?M:new O($);// get ele or empty collection
},R.poolIndex=function(){var F=this._private.cy,$=F._private.elements,M=this._private.data.id;return $._private.indexes[M]},R.json=function(F){var $=this.element(),M=this.cy();if(null==$&&F)return this;// can't set to no eles
if(null==$)return void 0;// can't get from no eles
var U=$._private;if(T.plainObject(F)){M.startBatch(),F.data&&$.data(F.data),F.position&&$.position(F.position);// ignore group -- immutable
var Z=function(K,J,ee){var te=F[K];null!=te&&te!==U[K]&&(te?$[J]():$[ee]())};return Z("removed","remove","restore"),Z("selected","select","unselect"),Z("selectable","selectify","unselectify"),Z("locked","lock","unlock"),Z("grabbable","grabify","ungrabify"),null!=F.classes&&$.classes(F.classes),M.endBatch(),this}if(void 0===F){// get
var G={data:D.copy(U.data),position:D.copy(U.position),group:U.group,removed:U.removed,selected:U.selected,selectable:U.selectable,locked:U.locked,grabbable:U.grabbable,classes:null};return G.classes=Object.keys(U.classes).filter(function(K){return U.classes[K]}).join(" "),G}},R.jsons=function(){var F=[];for(var $=0;$<this.length;$++){var M=this[$],U=M.json();F.push(U)}return F},R.clone=function(){var F=this.cy(),$=[];for(var M=0;M<this.length;M++){var U=this[M],Z=U.json(),G=new I(F,Z,!1);// NB no restore
$.push(G)}return new O(F,$)},R.copy=R.clone,R.restore=function(F){var $=this,M=$.cy(),U=M._private;F===void 0&&(F=!0);// create arrays of nodes and edges, since we need to
// restore the nodes first
var Z=[],G=[],K;for(var J=0,ee=$.length;J<ee;J++){var te=$[J];te.removed()&&(te.isNode()?Z.push(te):G.push(te));// keep nodes first in the array and edges after
}K=Z.concat(G);var J,ae=function(){K.splice(J,1),J--};// now, restore each element
for(J=0;J<K.length;J++){var te=K[J],ne=te._private,re=ne.data;// the traversal cache should start fresh when ele is added
// set id and validate
if(ne.traversalCache=null,void 0===re.id)re.id=L.generate(M,te);else if(T.number(re.id))re.id=""+re.id;else if(T.emptyString(re.id)||!T.string(re.id)){D.error("Can not create element with invalid string ID `"+re.id+"`"),ae();continue}else if(M.hasElementWithId(re.id)){D.error("Can not create second element with ID `"+re.id+"`"),ae();continue}var oe=re.id;// id is finalised, now let's keep a ref
if(te.isNode()){// extra checks for nodes
var se=te,le=ne.position;null==le.x&&(le.x=0),null==le.y&&(le.y=0)}if(te.isEdge()){// extra checks for edges
var pe=te,ue=["source","target"],ge=ue.length,ce=!1;for(var he=0;he<ge;he++){var ye=ue[he],me=re[ye];T.number(me)&&(me=re[ye]=""+re[ye]),null==me||""===me?(D.error("Can not create edge `"+oe+"` with unspecified "+ye),ce=!0):!M.hasElementWithId(me)&&(D.error("Can not create edge `"+oe+"` with nonexistant "+ye+" `"+me+"`"),ce=!0)}if(ce){ae();continue}// can't create this
var fe=M.getElementById(re.source),xe=M.getElementById(re.target);fe._private.edges.push(pe),xe._private.edges.push(pe),pe._private.source=fe,pe._private.target=xe}// if is edge
// create mock ids / indexes maps for element so it can be used like collections
ne.ids={},ne.ids[oe]=te,ne.indexes={},ne.indexes[oe]=te,ne.removed=!1,M.addToPool(te)}// for each element
// do compound node sanity checks
for(var J=0;J<Z.length;J++){// each node
var se=Z[J],re=se._private.data;T.number(re.parent)&&(re.parent=""+re.parent);var ve=re.parent;if(null!=ve){var be=M.getElementById(ve);if(be.empty())re.parent=void 0;else{for(var we=!1,Ee=be;!Ee.empty();){if(se.same(Ee)){we=!0,re.parent=void 0;// remove parent reference
// exit or we loop forever
break}Ee=Ee.parent()}we||(be[0]._private.children.push(se),se._private.parent=be[0],U.hasCompoundNodes=!0)}// else
}// if specified parent
}// for each node
if(0<K.length){var Se=new O(M,K);for(var J=0;J<Se.length;J++){var te=Se[J];if(!te.isNode()){// adding an edge invalidates the traversal caches for the parallel edges
var _e=te.parallelEdges();for(var he=0;he<_e.length;he++)_e[he]._private.traversalCache=null;// adding an edge invalidates the traversal cache for the connected nodes
te.source()[0]._private.traversalCache=null,te.target()[0]._private.traversalCache=null}}var Pe;Pe=U.hasCompoundNodes?Se.add(Se.connectedNodes()).add(Se.parent()):Se,Pe.updateStyle(F),F?Se.rtrigger("add"):Se.trigger("add")}return $;// chainability
},R.removed=function(){var F=this[0];return F&&F._private.removed},R.inside=function(){var F=this[0];return F&&!F._private.removed},R.remove=function(F){// add connected edges
function $(ye){var me=ye._private.edges;for(var fe=0;fe<me.length;fe++)U(me[fe])}// add descendant nodes
function M(ye){var me=ye._private.children;for(var fe=0;fe<me.length;fe++)U(me[fe])}function U(ye){var me=ae[ye.id()];me||(ae[ye.id()]=!0,ye.isNode()?(te.push(ye),$(ye),M(ye)):te.unshift(ye))}// make the list of elements to remove
// (may be removing more than specified due to connected edges etc)
function Z(ye,me){var fe=ye._private.edges;D.removeFromArray(fe,me),ye._private.traversalCache=null}function G(ye){// removing an edge invalidates the traversal caches for the parallel edges
var me=ye.parallelEdges();for(var fe=0;fe<me.length;fe++)me[fe]._private.traversalCache=null}function K(ye,me){me=me[0],ye=ye[0];var fe=ye._private.children,xe=ye.id();D.removeFromArray(fe,me),le.ids[xe]||(le.ids[xe]=!0,le.push(ye))}// remove from core pool
var J=this,ee=[],te=[],ae={},ne=J._private.cy;F===void 0&&(F=!0);for(var re=0,oe=J.length;re<oe;re++){var se=J[re];U(se)}var le=[];le.ids={},ne.removeFromPool(te);for(var re=0;re<te.length;re++){var se=te[re];// mark as removed
if(se._private.removed=!0,ee.push(se),se.isEdge()){// remove references to this edge in its connected nodes
var pe=se.source()[0],ue=se.target()[0];Z(pe,se),Z(ue,se),G(se)}else{// remove reference to parent
var ge=se.parent();0!==ge.length&&K(ge,se)}}// check to see if we have a compound graph or not
var ce=ne._private.elements;ne._private.hasCompoundNodes=!1;for(var re=0;re<ce.length;re++){var se=ce[re];if(se.isParent()){ne._private.hasCompoundNodes=!0;break}}var he=new O(this.cy(),ee);0<he.size()&&(F&&this.cy().notify({type:"remove",eles:he}),he.trigger("remove"));// the parents who were modified by the removal need their style updated
for(var re=0;re<le.length;re++){var se=le[re];se.removed()||se.updateStyle()}return new O(ne,ee)},R.move=function(F){var $=this._private.cy;if(F.source!==void 0||F.target!==void 0){var M=F.source,U=F.target,Z=$.hasElementWithId(M),G=$.hasElementWithId(U);if(Z||G){var K=this.jsons();this.remove();for(var J=0;J<K.length;J++){var ee=K[J],te=this[J];"edges"===ee.group&&(Z&&(ee.data.source=M),G&&(ee.data.target=U),ee.scratch=te._private.scratch)}return $.add(K)}}else if(F.parent!==void 0){// move node to new parent
var ae=F.parent,ne=null===ae||$.hasElementWithId(ae);if(ne){var K=this.jsons(),re=this.descendants(),oe=re.union(re.union(this).connectedEdges());this.remove();// NB: also removes descendants and their connected edges
for(var J=0;J<this.length;J++){var ee=K[J],te=this[J];"nodes"===ee.group&&(ee.data.parent=null===ae?void 0:ae,ee.scratch=te._private.scratch)}return $.add(K).union(oe.restore())}}return this;// if nothing done
},[E("./algorithms"),E("./animation"),E("./class"),E("./comparators"),E("./compounds"),E("./data"),E("./degree"),E("./dimensions"),E("./events"),E("./filter"),E("./group"),E("./index"),E("./iteration"),E("./layout"),E("./style"),E("./switch-functions"),E("./traversing")].forEach(function(F){D.extend(R,F)}),_.exports=O},{"../is":83,"../util":99,"./algorithms":11,"./animation":15,"./class":16,"./comparators":17,"./compounds":18,"./data":19,"./degree":20,"./dimensions":21,"./element":22,"./events":23,"./filter":24,"./group":25,"./index":26,"./iteration":27,"./layout":28,"./style":29,"./switch-functions":30,"./traversing":31}],27:[function(E,_){"use strict";var D=E("../is"),T=E("./zsort"),I={forEach:function(L,O){if(D.fn(L))for(var R=0;R<this.length;R++){var F=this[R],$=O?L.apply(O,[F,R,this]):L(F,R,this);if(!1===$)break;// exit each early on return false
}return this},toArray:function(){var L=[];for(var O=0;O<this.length;O++)L.push(this[O]);return L},slice:function(L,O){var R=[],F=this.length;null==O&&(O=F),null==L&&(L=0),0>L&&(L=F+L),0>O&&(O=F+O);for(var $=L;0<=$&&$<O&&$<F;$++)R.push(this[$]);return this.spawn(R)},size:function(){return this.length},eq:function(L){return this[L]||this.spawn()},first:function(){return this[0]||this.spawn()},last:function(){return this[this.length-1]||this.spawn()},empty:function(){return 0===this.length},nonempty:function(){return!this.empty()},sort:function(L){if(!D.fn(L))return this;var O=this.toArray().sort(L);return this.spawn(O)},sortByZIndex:function(){return this.sort(T)},zDepth:function(){var L=this[0];if(!L)return void 0;// var cy = ele.cy();
var O=L._private,R=O.group;if("nodes"===R){var F=O.data.parent?L.parents().size():0;return L.isParent()?F:Number.MAX_VALUE}var $=O.source,M=O.target,U=$.zDepth(),Z=M.zDepth();return Math.max(U,Z,0);// depth of deepest parent
}};I.each=I.forEach,_.exports=I},{"../is":83,"./zsort":32}],28:[function(E,_){"use strict";var D=E("../is"),T=E("../util"),I=E("../promise"),L={// using standard layout options, apply position function (w/ or w/o animation)
layoutPositions:function(O,R,F){var $=this.nodes(),M=this.cy();if(O.trigger({type:"layoutstart",layout:O}),O.animations=[],R.animate){for(var U=0;U<$.length;U++){var Z=$[U],G=F(Z,U),K=Z.position();D.number(K.x)&&D.number(K.y)||Z.silentPosition({x:0,y:0});var J=Z.animation({position:G,duration:R.animationDuration,easing:R.animationEasing});O.animations.push(J),J.play()}var ee;M.on("step.*",ee=function(){R.fit&&M.fit(R.eles,R.padding)}),O.one("layoutstop",function(){M.off("step.*",ee)}),O.one("layoutready",R.ready),O.trigger({type:"layoutready",layout:O}),I.all(O.animations.map(function(te){return te.promise()})).then(function(){M.off("step.*",ee),null!=R.zoom&&M.zoom(R.zoom),R.pan&&M.pan(R.pan),R.fit&&M.fit(R.eles,R.padding),O.one("layoutstop",R.stop),O.trigger({type:"layoutstop",layout:O})})}else $.positions(F),R.fit&&M.fit(R.eles,R.padding),null!=R.zoom&&M.zoom(R.zoom),R.pan&&M.pan(R.pan),O.one("layoutready",R.ready),O.trigger({type:"layoutready",layout:O}),O.one("layoutstop",R.stop),O.trigger({type:"layoutstop",layout:O});return this;// chaining
},layout:function(O){var R=this.cy();return R.makeLayout(T.extend({},O,{eles:this}))}};// aliases:
L.createLayout=L.makeLayout=L.layout,_.exports=L},{"../is":83,"../promise":85,"../util":99}],29:[function(E,_){"use strict";function D(O){var R=O.ok,F=O.edgeOkViaNode||O.ok,$=O.parentOk||O.ok;return function(){var M=this.cy();if(!M.styleEnabled())return!0;var U=this[0],Z=M.hasCompoundNodes();if(U){var G=U._private;if(!R(U))return!1;if(U.isNode()){if(Z){var K=G.data.parent?U.parents():null;if(K)for(var J=0;J<K.length;J++){var ee=K[J];if(!$(ee))return!1}}return!0}return F(G.source)&&F(G.target)}}}var T=E("../is"),I={// fully updates (recalculates) the style for the elements
updateStyle:function(O){var R=this._private.cy;if(!R.styleEnabled())return this;if(R._private.batchingStyle){var F=R._private.batchStyleEles;return F.merge(this),this;// chaining and exit early when batching
}O=O||void 0===O;const $=R.style();$.apply(this);var M=this.updateCompoundBounds(),U=0<M.length?this.add(M):this;return O?U.rtrigger("style"):U.trigger("style"),this;// chaining
},// just update the mappers in the elements' styles; cheaper than eles.updateStyle()
updateMappers:function(O){var R=this._private.cy,F=R.style();if(O=O||void 0===O,!R.styleEnabled())return this;F.updateMappers(this);var $=this.updateCompoundBounds(),M=0<$.length?this.add($):this;return O?M.rtrigger("style"):M.trigger("style"),this;// chaining
},// get the internal parsed style object for the specified property
parsedStyle:function(O){var R=this[0];return R.cy().styleEnabled()?R?R._private.style[O]||R.cy().style().getDefaultProperty(O):void 0:void 0},// get the specified css property as a rendered value (i.e. on-screen value)
// or get the whole rendered style if no property specified (NB doesn't allow setting)
renderedStyle:function(O){var R=this.cy();if(!R.styleEnabled())return this;var F=this[0];if(F){var $=F.cy().style().getRenderedStyle(F);if(O===void 0)return $;return $[O]}},// read the calculated css style of the element or override the style (via a bypass)
style:function(O,R){var F=this.cy();if(!F.styleEnabled())return this;var $=!1,M=F.style();if(T.plainObject(O)){M.applyBypass(this,O,$);var U=this.updateCompoundBounds(),Z=0<U.length?this.add(U):this;Z.rtrigger("style")}else if(T.string(O)){if(R===void 0){// then get the property from the style
var G=this[0];if(G)return M.getStylePropertyValue(G,O);// empty collection => can't get any value
return}M.applyBypass(this,O,R,$);var U=this.updateCompoundBounds(),Z=0<U.length?this.add(U):this;Z.rtrigger("style")}else if(O===void 0){var G=this[0];if(G)return M.getRawStyle(G);// empty collection => can't get any value
return}return this;// chaining
},removeStyle:function(O){var R=this.cy();if(!R.styleEnabled())return this;var F=!1,$=R.style(),M=this;if(void 0===O)for(var U=0;U<M.length;U++){var Z=M[U];$.removeAllBypasses(Z,F)}else{O=O.split(/\s+/);for(var U=0;U<M.length;U++){var Z=M[U];$.removeBypasses(Z,O,F)}}var G=this.updateCompoundBounds(),K=0<G.length?this.add(G):this;// let the renderer know we've updated style
return K.rtrigger("style"),this;// chaining
},show:function(){return this.css("display","element"),this;// chaining
},hide:function(){return this.css("display","none"),this;// chaining
},effectiveOpacity:function(){var O=this.cy();if(!O.styleEnabled())return 1;var R=O.hasCompoundNodes(),F=this[0];if(F){var $=F._private,M=F.pstyle("opacity").value;if(!R)return M;var U=$.data.parent?F.parents():null;if(U)for(var Z=0;Z<U.length;Z++){var G=U[Z],K=G.pstyle("opacity").value;M=K*M}return M}},transparent:function(){var O=this.cy();if(!O.styleEnabled())return!1;var R=this[0],F=R.cy().hasCompoundNodes();if(R){if(!F)return 0===R.pstyle("opacity").value;return 0===R.effectiveOpacity()}},backgrounding:function(){var O=this.cy();if(!O.styleEnabled())return!1;var R=this[0];return!!R._private.backgrounding}},L=function(O){return"element"===O.pstyle("display").value&&0!==O.width()&&(!O.isNode()||0!==O.height())};I.takesUpSpace=D({ok:L}),I.interactive=D({ok:function(O){return"yes"===O.pstyle("events").value&&"visible"===O.pstyle("visibility").value&&L(O)},parentOk:function(O){return"visible"===O.pstyle("visibility").value&&L(O)},edgeOkViaNode:L}),I.noninteractive=function(){var O=this[0];if(O)return!O.interactive()},I.visible=D({ok:function(O){return"visible"===O.pstyle("visibility").value&&0!==O.pstyle("opacity").pfValue&&L(O)},edgeOkViaNode:L}),I.hidden=function(){var O=this[0];if(O)return!O.visible()},I.bypass=I.css=I.style,I.renderedCss=I.renderedStyle,I.removeBypass=I.removeCss=I.removeStyle,I.pstyle=I.parsedStyle,_.exports=I},{"../is":83}],30:[function(E,_){"use strict";function D(L){return function(){var O=arguments,R=[];// e.g. cy.nodes().select( data, handler )
if(2===O.length){var F=O[0],$=O[1];this.on(L.event,F,$)}// e.g. cy.nodes().select( handler )
else if(1===O.length){var $=O[0];this.on(L.event,$)}// e.g. cy.nodes().select()
else if(0===O.length){for(var M=0;M<this.length;M++){var U=this[M],Z=!L.ableField||U._private[L.ableField],G=U._private[L.field]!=L.value;if(L.overrideAble){var K=L.overrideAble(U);if(void 0!==K&&(Z=K,!K))return this}Z&&(U._private[L.field]=L.value,G&&R.push(U))}var J=this.spawn(R);J.updateStyle(),J.trigger(L.event)}return this}}function T(L){I[L.field]=function(){var O=this[0];if(O){if(L.overrideField){var R=L.overrideField(O);if(R!==void 0)return R}return O._private[L.field]}},I[L.on]=D({event:L.on,field:L.field,ableField:L.ableField,overrideAble:L.overrideAble,value:!0}),I[L.off]=D({event:L.off,field:L.field,ableField:L.ableField,overrideAble:L.overrideAble,value:!1})}var I={};T({field:"locked",overrideField:function(L){return!!L.cy().autolock()||void 0},on:"lock",off:"unlock"}),T({field:"grabbable",overrideField:function(L){return!L.cy().autoungrabify()&&void 0},on:"grabify",off:"ungrabify"}),T({field:"selected",ableField:"selectable",overrideAble:function(L){return!L.cy().autounselectify()&&void 0},on:"select",off:"unselect"}),T({field:"selectable",overrideField:function(L){return!L.cy().autounselectify()&&void 0},on:"selectify",off:"unselectify"}),I.deselect=I.unselect,I.grabbed=function(){var L=this[0];if(L)return L._private.grabbed},T({field:"active",on:"activate",off:"unactivate"}),I.inactive=function(){var L=this[0];if(L)return!L._private.active},_.exports=I},{}],31:[function(E,_){"use strict";function D(Z){return function(K){var J=[];for(var ee=0;ee<this.length;ee++){var te=this[ee],ae=te._private[Z.attr];ae&&J.push(ae)}return this.spawn(J,{unique:!0}).filter(K)}}function T(Z){return function(K){var J=[],ee=this._private.cy,te=Z||{};// get elements if a selector is specified
O.string(K)&&(K=ee.$(K));var ae=this._private.ids,ne=K._private.ids;for(var re=0;re<K.length;re++){var oe=K[re]._private.edges;for(var se=0;se<oe.length;se++){var le=oe[se],pe=le._private.data,ue=ae[pe.source]&&ne[pe.target],ge=ne[pe.source]&&ae[pe.target];if(ue||ge){if(te.thisIsSrc||te.thisIsTgt){if(te.thisIsSrc&&!ue)continue;if(te.thisIsTgt&&!ge)continue}J.push(le)}}}return this.spawn(J,{unique:!0})}}function I(Z){return Z=L.extend({},{codirected:!1},Z),function(K){// micro-optimised for renderer
var J=[],ee=this.edges(),te=Z;// look at all the edges in the collection
for(var ae=0;ae<ee.length;ae++){var ne=ee[ae],re=ne._private,oe=re.source,se=oe._private.data.id,le=re.data.target,pe=oe._private.edges;// look at edges connected to the src node of this edge
for(var ue=0;ue<pe.length;ue++){var ge=pe[ue],ce=ge._private.data,he=ce.target,ye=ce.source,me=he===le&&ye===se;(te.codirected&&me||!te.codirected&&(me||se===he&&le===ye))&&J.push(ge)}}return this.spawn(J,{unique:!0}).filter(K)}}// Misc functions
/////////////////
var L=E("../util"),O=E("../is"),R={},F=function(Z,G){return function(J,ee,te,ae){var ne=J,re=this,oe;if(null==ne?oe="null":O.elementOrCollection(ne)&&1===ne.length&&(oe="#"+ne.id()),1===re.length&&oe){var se=re[0]._private,le=se.traversalCache=se.traversalCache||{},pe=le[G]=le[G]||{},ue=pe[oe];return ue?ue:pe[oe]=Z.call(re,J,ee,te,ae)}return Z.call(re,J,ee,te,ae)}},$=function(Z){return function(K){var J=this,ee=[];for(var te=0;te<J.length;te++){var ae=J[te];if(ae.isNode()){var ne=!1,re=ae.connectedEdges();for(var oe=0;oe<re.length;oe++){var se=re[oe],le=se.source(),pe=se.target();if(Z.noIncomingEdges&&pe===ae&&le!==ae||Z.noOutgoingEdges&&le===ae&&pe!==ae){ne=!0;break}}ne||ee.push(ae)}}return this.spawn(ee,{unique:!0}).filter(K)}},M=function(Z){return function(G){var K=this,J=[];for(var ee=0;ee<K.length;ee++){var te=K[ee];if(te.isNode()){var ae=te.connectedEdges();for(var ne=0;ne<ae.length;ne++){var re=ae[ne],oe=re.source(),se=re.target();Z.outgoing&&oe===te?(J.push(re),J.push(se)):Z.incoming&&se===te&&(J.push(re),J.push(oe))}}}return this.spawn(J,{unique:!0}).filter(G)}},U=function(Z){return function(G){for(var K=this,J=[],ee={};;){var te=Z.outgoing?K.outgoers():K.incomers();if(0===te.length)break;// done if none left
var ae=!1;for(var ne=0;ne<te.length;ne++){var re=te[ne],oe=re.id();ee[oe]||(ee[oe]=!0,J.push(re),ae=!0)}if(!ae)break;// done if touched all outgoers already
K=te}return this.spawn(J,{unique:!0}).filter(G)}};// DAG functions
////////////////
L.extend(R,{// get the root nodes in the DAG
roots:$({noIncomingEdges:!0}),// get the leaf nodes in the DAG
leaves:$({noOutgoingEdges:!0}),// normally called children in graph theory
// these nodes =edges=> outgoing nodes
outgoers:F(M({outgoing:!0}),"outgoers"),// aka DAG descendants
successors:U({outgoing:!0}),// normally called parents in graph theory
// these nodes <=edges= incoming nodes
incomers:F(M({incoming:!0}),"incomers"),// aka DAG ancestors
predecessors:U({incoming:!0})}),L.extend(R,{neighborhood:F(function(Z){var G=[],K=this.nodes();for(var J=0;J<K.length;J++){// for all nodes
var ee=K[J],te=ee.connectedEdges();// for each connected edge, add the edge and the other node
for(var ae=0;ae<te.length;ae++){var ne=te[ae],re=ne.source(),oe=ne.target(),se=ee===re?oe:re;// need check in case of loop
0<se.length&&G.push(se[0]),G.push(ne[0])}}return this.spawn(G,{unique:!0}).filter(Z)},"neighborhood"),closedNeighborhood:function(Z){return this.neighborhood().add(this).filter(Z)},openNeighborhood:function(Z){return this.neighborhood(Z)}}),R.neighbourhood=R.neighborhood,R.closedNeighbourhood=R.closedNeighborhood,R.openNeighbourhood=R.openNeighborhood,L.extend(R,{source:F(function(G){var K=this[0],J;return K&&(J=K._private.source||K.cy().collection()),J&&G?J.filter(G):J},"source"),target:F(function(G){var K=this[0],J;return K&&(J=K._private.target||K.cy().collection()),J&&G?J.filter(G):J},"target"),sources:D({attr:"source"}),targets:D({attr:"target"})}),L.extend(R,{edgesWith:F(T(),"edgesWith",!0),edgesTo:F(T({thisIsSrc:!0}),"edgesTo",!0)}),L.extend(R,{connectedEdges:F(function(Z){var G=[],K=this;for(var J=0;J<K.length;J++){var ee=K[J];if(ee.isNode()){var te=ee._private.edges;for(var ae=0;ae<te.length;ae++){var ne=te[ae];G.push(ne)}}}return this.spawn(G,{unique:!0}).filter(Z)},"connectedEdges"),connectedNodes:F(function(Z){var G=[],K=this;for(var J=0;J<K.length;J++){var ee=K[J];ee.isEdge()&&(G.push(ee.source()[0]),G.push(ee.target()[0]))}return this.spawn(G,{unique:!0}).filter(Z)},"connectedNodes"),parallelEdges:F(I(),"parallelEdges"),codirectedEdges:F(I({codirected:!0}),"codirectedEdges")}),L.extend(R,{components:function(){var Z=this,G=Z.cy(),K=Z.spawn(),J=Z.nodes().spawnSelf(),ee=[],te=function(re,oe){K.merge(re),J.unmerge(re),oe.merge(re)};if(J.empty())return Z.spawn();do{var ae=G.collection();ee.push(ae);var ne=J[0];te(ne,ae),Z.bfs({directed:!1,roots:ne,visit:function(re){te(re,ae)}})}while(0<J.length);return ee.map(function(re){var oe=re.connectedEdges().stdFilter(function(se){return re.anySame(se.source())&&re.anySame(se.target())});return re.union(oe)})}}),_.exports=R},{"../is":83,"../util":99}],32:[function(E,_){"use strict";_.exports=function(D,T){var I=D.cy(),L=D.pstyle("z-index").value-T.pstyle("z-index").value,O=0,R=0,F=I.hasCompoundNodes(),$=D.isNode(),M=T.isNode();F&&(O=D.zDepth(),R=T.zDepth());var U=O-R;if(0==U){if($&&!M)return 1;// 'a' is a node, it should be drawn later
// elements on different level
return!$&&M?-1:0==L?D.poolIndex()-T.poolIndex():L;// both nodes or both edges
}return U;// deeper element should be drawn later
}},{}],33:[function(E,_){"use strict";var D=E("../is"),T=E("../util"),I=E("../collection"),L=E("../collection/element");_.exports={add:function(O){var R,F=this;// add the elements
if(D.elementOrCollection(O)){var $=O;if($._private.cy===F)R=$.restore();else{// otherwise, copy from json
var M=[];for(var U=0;U<$.length;U++){var Z=$[U];M.push(Z.json())}R=new I(F,M)}}// specify an array of options
else if(D.array(O)){var M=O;R=new I(F,M)}// specify via opts.nodes and opts.edges
else if(D.plainObject(O)&&(D.array(O.nodes)||D.array(O.edges))){var M=[],G=["nodes","edges"];for(var U=0,K=G.length;U<K;U++){var J=G[U],ee=O[J];if(D.array(ee))for(var te=0,ae=ee.length;te<ae;te++){var ne=T.extend({group:J},ee[te]);M.push(ne)}}R=new I(F,M)}// specify options for one element
else{var ne=O;R=new L(F,ne).collection()}return R},remove:function(O){if(D.elementOrCollection(O));else if(D.string(O)){var R=O;O=this.$(R)}return O.remove()}}},{"../collection":26,"../collection/element":22,"../is":83,"../util":99}],34:[function(E,_){"use strict";var D=E("../define"),T=E("../util"),I=E("../is"),L={// pull in animation functions
animate:D.animate(),animation:D.animation(),animated:D.animated(),clearQueue:D.clearQueue(),delay:D.delay(),delayAnimation:D.delayAnimation(),stop:D.stop(),addToAnimationPool:function(O){var R=this;R.styleEnabled()&&R._private.aniEles.merge(O);// save cycles when no style used
},stopAnimationLoop:function(){this._private.animationsRunning=!1},startAnimationLoop:function(){// save cycles when no style used
// NB the animation loop will exec in headless environments if style enabled
// and explicit cy.destroy() is necessary to stop the loop
function O(){K._private.animationsRunning&&T.requestAnimationFrame(function(ne){R(ne),O()})}function R(ae){function ne(he,ye){var me=he._private,fe=me.animation.current,xe=me.animation.queue,ve=!1;// if nothing currently animating, get something from the queue
if(0===fe.length){var be=xe.shift();be&&fe.push(be)}var we=function(Pe){for(var Ce=Pe.length-1;0<=Ce;Ce--){var De=Pe[Ce];De()}Pe.splice(0,Pe.length)};// step and remove if done
for(var Ee=fe.length-1;0<=Ee;Ee--){var Se=fe[Ee],_e=Se._private;if(_e.stopped){fe.splice(Ee,1),_e.hooked=!1,_e.playing=!1,_e.started=!1,we(_e.frames);continue}(_e.playing||_e.applying)&&(_e.playing&&_e.applying&&(_e.applying=!1),_e.started||F(he,Se,ae),$(he,Se,ae,ye),_e.applying&&(_e.applying=!1),we(_e.frames),Se.completed()&&(fe.splice(Ee,1),_e.hooked=!1,_e.playing=!1,_e.started=!1,we(_e.completes)),ve=!0)}return ye||0!==fe.length||0!==xe.length||oe.push(he),ve}// handleElement
// handle all eles
var re=K._private.aniEles,oe=[],se=!1;for(var le=0;le<re.length;le++){var pe=re[le],ue=ne(pe);se=se||ue}// each element
var ge=ne(K,!0);// notify renderer
if(se||ge)if(0<re.length){var ce=re.updateCompoundBounds().spawnSelf().merge(re);K.notify({type:"draw",eles:ce})}else K.notify({type:"draw"});// remove elements from list of currently animating if its queues are empty
re.unmerge(oe),K.trigger("step")}// handleElements
function F(ae,ne,re){var oe=I.core(ae),se=ae,le=K._private.style,pe=ne._private;if(!oe){var ue=se._private.position;pe.startPosition=pe.startPosition||{x:ue.x,y:ue.y},pe.startStyle=pe.startStyle||le.getAnimationStartStyle(se,pe.style)}if(oe){var ge=K._private.pan;pe.startPan=pe.startPan||{x:ge.x,y:ge.y},pe.startZoom=null==pe.startZoom?K._private.zoom:pe.startZoom}pe.started=!0,pe.startTime=re-pe.progress*pe.duration}function $(ae,ne,re,oe){var se=K._private.style,le=!oe,pe=ae._private,ue=ne._private,ge=ue.easing,ce=ue.startTime;if(!ue.easingImpl)if(null==ge)ue.easingImpl=te.linear;else{// then define w/ name
var he;if(I.string(ge)){var ye=se.parse("transition-timing-function",ge);he=ye.value}else he=ge;var me,fe;I.string(he)?(me=he,fe=[]):(me=he[1],fe=he.slice(2).map(function(Oe){return+Oe})),0<fe.length?("spring"===me&&fe.push(ue.duration),ue.easingImpl=te[me].apply(null,fe)):ue.easingImpl=te[me]}var xe=ue.easingImpl,ve;if(ve=0===ue.duration?1:(re-ce)/ue.duration,ue.applying&&(ve=ue.progress),0>ve?ve=0:1<ve&&(ve=1),null==ue.delay){// then update
var be=ue.startPosition,we=ue.position,Ee=pe.position;we&&le&&(M(be.x,we.x)&&(Ee.x=G(be.x,we.x,ve,xe)),M(be.y,we.y)&&(Ee.y=G(be.y,we.y,ve,xe)),ae.trigger("position"));var Se=ue.startPan,_e=ue.pan,Pe=pe.pan,Ce=null!=_e&&oe;Ce&&(M(Se.x,_e.x)&&(Pe.x=G(Se.x,_e.x,ve,xe)),M(Se.y,_e.y)&&(Pe.y=G(Se.y,_e.y,ve,xe)),ae.trigger("pan"));var De=ue.startZoom,Te=ue.zoom,ke=null!=Te&&oe;ke&&(M(De,Te)&&(pe.zoom=G(De,Te,ve,xe)),ae.trigger("zoom")),(Ce||ke)&&ae.trigger("viewport");var Ie=ue.style;if(Ie&&0<Ie.length&&le){for(var Ne=0;Ne<Ie.length;Ne++){var ze=Ie[Ne],me=ze.name,Be=ue.startStyle[me],Le=G(Be,ze,ve,xe);se.overrideBypass(ae,me,Le)}// for props
ae.trigger("style")}// if
}return ue.progress=ve,ve}function M(ae,ne){return null==ae||null==ne?!1:I.number(ae)&&I.number(ne)||ae&&ne}// assumes p0 = 0, p3 = 1
function U(ae,ne,re){var oe=1-re,se=re*re;return 3*oe*oe*re*ae+3*oe*se*ne+se*re}function Z(ae,ne){return function(re,oe,se){return re+(oe-re)*U(ae,ne,se)}}/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License *//* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
       then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */function G(ae,ne,re,oe){0>re?re=0:1<re&&(re=1);var se,le;if(se=null!=ae.pfValue||null!=ae.value?null==ae.pfValue?ae.value:ae.pfValue:ae,le=null!=ne.pfValue||null!=ne.value?null==ne.pfValue?ne.value:ne.pfValue:ne,I.number(se)&&I.number(le))return oe(se,le,re);if(I.array(se)&&I.array(le)){var pe=[];for(var ue=0;ue<le.length;ue++){var ge=se[ue],ce=le[ue];if(null!=ge&&null!=ce){var he=oe(ge,ce,re);ae.roundValue&&(he=Math.round(he)),pe.push(he)}else pe.push(ce)}return pe}0}var K=this;if(K._private.animationsRunning=!0,!!K.styleEnabled()){var J=K.renderer();J&&J.beforeRender?J.beforeRender(function(ne,re){R(re)},J.beforeRenderPriorities.animations):O();var ee=function(){function ae(oe){return-oe.tension*oe.x-oe.friction*oe.v}function ne(oe,se,le){var pe={x:oe.x+le.dx*se,v:oe.v+le.dv*se,tension:oe.tension,friction:oe.friction};return{dx:pe.v,dv:ae(pe)}}function re(oe,se){var le={dx:oe.v,dv:ae(oe)},pe=ne(oe,0.5*se,le),ue=ne(oe,0.5*se,pe),ge=ne(oe,se,ue),ce=1/6*(le.dx+2*(pe.dx+ue.dx)+ge.dx),he=1/6*(le.dv+2*(pe.dv+ue.dv)+ge.dv);return oe.x=oe.x+ce*se,oe.v=oe.v+he*se,oe}return function oe(se,le,pe){var ue={x:-1,v:0,tension:null,friction:null},ge=[0],ce=0,he=1/10000,ye=16/1000,me,fe,xe;for(se=parseFloat(se)||500,le=parseFloat(le)||20,pe=pe||null,ue.tension=se,ue.friction=le,me=null!==pe,me?(ce=oe(se,le),fe=ce/pe*ye):fe=ye;xe=re(xe||ue,fe),ge.push(1+xe.x),ce+=16,!!(Math.abs(xe.x)>he&&Math.abs(xe.v)>he););/* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
           computed path and returns a snapshot of the position according to a given percentComplete. */return me?function(ve){return ge[0|ve*(ge.length-1)]}:ce}}(),te={linear:function(ae,ne,re){return ae+(ne-ae)*re},// default easings
ease:Z(0.25,0.1,0.25,1),"ease-in":Z(0.42,0,1,1),"ease-out":Z(0,0,0.58,1),"ease-in-out":Z(0.42,0,0.58,1),// sine
"ease-in-sine":Z(0.47,0,0.745,0.715),"ease-out-sine":Z(0.39,0.575,0.565,1),"ease-in-out-sine":Z(0.445,0.05,0.55,0.95),// quad
"ease-in-quad":Z(0.55,0.085,0.68,0.53),"ease-out-quad":Z(0.25,0.46,0.45,0.94),"ease-in-out-quad":Z(0.455,0.03,0.515,0.955),// cubic
"ease-in-cubic":Z(0.55,0.055,0.675,0.19),"ease-out-cubic":Z(0.215,0.61,0.355,1),"ease-in-out-cubic":Z(0.645,0.045,0.355,1),// quart
"ease-in-quart":Z(0.895,0.03,0.685,0.22),"ease-out-quart":Z(0.165,0.84,0.44,1),"ease-in-out-quart":Z(0.77,0,0.175,1),// quint
"ease-in-quint":Z(0.755,0.05,0.855,0.06),"ease-out-quint":Z(0.23,1,0.32,1),"ease-in-out-quint":Z(0.86,0,0.07,1),// expo
"ease-in-expo":Z(0.95,0.05,0.795,0.035),"ease-out-expo":Z(0.19,1,0.22,1),"ease-in-out-expo":Z(1,0,0,1),// circ
"ease-in-circ":Z(0.6,0.04,0.98,0.335),"ease-out-circ":Z(0.075,0.82,0.165,1),"ease-in-out-circ":Z(0.785,0.135,0.15,0.86),// user param easings...
spring:function(ae,ne,re){if(0===re)// can't get a spring w/ duration 0
return te.linear;// duration 0 => jump to end so impl doesn't matter
var oe=ee(ae,ne,re);return function(se,le,pe){return se+(le-se)*oe(pe)}},"cubic-bezier":function(ae,ne,re,oe){return Z(ae,ne,re,oe)}}}}};_.exports=L},{"../define":44,"../is":83,"../util":99}],35:[function(E,_){"use strict";var D=E("../define"),T={on:D.on(),// .on( events [, selector] [, data], handler)
one:D.on({unbindSelfOnTrigger:!0}),once:D.on({unbindAllBindersOnTrigger:!0}),off:D.off(),// .off( events [, selector] [, handler] )
trigger:D.trigger()// .trigger( events [, extraParams] )
};D.eventAliasesOn(T),_.exports=T},{"../define":44}],36:[function(E,_){"use strict";var D={png:function(T){var I=this._private.renderer;return T=T||{},I.png(T)},jpg:function(T){var I=this._private.renderer;return T=T||{},T.bg=T.bg||"#fff",I.jpg(T)}};D.jpeg=D.jpg,_.exports=D},{}],37:[function(E,_){"use strict";var D=E("../window"),T=E("../util"),I=E("../collection"),L=E("../is"),O=E("../promise"),R=E("../define"),F=function(M){var U=this;M=T.extend({},M);var Z=M.container;// allow for passing a wrapped jquery object
// e.g. cytoscape({ container: $('#cy') })
Z&&!L.htmlElement(Z)&&L.htmlElement(Z[0])&&(Z=Z[0]);var G=Z?Z._cyreg:null;// e.g. already registered some info (e.g. readies) via jquery
G=G||{},G&&G.cy&&(G.cy.destroy(),G={});var K=G.readies=G.readies||[];Z&&(Z._cyreg=G),G.cy=U;var J=D!==void 0&&Z!==void 0&&!M.headless,ee=M;ee.layout=T.extend({name:J?"grid":"null"},ee.layout),ee.renderer=T.extend({name:J?"canvas":"null"},ee.renderer);var te=function(oe,se,le){if(se!==void 0)return se;return void 0===le?oe:le},ae=this._private={container:Z,// html dom ele container
ready:!1,// whether ready has been triggered
options:ee,// cached options
elements:new I(this),// elements in the graph
listeners:[],// list of listeners
aniEles:new I(this),// elements being animated
scratch:{},// scratch object for core
layout:null,renderer:null,notificationsEnabled:!0,// whether notifications are sent to the renderer
minZoom:1e-50,maxZoom:1e+50,zoomingEnabled:te(!0,ee.zoomingEnabled),userZoomingEnabled:te(!0,ee.userZoomingEnabled),panningEnabled:te(!0,ee.panningEnabled),userPanningEnabled:te(!0,ee.userPanningEnabled),boxSelectionEnabled:te(!0,ee.boxSelectionEnabled),autolock:te(!1,ee.autolock,ee.autolockNodes),autoungrabify:te(!1,ee.autoungrabify,ee.autoungrabifyNodes),autounselectify:te(!1,ee.autounselectify),styleEnabled:ee.styleEnabled===void 0?J:ee.styleEnabled,zoom:L.number(ee.zoom)?ee.zoom:1,pan:{x:L.plainObject(ee.pan)&&L.number(ee.pan.x)?ee.pan.x:0,y:L.plainObject(ee.pan)&&L.number(ee.pan.y)?ee.pan.y:0},animation:{// object for currently-running animations
current:[],queue:[]},hasCompoundNodes:!1},ne=ee.selectionType;// set selection type
ae.selectionType=void 0===ne||"additive"!==ne&&"single"!==ne?"single":ne,L.number(ee.minZoom)&&L.number(ee.maxZoom)&&ee.minZoom<ee.maxZoom?(ae.minZoom=ee.minZoom,ae.maxZoom=ee.maxZoom):L.number(ee.minZoom)&&ee.maxZoom===void 0?ae.minZoom=ee.minZoom:L.number(ee.maxZoom)&&ee.minZoom===void 0&&(ae.maxZoom=ee.maxZoom),U.initRenderer(T.extend({hideEdgesOnViewport:ee.hideEdgesOnViewport,textureOnViewport:ee.textureOnViewport,wheelSensitivity:L.number(ee.wheelSensitivity)&&0<ee.wheelSensitivity?ee.wheelSensitivity:1,motionBlur:ee.motionBlur!==void 0&&ee.motionBlur,// off by default
motionBlurOpacity:ee.motionBlurOpacity===void 0?0.05:ee.motionBlurOpacity,pixelRatio:L.number(ee.pixelRatio)&&0<ee.pixelRatio?ee.pixelRatio:void 0,desktopTapThreshold:ee.desktopTapThreshold===void 0?4:ee.desktopTapThreshold,touchTapThreshold:ee.touchTapThreshold===void 0?8:ee.touchTapThreshold},ee.renderer));var re=function(oe,se,le){U.notifications(!1);// remove old elements
var pe=U.mutableElements();0<pe.length&&pe.remove(),null!=oe&&(L.plainObject(oe)||L.array(oe))&&U.add(oe),U.one("layoutready",function(ge){U.notifications(!0),U.trigger(ge),U.notify({type:"load",eles:U.mutableElements()}),U.one("load",se),U.trigger("load")}).one("layoutstop",function(){U.one("done",le),U.trigger("done")});var ue=T.extend({},U._private.options.layout);ue.eles=U.elements(),U.layout(ue).run()};(function(oe,se){var le=oe.some(L.promise);return le?O.all(oe).then(se):void se(oe)})([ee.style,ee.elements],function(oe){var se=oe[0],le=oe[1];// init style
ae.styleEnabled&&U.setStyle(se),re(le,function(){U.startAnimationLoop(),ae.ready=!0,L.fn(ee.ready)&&U.on("ready",ee.ready);// bind all the ready handlers registered before creating this instance
for(var pe=0;pe<K.length;pe++){var ue=K[pe];U.on("ready",ue)}G&&(G.readies=[]),U.trigger("ready")},ee.done)})},$=F.prototype;// short alias
T.extend($,{instanceString:function(){return"core"},isReady:function(){return this._private.ready},ready:function(M){return this.isReady()?this.trigger("ready",[],M):this.on("ready",M),this},destroy:function(){var M=this;return M.stopAnimationLoop(),M.destroyRenderer(),M},hasElementWithId:function(M){return this._private.elements.hasElementWithId(M)},getElementById:function(M){return this._private.elements.getElementById(M)},selectionType:function(){return this._private.selectionType},hasCompoundNodes:function(){return this._private.hasCompoundNodes},headless:function(){return"null"===this._private.options.renderer.name},styleEnabled:function(){return this._private.styleEnabled},addToPool:function(M){return this._private.elements.merge(M),this;// chaining
},removeFromPool:function(M){return this._private.elements.unmerge(M),this},container:function(){return this._private.container},options:function(){return T.copy(this._private.options)},json:function(M){var U=this,Z=U._private,G=U.mutableElements();if(L.plainObject(M)){if(U.startBatch(),M.elements){var K={},J=function(le,pe){for(var ue=0;ue<le.length;ue++){var ge=le[ue],ce=ge.data.id,he=U.getElementById(ce);K[ce]=!0,0===he.length?pe?U.add(T.extend({group:pe},ge)):U.add(ge):he.json(ge)}};if(L.array(M.elements))J(M.elements);else{// elements: { nodes: [], edges: [] }
var ee=["nodes","edges"];for(var te=0;te<ee.length;te++){var ae=ee[te],ne=M.elements[ae];L.array(ne)&&J(ne,ae)}}// elements not specified in json should be removed
G.stdFilter(function(le){return!K[le.id()]}).remove()}M.style&&U.style(M.style),null!=M.zoom&&M.zoom!==Z.zoom&&U.zoom(M.zoom),M.pan&&(M.pan.x!==Z.pan.x||M.pan.y!==Z.pan.y)&&U.pan(M.pan);var re=["minZoom","maxZoom","zoomingEnabled","userZoomingEnabled","panningEnabled","userPanningEnabled","boxSelectionEnabled","autolock","autoungrabify","autounselectify"];for(var te=0;te<re.length;te++){var oe=re[te];null!=M[oe]&&U[oe](M[oe])}return U.endBatch(),this;// chaining
}if(void 0===M){// get
var se={};return se.elements={},G.forEach(function(le){var pe=le.group();se.elements[pe]||(se.elements[pe]=[]),se.elements[pe].push(le.json())}),this._private.styleEnabled&&(se.style=U.style().json()),se.zoomingEnabled=U._private.zoomingEnabled,se.userZoomingEnabled=U._private.userZoomingEnabled,se.zoom=U._private.zoom,se.minZoom=U._private.minZoom,se.maxZoom=U._private.maxZoom,se.panningEnabled=U._private.panningEnabled,se.userPanningEnabled=U._private.userPanningEnabled,se.pan=T.copy(U._private.pan),se.boxSelectionEnabled=U._private.boxSelectionEnabled,se.renderer=T.copy(U._private.options.renderer),se.hideEdgesOnViewport=U._private.options.hideEdgesOnViewport,se.textureOnViewport=U._private.options.textureOnViewport,se.wheelSensitivity=U._private.options.wheelSensitivity,se.motionBlur=U._private.options.motionBlur,se}},scratch:R.data({field:"scratch",bindingEvent:"scratch",allowBinding:!0,allowSetting:!0,settingEvent:"scratch",settingTriggersEvent:!0,triggerFnName:"trigger",allowGetting:!0}),removeScratch:R.removeData({field:"scratch",event:"scratch",triggerFnName:"trigger",triggerEvent:!0})}),[E("./add-remove"),E("./animation"),E("./events"),E("./export"),E("./layout"),E("./notification"),E("./renderer"),E("./search"),E("./style"),E("./viewport")].forEach(function(M){T.extend($,M)}),_.exports=F},{"../collection":26,"../define":44,"../is":83,"../promise":85,"../util":99,"../window":106,"./add-remove":33,"./animation":34,"./events":35,"./export":36,"./layout":38,"./notification":39,"./renderer":40,"./search":41,"./style":42,"./viewport":43}],38:[function(E,_){"use strict";var D=E("../util"),T=E("../is"),I={layout:function(L){var O=this;if(null==L)return void D.error("Layout options must be specified to make a layout");if(null==L.name)return void D.error("A `name` must be specified to make a layout");var R=L.name,F=O.extension("layout",R);if(null==F)return void D.error("Can not apply layout: No such layout `"+R+"` found; did you include its JS file?");var $;$=T.string(L.eles)?O.$(L.eles):null==L.eles?O.$():L.eles;var M=new F(D.extend({},L,{cy:O,eles:$}));return M}};I.createLayout=I.makeLayout=I.layout,_.exports=I},{"../is":83,"../util":99}],39:[function(E,_){"use strict";_.exports={notify:function(D){var T=this._private;if(T.batchingNotify){var I=T.batchNotifyEles,L=T.batchNotifyTypes;return D.eles&&I.merge(D.eles),void(L.ids[D.type]||(L.push(D.type),L.ids[D.type]=!0));// notifications are disabled during batching
}if(T.notificationsEnabled){// exit on disabled
var O=this.renderer();// exit if destroy() called on core or renderer in between frames #1499
// TODO first check this.isDestroyed() in >=3.1 #1440
O&&O.notify(D)}},notifications:function(D){var T=this._private;return void 0===D?T.notificationsEnabled:void(T.notificationsEnabled=!!D)},noNotifications:function(D){this.notifications(!1),D(),this.notifications(!0)},startBatch:function(){var D=this._private;return null==D.batchCount&&(D.batchCount=0),0===D.batchCount&&(D.batchingStyle=D.batchingNotify=!0,D.batchStyleEles=this.collection(),D.batchNotifyEles=this.collection(),D.batchNotifyTypes=[],D.batchNotifyTypes.ids={}),D.batchCount++,this},endBatch:function(){var D=this._private;return D.batchCount--,0===D.batchCount&&(D.batchingStyle=!1,D.batchStyleEles.updateStyle(),D.batchingNotify=!1,this.notify({type:D.batchNotifyTypes,eles:D.batchNotifyEles})),this},batch:function(D){return this.startBatch(),D(),this.endBatch(),this},// for backwards compatibility
batchData:function(D){var T=this;return this.batch(function(){var I=Object.keys(D);for(var L=0;L<I.length;L++){var O=I[L],R=D[O],F=T.getElementById(O);F.data(R)}})}}},{}],40:[function(E,_){"use strict";var D=E("../util"),T={renderTo:function(I,L,O,R){var F=this._private.renderer;return F.renderTo(I,L,O,R),this},renderer:function(){return this._private.renderer},forceRender:function(){return this.notify({type:"draw"}),this},resize:function(){return this.invalidateSize(),this.notify({type:"resize"}),this.trigger("resize"),this},initRenderer:function(I){var L=this,O=L.extension("renderer",I.name);if(null==O)return void D.error("Can not initialise: No such renderer `%s` found; did you include its JS file?",I.name);var R=D.extend({},I,{cy:L});L._private.renderer=new O(R)},destroyRenderer:function(){var I=this;I.notify({type:"destroy"});// destroy the renderer
var L=I.container();if(L)for(L._cyreg=null;0<L.childNodes.length;)L.removeChild(L.childNodes[0]);I._private.renderer=null},onRender:function(I){return this.on("render",I)},offRender:function(I){return this.off("render",I)}};T.invalidateDimensions=T.resize,_.exports=T},{"../util":99}],41:[function(E,_){"use strict";var D=E("../is"),T=E("../collection"),I={// get a collection
// - empty collection on no args
// - collection of elements in the graph on selector arg
// - guarantee a returned collection when elements or collection specified
collection:function(L,O){//TODO use a switch on typeof, this is. stuff may be slower than that
if(D.string(L))return this.$(L);return D.elementOrCollection(L)?L.collection():D.array(L)?new T(this,L,O):new T(this)},nodes:function(L){var O=this.$(function(R){return R.isNode()});return L?O.filter(L):O},edges:function(L){var O=this.$(function(R){return R.isEdge()});return L?O.filter(L):O},// search the graph like jQuery
$:function(L){var O=this._private.elements;return L?O.filter(L):O.spawnSelf()},mutableElements:function(){return this._private.elements}};// aliases
I.elements=I.filter=I.$,_.exports=I},{"../collection":26,"../is":83}],42:[function(E,_){"use strict";var D=E("../is"),T=E("../style");_.exports={style:function(I){if(I){var L=this.setStyle(I);L.update()}return this._private.style},setStyle:function(I){var L=this._private;return L.style=D.stylesheet(I)?I.generateStyle(this):D.array(I)?T.fromJson(this,I):D.string(I)?T.fromString(this,I):T(this),L.style}}},{"../is":83,"../style":91}],43:[function(E,_){"use strict";var D=E("../is"),T={autolock:function(I){if(I!==void 0)this._private.autolock=!!I;else return this._private.autolock;return this;// chaining
},autoungrabify:function(I){if(I!==void 0)this._private.autoungrabify=!!I;else return this._private.autoungrabify;return this;// chaining
},autounselectify:function(I){if(I!==void 0)this._private.autounselectify=!!I;else return this._private.autounselectify;return this;// chaining
},panningEnabled:function(I){if(I!==void 0)this._private.panningEnabled=!!I;else return this._private.panningEnabled;return this;// chaining
},userPanningEnabled:function(I){if(I!==void 0)this._private.userPanningEnabled=!!I;else return this._private.userPanningEnabled;return this;// chaining
},zoomingEnabled:function(I){if(I!==void 0)this._private.zoomingEnabled=!!I;else return this._private.zoomingEnabled;return this;// chaining
},userZoomingEnabled:function(I){if(I!==void 0)this._private.userZoomingEnabled=!!I;else return this._private.userZoomingEnabled;return this;// chaining
},boxSelectionEnabled:function(I){if(I!==void 0)this._private.boxSelectionEnabled=!!I;else return this._private.boxSelectionEnabled;return this;// chaining
},pan:function(){var I=arguments,L=this._private.pan,O,R,F,$,M;switch(I.length){case 0:// .pan()
return L;case 1:if(D.string(I[0]))return O=I[0],L[O];if(D.plainObject(I[0])){// .pan({ x: 0, y: 100 })
if(!this._private.panningEnabled)return this;F=I[0],$=F.x,M=F.y,D.number($)&&(L.x=$),D.number(M)&&(L.y=M),this.trigger("pan viewport")}break;case 2:// .pan('x', 100)
if(!this._private.panningEnabled)return this;O=I[0],R=I[1],("x"===O||"y"===O)&&D.number(R)&&(L[O]=R),this.trigger("pan viewport");break;default:// invalid
}return this.notify({// notify the renderer that the viewport changed
type:"viewport"}),this;// chaining
},panBy:function(){var I=arguments,L=this._private.pan,O,R,F,$,M;if(!this._private.panningEnabled)return this;switch(I.length){case 1:D.plainObject(I[0])&&(F=I[0],$=F.x,M=F.y,D.number($)&&(L.x+=$),D.number(M)&&(L.y+=M),this.trigger("pan viewport"));break;case 2:O=I[0],R=I[1],("x"===O||"y"===O)&&D.number(R)&&(L[O]+=R),this.trigger("pan viewport");break;default:// invalid
}return this.notify({// notify the renderer that the viewport changed
type:"viewport"}),this;// chaining
},fit:function(I,L){var O=this.getFitViewport(I,L);if(O){var R=this._private;R.zoom=O.zoom,R.pan=O.pan,this.trigger("pan zoom viewport"),this.notify({// notify the renderer that the viewport changed
type:"viewport"})}return this;// chaining
},getFitViewport:function(I,L){if(D.number(I)&&void 0===L&&(L=I,I=void 0),this._private.panningEnabled&&this._private.zoomingEnabled){var O;if(D.string(I)){var R=I;I=this.$(R)}else if(D.boundingBox(I)){// assume bb
var F=I;O={x1:F.x1,y1:F.y1,x2:F.x2,y2:F.y2},O.w=O.x2-O.x1,O.h=O.y2-O.y1}else D.elementOrCollection(I)||(I=this.mutableElements());O=O||I.boundingBox();var $=this.width(),M=this.height(),U;if(L=D.number(L)?L:0,!isNaN($)&&!isNaN(M)&&0<$&&0<M&&!isNaN(O.w)&&!isNaN(O.h)&&0<O.w&&0<O.h){U=Math.min(($-2*L)/O.w,(M-2*L)/O.h),U=U>this._private.maxZoom?this._private.maxZoom:U,U=U<this._private.minZoom?this._private.minZoom:U;var Z={// now pan to middle
x:($-U*(O.x1+O.x2))/2,y:(M-U*(O.y1+O.y2))/2};return{zoom:U,pan:Z}}}},minZoom:function(I){return void 0===I?this._private.minZoom:(D.number(I)&&(this._private.minZoom=I),this)},maxZoom:function(I){return void 0===I?this._private.maxZoom:(D.number(I)&&(this._private.maxZoom=I),this)},zoom:function(I){var L,O;// in rendered px
if(void 0===I)// then get the zoom
return this._private.zoom;if(D.number(I))O=I;else if(D.plainObject(I)){if(O=I.level,I.position){var R=I.position,F=this._private.pan,$=this._private.zoom;L={// convert to rendered px
x:R.x*$+F.x,y:R.y*$+F.y}}else I.renderedPosition&&(L=I.renderedPosition);if(L&&!this._private.panningEnabled)return this;// panning disabled
}if(!this._private.zoomingEnabled)return this;// zooming disabled
if(!D.number(O)||L&&(!D.number(L.x)||!D.number(L.y)))return this;// can't zoom with invalid params
// crop zoom
if(O=O>this._private.maxZoom?this._private.maxZoom:O,O=O<this._private.minZoom?this._private.minZoom:O,L){// set zoom about position
var M=this._private.pan,U=this._private.zoom,Z=O,G={x:-Z/U*(L.x-M.x)+L.x,y:-Z/U*(L.y-M.y)+L.y};this._private.zoom=O,this._private.pan=G;var K=M.x!==G.x||M.y!==G.y;this.trigger(" zoom "+(K?" pan ":"")+" viewport ")}else this._private.zoom=O,this.trigger("zoom viewport");return this.notify({// notify the renderer that the viewport changed
type:"viewport"}),this;// chaining
},viewport:function(I){var L=this._private,O=!0,R=!0,F=[],$=!1,M=!1;// to trigger
if(!I)return this;if(D.number(I.zoom)||(O=!1),D.plainObject(I.pan)||(R=!1),!O&&!R)return this;if(O){var U=I.zoom;U<L.minZoom||U>L.maxZoom||!L.zoomingEnabled?$=!0:(L.zoom=U,F.push("zoom"))}if(R&&(!$||!I.cancelOnFailedZoom)&&L.panningEnabled){var Z=I.pan;D.number(Z.x)&&(L.pan.x=Z.x,M=!1),D.number(Z.y)&&(L.pan.y=Z.y,M=!1),M||F.push("pan")}return 0<F.length&&(F.push("viewport"),this.trigger(F.join(" ")),this.notify({type:"viewport"})),this;// chaining
},center:function(I){var L=this.getCenterPan(I);return L&&(this._private.pan=L,this.trigger("pan viewport"),this.notify({// notify the renderer that the viewport changed
type:"viewport"})),this;// chaining
},getCenterPan:function(I,L){if(this._private.panningEnabled){if(D.string(I)){var O=I;I=this.mutableElements().filter(O)}else D.elementOrCollection(I)||(I=this.mutableElements());var R=I.boundingBox(),F=this.width(),$=this.height();L=void 0===L?this._private.zoom:L;var M={// middle
x:(F-L*(R.x1+R.x2))/2,y:($-L*(R.y1+R.y2))/2};return M}},reset:function(){// chaining
return this._private.panningEnabled&&this._private.zoomingEnabled?(this.viewport({pan:{x:0,y:0},zoom:1}),this):this},invalidateSize:function(){this._private.sizeCache=null},size:function(){var I=this._private,L=I.container;return I.sizeCache=I.sizeCache||(L?{width:L.clientWidth,height:L.clientHeight}:{// fallback if no container (not 0 b/c can be used for dividing etc)
width:1,height:1})},width:function(){return this.size().width},height:function(){return this.size().height},extent:function(){var I=this._private.pan,L=this._private.zoom,O=this.renderedExtent(),R={x1:(O.x1-I.x)/L,x2:(O.x2-I.x)/L,y1:(O.y1-I.y)/L,y2:(O.y2-I.y)/L};return R.w=R.x2-R.x1,R.h=R.y2-R.y1,R},renderedExtent:function(){var I=this.width(),L=this.height();return{x1:0,y1:0,x2:I,y2:L,w:I,h:L}}};// aliases
T.centre=T.center,T.autolockNodes=T.autolock,T.autoungrabifyNodes=T.autoungrabify,_.exports=T},{"../is":83}],44:[function(E,_){"use strict";// use this module to cherry pick functions into your prototype
// (useful for functions shared between the core and collections, for example)
// e.g.
// var foo = define.foo({ /* params... */ })
var D=E("./util"),T=E("./is"),I=E("./selector"),L=E("./promise"),O=E("./event"),R=E("./animation"),F={// access data field
data:function($){return $=D.extend({},{field:"data",bindingEvent:"data",allowBinding:!1,allowSetting:!1,allowGetting:!1,settingEvent:"data",settingTriggersEvent:!1,triggerFnName:"trigger",immutableKeys:{},// key => true if immutable
updateStyle:!1,onSet:function(){},canSet:function(){return!0}},$),function(U,Z){var G=$,K=this,J=void 0!==K.length,ee=J?K:[K],te=J?K[0]:K;// put in array if not array-like
// .data('foo', ...)
if(T.string(U)){// set or get property
// .data('foo')
if(G.allowGetting&&void 0===Z){// get
var ae;return te&&(ae=te._private[G.field][U]),ae;// .data('foo', 'bar')
}// .data({ 'foo': 'bar' })
if(G.allowSetting&&void 0!==Z){// set
var ne=!G.immutableKeys[U];if(ne){for(var re=0,oe=ee.length;re<oe;re++)G.canSet(ee[re])&&(ee[re]._private[G.field][U]=Z);// update mappers if asked
G.updateStyle&&K.updateStyle(),G.onSet(K),G.settingTriggersEvent&&K[G.triggerFnName](G.settingEvent)}}}else if(G.allowSetting&&T.plainObject(U)){// extend
var se=U,ue=Object.keys(se),le,pe;for(var re=0;re<ue.length;re++){le=ue[re],pe=se[le];var ne=!G.immutableKeys[le];if(ne)for(var ge=0;ge<ee.length;ge++){var ce=ee[ge];G.canSet(ce)&&(ce._private[G.field][le]=pe)}}// update mappers if asked
G.updateStyle&&K.updateStyle(),G.onSet(K),G.settingTriggersEvent&&K[G.triggerFnName](G.settingEvent)}else if(G.allowBinding&&T.fn(U))K.on(G.bindingEvent,U);else if(G.allowGetting&&void 0===U){// get whole object
var ae;return te&&(ae=te._private[G.field]),ae}return K;// maintain chainability
};// function
},// data
// remove data field
removeData:function($){return $=D.extend({},{field:"data",event:"data",triggerFnName:"trigger",triggerEvent:!1,immutableKeys:{}// key => true if immutable
},$),function(U){var Z=$,G=this,K=void 0!==G.length,J=K?G:[G];// put in array if not array-like
// .removeData('foo bar')
if(T.string(U)){// then get the list of keys, and delete them
var ee=U.split(/\s+/),te=ee.length;for(var ae=0;ae<te;ae++){// delete each non-empty key
var ne=ee[ae];if(!T.emptyString(ne)){var re=!Z.immutableKeys[ne];// not valid if immutable
if(re)for(var oe=0,se=J.length;oe<se;oe++)J[oe]._private[Z.field][ne]=void 0}}Z.triggerEvent&&G[Z.triggerFnName](Z.event)}else if(void 0===U){// then delete all keys
for(var oe=0,se=J.length;oe<se;oe++){var le=J[oe]._private[Z.field],ee=Object.keys(le);for(var ae=0;ae<ee.length;ae++){var ne=ee[ae],pe=!Z.immutableKeys[ne];pe&&(le[ne]=void 0)}}Z.triggerEvent&&G[Z.triggerFnName](Z.event)}return G;// maintain chaining
};// function
},// removeData
// event function reusable stuff
event:{regex:/(\w+)(\.(?:\w+|\*))?/,// regex for matching event strings (e.g. "click.namespace")
universalNamespace:".*",// matches as if no namespace specified and prevents users from unbinding accidentally
optionalTypeRegex:/(\w+)?(\.(?:\w+|\*))?/,falseCallback:function(){return!1}},// event binding
on:function($){return $=D.extend({},{unbindSelfOnTrigger:!1,unbindAllBindersOnTrigger:!1},$),function(U,Z,G,K){var J=this,ee=void 0!==J.length,te=ee?J:[J],ae=T.string(U),ne=$;// put in array if not array-like
// if there isn't a callback, we can't really do anything
// (can't speak for mapped events arg version)
if(T.plainObject(Z)?(K=G,G=Z,Z=void 0):(T.fn(Z)||!1===Z)&&(K=Z,G=void 0,Z=void 0),(T.fn(G)||!1===G)&&(K=G,G=void 0),!(T.fn(K)||!1===K)&&ae)return J;// maintain chaining
if(ae){// then convert to map
var re={};re[U]=K,U=re}var oe=Object.keys(U);for(var se=0;se<oe.length;se++){var le=oe[se];// for events array
if(K=U[le],!1===K&&(K=F.event.falseCallback),!!T.fn(K)){le=le.split(/\s+/);for(var pe=0;pe<le.length;pe++){var ue=le[pe];if(!T.emptyString(ue)){var ge=ue.match(F.event.regex);// type[.namespace]
if(ge){var ce=ge[1],he=ge[2]?ge[2]:void 0,ye={callback:K,// callback to run
data:G,// extra data in eventObj.data
delegated:!!Z,// whether the evt is delegated
selector:Z,// the selector to match for delegated events
selObj:new I(Z),// cached selector object to save rebuilding
type:ce,// the event type (e.g. 'click')
namespace:he,// the event namespace (e.g. ".foo")
unbindSelfOnTrigger:ne.unbindSelfOnTrigger,unbindAllBindersOnTrigger:ne.unbindAllBindersOnTrigger,binders:te// who bound together
};for(var me=0;me<te.length;me++){var fe=te[me]._private=te[me]._private||{};fe.listeners=fe.listeners||[],fe.listeners.push(ye)}}}}}}// for events map
return J;// maintain chaining
};// function
},// on
eventAliasesOn:function($){var M=$;M.addListener=M.listen=M.bind=M.on,M.removeListener=M.unlisten=M.unbind=M.off,M.emit=M.trigger,M.pon=M.promiseOn=function(){var U=this,Z=Array.prototype.slice.call(arguments,0);return new L(function(G){var K=Z.concat([function(ee){U.off.apply(U,J),G(ee)}]),J=K.concat([]);U.on.apply(U,K)})}},off:function(M){return M=D.extend({},{},M),function(U,Z,G){var K=this,J=void 0!==K.length,ee=J?K:[K],te=T.string(U);// put in array if not array-like
if(0===arguments.length){// then unbind all
for(var ae=0;ae<ee.length;ae++)ee[ae]._private=ee[ae]._private||{},he.listeners=[];return K;// maintain chaining
}if((T.fn(Z)||!1===Z)&&(G=Z,Z=void 0),te){// then convert to map
var ne={};ne[U]=G,U=ne}var re=Object.keys(U);for(var oe=0;oe<re.length;oe++){var se=re[oe];G=U[se],!1===G&&(G=F.event.falseCallback),se=se.split(/\s+/);for(var le=0;le<se.length;le++){var pe=se[le];// if match
if(!T.emptyString(pe)){var ue=pe.match(F.event.optionalTypeRegex);// [type][.namespace]
if(ue){var ge=ue[1]?ue[1]:void 0,ce=ue[2]?ue[2]:void 0;for(var ae=0;ae<ee.length;ae++){//
var he=ee[ae]._private=ee[ae]._private||{},ye=he.listeners=he.listeners||[];for(var me=0;me<ye.length;me++){var fe=ye[me],xe=!ce||ce===fe.namespace,ve=!ge||fe.type===ge,be=!G||G===fe.callback;xe&&ve&&be&&(ye.splice(me,1),me--)}// for listeners
}// for all
}}}// for events array
}// for events map
return K;// maintain chaining
};// function
},// off
trigger:function($){return $=D.extend({},{},$),function(U,Z,G){var K=this,J=void 0!==K.length,ee=J?K:[K],te=T.string(U),ae=T.plainObject(U),ne=T.event(U),re=this._private=this._private||{},oe=re.cy||(T.core(this)?this:null),se=!!oe&&oe.hasCompoundNodes();// put in array if not array-like
if(te){// then make a plain event object for each event name
var le=U.split(/\s+/);U=[];for(var pe=0;pe<le.length;pe++){var ue=le[pe];if(!T.emptyString(ue)){var ge=ue.match(F.event.regex),ce=ge[1],he=ge[2]?ge[2]:void 0;// type[.namespace]
U.push({type:ce,namespace:he})}}}else if(ae){// put in length 1 array
var ye=U;U=[ye]}Z?!T.array(Z)&&(Z=[Z]):Z=[];for(var pe=0;pe<U.length;pe++){// trigger each event in order
var me=U[pe];for(var fe=0;fe<ee.length;fe++){// for each
var xe=ee[fe],re=xe._private=xe._private||{},ve=re.listeners=re.listeners||[],be=T.element(xe),we=be||$.layout,ue;// create the event for this element from the event object
// create a rendered position based on the passed position
if(ne?(ue=me,ue.target=ue.target||xe,ue.cy=ue.cy||oe):ue=new O(me,{target:xe,cy:oe,namespace:me.namespace}),me.layout&&(ue.layout=me.layout),$.layout&&(ue.layout=xe),ue.position){var Ee=ue.position,Se=oe.zoom(),_e=oe.pan();ue.renderedPosition={x:Ee.x*Se+_e.x,y:Ee.y*Se+_e.y}}G&&(ve=[{namespace:ue.namespace,type:ue.type,callback:G}]);for(var Pe=0;Pe<ve.length;Pe++){// check each listener
var Ce=ve[Pe],De=!Ce.namespace||Ce.namespace===ue.namespace||Ce.namespace===F.event.universalNamespace,Te=Ce.type===ue.type,ke=!Ce.delegated||xe!==ue.target&&T.element(ue.target)&&Ce.selObj.matches(ue.target);// we're not going to validate the hierarchy; that's too expensive
if(De&&Te&&ke){// then trigger it
var Ie=[ue];if(Ie=Ie.concat(Z),ue.data=Ce.data?Ce.data:void 0,(Ce.unbindSelfOnTrigger||Ce.unbindAllBindersOnTrigger)&&(ve.splice(Pe,1),Pe--),Ce.unbindAllBindersOnTrigger){// then delete the listener for all binders
var Ne=Ce.binders;for(var ze=0;ze<Ne.length;ze++){var Be=Ne[ze];if(Be&&Be!==xe){// already handled triggerer or we can't handle it
var Le=Be._private.listeners;for(var Oe=0;Oe<Le.length;Oe++){var Ae=Le[Oe];Ae===Ce&&(Le.splice(Oe,1),Oe--)}}}}// run the callback
var je=Ce.delegated?ue.target:xe,Re=Ce.callback.apply(je,Ie);(!1===Re||ue.isPropagationStopped())&&(we=!1,!1===Re&&(ue.stopPropagation(),ue.preventDefault()))}// if listener matches
}// for each listener
// bubble up event for elements
if(we){var qe=se?xe._private.parent:null,Ve=null!=qe&&0!==qe.length;Ve?(qe=qe[0],qe.trigger(ue)):oe.trigger(ue)}}// for each of all
}// for each event
return K;// maintain chaining
};// function
},// trigger
animated:function($){return $=D.extend({},{},$),function(){var U=this,Z=void 0!==U.length,G=Z?U:[U],K=this._private.cy||this;// put in array if not array-like
if(!K.styleEnabled())return!1;var J=G[0];if(J)return 0<J._private.animation.current.length}},// animated
clearQueue:function($){return $=D.extend({},{},$),function(){var U=this,Z=void 0!==U.length,G=Z?U:[U],K=this._private.cy||this;// put in array if not array-like
if(!K.styleEnabled())return this;for(var J=0;J<G.length;J++){var ee=G[J];ee._private.animation.queue=[]}return this}},// clearQueue
delay:function($){return $=D.extend({},{},$),function(U,Z){var G=this._private.cy||this;return G.styleEnabled()?this.animate({delay:U,duration:U,complete:Z}):this}},// delay
delayAnimation:function($){return $=D.extend({},{},$),function(U,Z){var G=this._private.cy||this;return G.styleEnabled()?this.animation({delay:U,duration:U,complete:Z}):this}},// delay
animation:function($){return $=D.extend({},{},$),function(U,Z){var G=this,K=void 0!==G.length,J=K?G:[G],ee=this._private.cy||this,te=!K,ae=!te;// put in array if not array-like
if(!ee.styleEnabled())return this;var ne=ee.style();switch(U=D.extend({},U,Z),void 0===U.duration&&(U.duration=400),U.duration){case"slow":U.duration=600;break;case"fast":U.duration=200;}var re=0===Object.keys(U).length;if(re)return new R(J[0],U);// nothing to animate
if(ae&&(U.style=ne.getPropsList(U.style||U.css),U.css=void 0),U.renderedPosition&&ae){var oe=U.renderedPosition,se=ee.pan(),le=ee.zoom();U.position={x:(oe.x-se.x)/le,y:(oe.y-se.y)/le}}// override pan w/ panBy if set
if(U.panBy&&te){var pe=U.panBy,ue=ee.pan();U.pan={x:ue.x+pe.x,y:ue.y+pe.y}}// override pan w/ center if set
var ge=U.center||U.centre;if(ge&&te){var ce=ee.getCenterPan(ge.eles,U.zoom);ce&&(U.pan=ce)}// override pan & zoom w/ fit if set
if(U.fit&&te){var he=U.fit,ye=ee.getFitViewport(he.eles||he.boundingBox,he.padding);ye&&(U.pan=ye.pan,U.zoom=ye.zoom)}return new R(J[0],U)}},// animate
animate:function($){return $=D.extend({},{},$),function(U,Z){var G=this,K=void 0!==G.length,J=K?G:[G],ee=this._private.cy||this;// put in array if not array-like
if(!ee.styleEnabled())return this;Z&&(U=D.extend({},U,Z));// manually hook and run the animation
for(var te=0;te<J.length;te++){var ae=J[te],ne=ae.animated()&&(void 0===U.queue||U.queue),re=ae.animation(U,ne?{queue:!0}:void 0);re.play()}return this;// chaining
}},// animate
stop:function($){return $=D.extend({},{},$),function(U,Z){var G=this,K=void 0!==G.length,J=K?G:[G],ee=this._private.cy||this;// put in array if not array-like
if(!ee.styleEnabled())return this;for(var te=0;te<J.length;te++){var ae=J[te],ne=ae._private,re=ne.animation.current;for(var oe=0;oe<re.length;oe++){var se=re[oe],le=se._private;Z&&(le.duration=0)}// clear the queue of future animations
U&&(ne.animation.queue=[]),Z||(ne.animation.current=[])}// we have to notify (the animation loop doesn't do it for us on `stop`)
return ee.notify({eles:this,type:"draw"}),this}}// stop
};// define
_.exports=F},{"./animation":2,"./event":45,"./is":83,"./promise":85,"./selector":86,"./util":99}],45:[function(E,_){"use strict";/*!
 Event object based on jQuery events, MIT license

 https://jquery.org/license/
 https://tldrlegal.com/license/mit-license
 https://github.com/jquery/jquery/blob/master/src/event.js
 */var D=function(L,O){// Allow instantiation without the 'new' keyword
return this instanceof D?void(L&&L.type?(this.originalEvent=L,this.type=L.type,this.isDefaultPrevented=L.defaultPrevented?I:T):this.type=L,O&&(this.type=O.type===void 0?this.type:O.type,this.cy=O.cy,this.target=O.target,this.position=O.position,this.renderedPosition=O.renderedPosition,this.namespace=O.namespace,this.layout=O.layout,this.data=O.data,this.message=O.message),this.timeStamp=L&&L.timeStamp||Date.now()):new D(L,O);// Event object
};const T=()=>!1,I=()=>!0;// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
D.prototype={instanceString:function(){return"event"},preventDefault:function(){this.isDefaultPrevented=I;var L=this.originalEvent;if(L){// if preventDefault exists run it on the original event
const O=L.preventDefault;O&&O()}},stopPropagation:function(){this.isPropagationStopped=I;var L=this.originalEvent;!L||L.stopPropagation&&L.stopPropagation();// if stopPropagation exists run it on the original event
},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=I,this.stopPropagation()},isDefaultPrevented:T,isPropagationStopped:T,isImmediatePropagationStopped:T},_.exports=D},{}],46:[function(E,_){"use strict";function D(J,ee,te){var ae=te,ne=function(ve){O.error("Can not register `"+ee+"` for `"+J+"` since `"+ve+"` already exists in the prototype and can not be overridden")};if("core"===J){if($.prototype[ee])return ne(ee);$.prototype[ee]=te}else if("collection"===J){if(F.prototype[ee])return ne(ee);F.prototype[ee]=te}else if("layout"===J){// fill in missing layout functions in the prototype
var re=function(ve){this.options=ve,te.call(this,ve),U.plainObject(this._private)||(this._private={}),this._private.cy=ve.cy,this._private.listeners=[]},oe=re.prototype=Object.create(te.prototype),se=[];for(var le=0;le<se.length;le++){var pe=se[le];oe[pe]=oe[pe]||function(){return this}}// either .start() or .run() is defined, so autogen the other
oe.start&&!oe.run?oe.run=function(){return this.start(),this}:!oe.start&&oe.run&&(oe.start=function(){return this.run(),this}),oe.stop||(oe.stop=function(){var ve=this.options;if(ve&&ve.animate){var be=this.animations;for(var we=0;we<be.length;we++)be[we].stop()}return this.trigger("layoutstop"),this}),oe.destroy||(oe.destroy=function(){return this}),oe.on=R.on({layout:!0}),oe.one=R.on({layout:!0,unbindSelfOnTrigger:!0}),oe.once=R.on({layout:!0,unbindAllBindersOnTrigger:!0}),oe.off=R.off({layout:!0}),oe.trigger=R.trigger({layout:!0}),R.eventAliasesOn(oe),ae=re}else if("renderer"===J&&"null"!==ee&&"base"!==ee){// user registered renderers inherit from base
var ue=T("renderer","base"),ge=ue.prototype,ce=te.prototype,he=function(){ue.apply(this,arguments),te.apply(this,arguments)},ye=he.prototype;for(var me in ge){var fe=ge[me],xe=null!=ce[me];if(xe)return ne(me);ye[me]=fe}for(var me in ce)ye[me]=ce[me];// take impl from registrant
ge.clientFunctions.forEach(function(ve){ye[ve]=ye[ve]||function(){O.error("Renderer does not implement `renderer."+ve+"()` on its prototype")}}),ae=he}return O.setMap({map:Z,keys:[J,ee],value:ae})}function T(J,ee){return O.getMap({map:Z,keys:[J,ee]})}function I(J,ee,te,ae,ne){return O.setMap({map:G,keys:[J,ee,te,ae],value:ne})}function L(J,ee,te,ae){return O.getMap({map:G,keys:[J,ee,te,ae]})}var O=E("./util"),R=E("./define"),F=E("./collection"),$=E("./core"),M=E("./extensions"),U=E("./is"),Z={},G={},K=function(){// e.g. extension('renderer', 'svg')
if(2===arguments.length)return T.apply(null,arguments);// e.g. extension('renderer', 'svg', { ... })
// e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
return 3===arguments.length?D.apply(null,arguments):4===arguments.length?L.apply(null,arguments):5===arguments.length?I.apply(null,arguments):void O.error("Invalid extension access syntax");// e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
};// registered extensions to cytoscape, indexed by name
// registered modules for extensions, indexed by name
// allows a core instance to access extensions internally
$.prototype.extension=K,M.forEach(function(J){J.extensions.forEach(function(ee){D(J.type,ee.name,ee.impl)})}),_.exports=K},{"./collection":26,"./core":37,"./define":44,"./extensions":47,"./is":83,"./util":99}],47:[function(E,_){"use strict";_.exports=[{type:"layout",extensions:E("./layout")},{type:"renderer",extensions:E("./renderer")}]},{"./layout":53,"./renderer":78}],48:[function(E,_){"use strict";function D(R){this.options=T.extend({},O,R)}var T=E("../../util"),I=E("../../math"),L=E("../../is"),O={fit:!0,// whether to fit the viewport to the graph
directed:!1,// whether the tree is directed downwards (or edges can point in any direction if false)
padding:30,// padding on fit
circle:!1,// put depths in concentric circles if true, put depths top down if false
spacingFactor:1.75,// positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
boundingBox:void 0,// constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
avoidOverlap:!0,// prevents node overlap, may overflow boundingBox if not enough space
roots:void 0,// the roots of the trees
maximalAdjustments:0,// how many times to try to position the nodes in a maximal way (i.e. no backtracking)
animate:!1,// whether to transition the node positions
animationDuration:500,// duration of animation in ms if enabled
animationEasing:void 0,// easing of animation if enabled
ready:void 0,// callback on layoutready
stop:void 0// callback on layoutstop
};D.prototype.run=function(){var R=this.options,F=R,$=R.cy,M=F.eles,U=M.nodes().not(":parent"),Z=I.makeBoundingBox(F.boundingBox?F.boundingBox:{x1:0,y1:0,w:$.width(),h:$.height()}),G;if(L.elementOrCollection(F.roots))G=F.roots;else if(L.array(F.roots)){var K=[];for(var J=0;J<F.roots.length;J++){var ee=F.roots[J],te=$.getElementById(ee);K.push(te)}G=$.collection(K)}else if(L.string(F.roots))G=$.$(F.roots);else if(F.directed)G=U.roots();else{for(var ae=[],ne=U;0<ne.length;){var re=$.collection();M.bfs({roots:ne[0],visit:function(Me){re=re.add(Me)},directed:!1}),ne=ne.not(re),ae.push(re)}G=$.collection();for(var J=0;J<ae.length;J++){var oe=ae[J],se=oe.maxDegree(!1),le=oe.filter(function(Me){return Me.degree(!1)===se});G=G.add(le)}}var pe=[],ue={},ge={},ce={},he={},ye={};M.bfs({roots:G,directed:F.directed,visit:function(Me,Ue,Ze,Ge,Ke){var Qe=Me[0],Je=Qe.id();if(pe[Ke]||(pe[Ke]=[]),pe[Ke].push(Qe),ue[Je]=!0,ge[Je]=Ke,ce[Je]=Ze,he[Je]=Ue,Ze){var tt=Ze.id(),at=ye[tt]=ye[tt]||[];at.push(Me)}}});// check for nodes not found by bfs
var me=[];for(var J=0;J<U.length;J++){var te=U[J];if(ue[te.id()])continue;else me.push(te)}// assign orphan nodes a depth from their neighborhood
for(var fe=3*me.length,xe=0;0!==me.length&&xe<fe;){var ve=me.shift(),be=ve.neighborhood().nodes(),we=!1;for(var J=0;J<be.length;J++){var Ee=ge[be[J].id()];if(void 0!==Ee){pe[Ee].push(ve),we=!0;break}}we||me.push(ve),xe++}// assign orphan nodes that are still left to the depth of their subgraph
for(;0!==me.length;){var ve=me.shift(),we=!1;//var subgraph = graph.bfs( node ).path;
we||(0===pe.length&&pe.push([]),pe[0].push(ve))}// assign the nodes a depth and index
var Se=function(){for(var Me=0;Me<pe.length;Me++){var Ue=pe[Me];for(var Ze=0;Ze<Ue.length;Ze++){var Ge=Ue[Ze];Ge._private.scratch.breadthfirst={depth:Me,index:Ze}}}};Se();var _e=function(Me){// returns true if has edges pointing in from a higher depth
var Ue=Me.connectedEdges(function(nt){return nt.data("target")===Me.id()}),Ze=Me._private.scratch.breadthfirst,Ge=0,Ke;for(var Qe=0;Qe<Ue.length;Qe++){var Je=Ue[Qe],tt=Je.source()[0],at=tt._private.scratch.breadthfirst;Ze.depth<=at.depth&&Ge<at.depth&&(Ge=at.depth,Ke=tt)}return Ke};// make maximal if so set by adjusting depths
for(var Pe=0;Pe<F.maximalAdjustments;Pe++){var Ce=pe.length,De=[];for(var J=0;J<Ce;J++){var Ee=pe[J],Te=Ee.length;for(var ke=0;ke<Te;ke++){var te=Ee[ke],Ie=te._private.scratch.breadthfirst,Ne=_e(te);Ne&&(Ie.intEle=Ne,De.push(te))}}for(var J=0;J<De.length;J++){var te=De[J],Ie=te._private.scratch.breadthfirst,Ne=Ie.intEle,ze=Ne._private.scratch.breadthfirst;pe[Ie.depth].splice(Ie.index,1);for(// remove from old depth & index
// add to end of new depth
var Be=ze.depth+1;Be>pe.length-1;)pe.push([]);pe[Be].push(te),Ie.depth=Be,Ie.index=pe[Be].length-1}Se()}// find min distance we need to leave between nodes
var Le=0;if(F.avoidOverlap){for(var J=0;J<U.length;J++){var Oe=U[J],Ae=Oe.boundingBox(),je=Ae.w,Re=Ae.h;Le=Math.max(Le,je,Re)}Le*=F.spacingFactor}// get the weighted percent for an element based on its connectivity to other levels
var qe={},Ve=function(Me){if(qe[Me.id()])return qe[Me.id()];var Ue=Me._private.scratch.breadthfirst.depth,Ze=Me.neighborhood().nodes().not(":parent"),Ge=0,Ke=0;for(var Qe=0;Qe<Ze.length;Qe++){var Je=Ze[Qe],tt=Je._private.scratch.breadthfirst,at=tt.index,nt=tt.depth,it=pe[nt].length;(Ue>nt||0===Ue)&&(Ge+=at/it,Ke++)}return Ke=Math.max(1,Ke),Ge=Ge/Ke,0==Ke&&(Ge=void 0),qe[Me.id()]=Ge,Ge},Fe=function(Me,Ue){var Ze=Ve(Me),Ge=Ve(Ue);return Ze-Ge};// rearrange the indices in each depth level based on connectivity
for(var Xe=0;3>Xe;Xe++){// do it a few times b/c the depths are dynamic and we want a more stable result
for(var J=0;J<pe.length;J++)pe[J]=pe[J].sort(Fe);Se()}var Ye=0;for(var J=0;J<pe.length;J++)Ye=Math.max(pe[J].length,Ye);var We={x:Z.x1+Z.w/2,y:Z.x1+Z.h/2},He=function(Me,Ue){var Ze=Me._private.scratch.breadthfirst,Ge=Ze.depth,Ke=Ze.index,Qe=pe[Ge].length,Je=Math.max(Z.w/(Qe+1),Le),tt=Math.max(Z.h/(pe.length+1),Le),at=Math.min(Z.w/2/pe.length,Z.h/2/pe.length);if(at=Math.max(at,Le),!F.circle){var nt={x:We.x+(Ke+1-(Qe+1)/2)*Je,y:(Ge+1)*tt};return Ue?nt:nt;// var succs = successors[ ele.id() ];
// if( succs ){
//   epos.x = 0;
//
//   for( var i = 0 ; i < succs.length; i++ ){
//     var spos = pos[ succs[i].id() ];
//
//     epos.x += spos.x;
//   }
//
//   epos.x /= succs.length;
// } else {
//   //debugger;
// }
}if(F.circle){var it=at*Ge+at-(0<pe.length&&3>=pe[0].length?at/2:0),rt=2*Math.PI/pe[Ge].length*Ke;return 0===Ge&&1===pe[0].length&&(it=1),{x:We.x+it*Math.cos(rt),y:We.y+it*Math.sin(rt)}}return{x:We.x+(Ke+1-(Qe+1)/2)*Je,y:(Ge+1)*tt}},$e={};// get positions in reverse depth order
for(var J=pe.length-1;0<=J;J--){var Ee=pe[J];for(var ke=0;ke<Ee.length;ke++){var ve=Ee[ke];$e[ve.id()]=He(ve,J===pe.length-1)}}return U.layoutPositions(this,F,function(Me){return $e[Me.id()]}),this;// chaining
},_.exports=D},{"../../is":83,"../../math":84,"../../util":99}],49:[function(E,_){"use strict";function D(R){this.options=T.extend({},O,R)}var T=E("../../util"),I=E("../../math"),L=E("../../is"),O={fit:!0,// whether to fit the viewport to the graph
padding:30,// the padding on fit
boundingBox:void 0,// constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
avoidOverlap:!0,// prevents node overlap, may overflow boundingBox and radius if not enough space
radius:void 0,// the radius of the circle
startAngle:3/2*Math.PI,// where nodes start in radians
sweep:void 0,// how many radians should be between the first and last node (defaults to full circle)
clockwise:!0,// whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
sort:void 0,// a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
animate:!1,// whether to transition the node positions
animationDuration:500,// duration of animation in ms if enabled
animationEasing:void 0,// easing of animation if enabled
ready:void 0,// callback on layoutready
stop:void 0// callback on layoutstop
};D.prototype.run=function(){var R=this.options,F=R,$=R.cy,M=F.eles,U=void 0===F.counterclockwise?F.clockwise:!F.counterclockwise,Z=M.nodes().not(":parent");F.sort&&(Z=Z.sort(F.sort));var G=I.makeBoundingBox(F.boundingBox?F.boundingBox:{x1:0,y1:0,w:$.width(),h:$.height()}),K={x:G.x1+G.w/2,y:G.y1+G.h/2},J=void 0===F.sweep?2*Math.PI-2*Math.PI/Z.length:F.sweep,ee=J/Math.max(1,Z.length-1),ae=0,te;for(var ne=0;ne<Z.length;ne++){var re=Z[ne],oe=re.boundingBox(),se=oe.w,le=oe.h;ae=Math.max(ae,se,le)}// calculate the radius
if(te=L.number(F.radius)?F.radius:1>=Z.length?0:Math.min(G.h,G.w)/2-ae,1<Z.length&&F.avoidOverlap){ae*=1.75;// just to have some nice spacing
var pe=Math.cos(ee)-Math.cos(0),ue=Math.sin(ee)-Math.sin(0),ge=Math.sqrt(ae*ae/(pe*pe+ue*ue));te=Math.max(ge,te)}return Z.layoutPositions(this,F,function(ce,he){var ye=F.startAngle+he*ee*(U?1:-1),me=te*Math.cos(ye),fe=te*Math.sin(ye),xe={x:K.x+me,y:K.y+fe};return xe}),this;// chaining
},_.exports=D},{"../../is":83,"../../math":84,"../../util":99}],50:[function(E,_){"use strict";function D(O){this.options=T.extend({},L,O)}var T=E("../../util"),I=E("../../math"),L={fit:!0,// whether to fit the viewport to the graph
padding:30,// the padding on fit
startAngle:3/2*Math.PI,// where nodes start in radians
sweep:void 0,// how many radians should be between the first and last node (defaults to full circle)
clockwise:!0,// whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
equidistant:!1,// whether levels have an equal radial distance betwen them, may cause bounding box overflow
minNodeSpacing:10,// min spacing between outside of nodes (used for radius adjustment)
boundingBox:void 0,// constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
avoidOverlap:!0,// prevents node overlap, may overflow boundingBox if not enough space
height:void 0,// height of layout area (overrides container height)
width:void 0,// width of layout area (overrides container width)
concentric:function(O){// returns numeric value for each node, placing higher nodes in levels towards the centre
return O.degree()},levelWidth:function(O){// the variation of concentric values in each level
return O.maxDegree()/4},animate:!1,// whether to transition the node positions
animationDuration:500,// duration of animation in ms if enabled
animationEasing:void 0,// easing of animation if enabled
ready:void 0,// callback on layoutready
stop:void 0// callback on layoutstop
};D.prototype.run=function(){var O=this.options,R=O,F=void 0===R.counterclockwise?R.clockwise:!R.counterclockwise,$=O.cy,M=R.eles,U=M.nodes().not(":parent"),Z=I.makeBoundingBox(R.boundingBox?R.boundingBox:{x1:0,y1:0,w:$.width(),h:$.height()}),G={x:Z.x1+Z.w/2,y:Z.y1+Z.h/2},K=[],J=R.startAngle,ee=0;// { node, value }
for(var te=0;te<U.length;te++){var ae=U[te],ne=R.concentric(ae);K.push({value:ne,node:ae}),ae._private.scratch.concentric=ne}// in case we used the `concentric` in style
U.updateStyle();// calculate max size now based on potentially updated mappers
for(var te=0;te<U.length;te++){var ae=U[te],re=ae.boundingBox();ee=Math.max(ee,re.w,re.h)}// sort node values in descreasing order
K.sort(function(Te,ke){return ke.value-Te.value});var oe=R.levelWidth(U),se=[[]],le=se[0];// put the values into levels
for(var te=0;te<K.length;te++){var pe=K[te];if(0<le.length){var ue=Math.abs(le[0].value-pe.value);ue>=oe&&(le=[],se.push(le))}le.push(pe)}// create positions from levels
var ge=ee+R.minNodeSpacing;// min dist between nodes
if(!R.avoidOverlap){// then strictly constrain to bb
var ce=0<se.length&&1<se[0].length,he=Math.min(Z.w,Z.h)/2-ge,ye=he/(se.length+ce?1:0);ge=Math.min(ge,ye)}// find the metrics for each level
var me=0;for(var te=0;te<se.length;te++){var fe=se[te],xe=void 0===R.sweep?2*Math.PI-2*Math.PI/fe.length:R.sweep,ve=fe.dTheta=xe/Math.max(1,fe.length-1);// calculate the radius
if(1<fe.length&&R.avoidOverlap){// but only if more than one node (can't overlap)
var be=Math.cos(ve)-Math.cos(0),we=Math.sin(ve)-Math.sin(0),Ee=Math.sqrt(ge*ge/(be*be+we*we));me=Math.max(Ee,me)}fe.r=me,me+=ge}if(R.equidistant){var Se=0,me=0;for(var te=0;te<se.length;te++){var fe=se[te],_e=fe.r-me;Se=Math.max(Se,_e)}me=0;for(var te=0;te<se.length;te++){var fe=se[te];0===te&&(me=fe.r),fe.r=me,me+=Se}}// calculate the node positions
var Pe={};// id => position
for(var te=0;te<se.length;te++){var fe=se[te],ve=fe.dTheta,me=fe.r;for(var Ce=0;Ce<fe.length;Ce++){var pe=fe[Ce],J=R.startAngle+(F?1:-1)*ve*Ce,De={x:G.x+me*Math.cos(J),y:G.y+me*Math.sin(J)};Pe[pe.node.id()]=De}}// position the nodes
return U.layoutPositions(this,R,function(Te){var ke=Te.id();return Pe[ke]}),this;// chaining
},_.exports=D},{"../../math":84,"../../util":99}],51:[function(E,_){"use strict";/*
The CoSE layout was written by Gerardo Huck.
https://www.linkedin.com/in/gerardohuck/

Based on the following article:
http://dl.acm.org/citation.cfm?id=1498047

Modifications tracked on Github.
*//**
 * @brief       : constructor
 * @arg options : object containing layout options
 */function D(J){this.options=T.extend({},F,J),this.options.layout=this}/**
 * @brief : runs the layout
 */var T=E("../../util"),I=E("../../math"),L=E("../../thread"),O=E("../../is"),R,F={// Called on `layoutready`
ready:function(){},// Called on `layoutstop`
stop:function(){},// Whether to animate while running the layout
animate:!0,// The layout animates only after this many milliseconds
// (prevents flashing on fast runs)
animationThreshold:250,// Number of iterations between consecutive screen positions update
// (0 -> only updated on the end)
refresh:20,// Whether to fit the network view after when done
fit:!0,// Padding on fit
padding:30,// Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
boundingBox:void 0,// Randomize the initial positions of the nodes (true) or use existing positions (false)
randomize:!1,// Extra spacing between components in non-compound graphs
componentSpacing:100,// Node repulsion (non overlapping) multiplier
nodeRepulsion:function(){return 400000},// Node repulsion (overlapping) multiplier
nodeOverlap:10,// Ideal edge (non nested) length
idealEdgeLength:function(){return 10},// Divisor to compute edge forces
edgeElasticity:function(){return 100},// Nesting factor (multiplier) to compute ideal edge length for nested edges
nestingFactor:5,// Gravity force (constant)
gravity:80,// Maximum number of iterations to perform
numIter:1000,// Initial temperature (maximum node displacement)
initialTemp:200,// Cooling factor (how the temperature is reduced between consecutive iterations
coolingFactor:0.95,// Lower temperature threshold (below this point the layout will end)
minTemp:1,// Whether to use threading to speed up the layout
useMultitasking:!0};/**
 * @brief :  default layout options
 */D.prototype.run=function(){var J=this.options,ee=J.cy,te=this,ae=this.thread;(!ae||ae.stopped())&&(ae=this.thread=L({disabled:!J.useMultitasking})),te.stopped=!1,te.trigger({type:"layoutstart",layout:te}),R=!(!0!==J.debug);// Initialize layout info
var ne=$(ee,te,J);// Show LayoutInfo contents if debugging
R&&Z(ne),J.randomize&&G(ne,ee);var re=Date.now(),oe=!1,se=function(pe){pe=pe||{};oe&&!pe.next||!pe.force&&Date.now()-re<J.animationThreshold||(oe=!0,T.requestAnimationFrame(function(){K(ne,ee,J),!0===J.fit&&ee.fit(J.padding),oe=!1,pe.next&&pe.next()}))};ae.on("message",function(pe){var ue=pe.message;ne.layoutNodes=ue,se()}),ae.pass({layoutInfo:ne,options:{animate:J.animate,refresh:J.refresh,componentSpacing:J.componentSpacing,nodeOverlap:J.nodeOverlap,nestingFactor:J.nestingFactor,gravity:J.gravity,numIter:J.numIter,initialTemp:J.initialTemp,coolingFactor:J.coolingFactor,minTemp:J.minTemp}}).run(function(pe){var ue=pe.layoutInfo,ge=pe.options,ce=function(Te,ke){he(Te,ke),xe(Te,ke),ve(Te,ke),be(Te,ke),we(Te,ke)},he=function(Te,ke){// Go through each of the graphs in graphSet
// Nodes only repel each other if they belong to the same graph
// var s = 'calculateNodeForces';
// logDebug(s);
for(var Ie=0;Ie<Te.graphSet.length;Ie++){var Ne=Te.graphSet[Ie],ze=Ne.length;// s = "Set: " + graph.toString();
// logDebug(s);
// Now get all the pairs of nodes
// Only get each pair once, (A, B) = (B, A)
for(var Be=0;Be<ze;Be++){var Le=Te.layoutNodes[Te.idToIndex[Ne[Be]]];for(var Oe=Be+1;Oe<ze;Oe++){var Ae=Te.layoutNodes[Te.idToIndex[Ne[Oe]]];ye(Le,Ae,Te,ke)}}}},ye=function(Te,ke,Ie,Ne){// var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;
var ze=Te.cmptId,Be=ke.cmptId;// Apply force
if(ze===Be||Ie.isCompound){// Get direction of line connecting both node centers
var Le=ke.positionX-Te.positionX,Oe=ke.positionY-Te.positionY;// s += "\ndirectionX: " + directionX + ", directionY: " + directionY;
// If both centers are the same, apply a random force
if(0!=Le||0!=Oe){var Ae=me(Te,ke,Le,Oe);if(0<Ae)// s += "\nNodes DO overlap.";
// s += "\nOverlap: " + overlap;
// If nodes overlap, repulsion force is proportional
// to the overlap
var je=Ne.nodeOverlap*Ae,Re=Math.sqrt(Le*Le+Oe*Oe),qe=je*Le/Re,Ve=je*Oe/Re;// Compute the module and components of the force vector
// s += "\nDistance: " + distance;
else// s += "\nNodes do NOT overlap.";
// If there's no overlap, force is inversely proportional
// to squared distance
// Get clipping points for both nodes
var Fe=fe(Te,Le,Oe),Xe=fe(ke,-1*Le,-1*Oe),Ye=Xe.x-Fe.x,We=Xe.y-Fe.y,He=Ye*Ye+We*We,Re=Math.sqrt(He),je=(Te.nodeRepulsion+ke.nodeRepulsion)/He,qe=je*Ye/Re,Ve=je*We/Re;// Use clipping points to compute distance
// s += "\nDistance: " + distance;
// Compute the module and components of the force vector
Te.isLocked||(Te.offsetX-=qe,Te.offsetY-=Ve),ke.isLocked||(ke.offsetX+=qe,ke.offsetY+=Ve)}}},me=function(Te,ke,Ie,Ne){if(0<Ie)var ze=Te.maxX-ke.minX;else var ze=ke.maxX-Te.minX;if(0<Ne)var Be=Te.maxY-ke.minY;else var Be=ke.maxY-Te.minY;return 0<=ze&&0<=Be?Math.sqrt(ze*ze+Be*Be):0},fe=function(Te,ke,Ie){// Shorcuts
var Ne=Te.positionX,ze=Te.positionY,Be=Te.height||1,Le=Te.width||1,Oe=Ie/ke,Ae=Be/Le,je={};// var s = 'Computing clipping point of node ' + node.id +
//   " . Height:  " + H + ", Width: " + W +
//   "\nDirection " + dX + ", " + dY;
//
// Compute intersection
{// Case: Vertical direction (up)
if(0===ke&&0<Ie){je.x=Ne,je.y=ze+Be/2;break}// Case: Vertical direction (down)
if(0===ke&&0>Ie){je.x=Ne,je.y=ze+Be/2;// s += "\nDown direction";
break}// Case: Intersects the right border
if(0<ke&&-1*Ae<=Oe&&Oe<=Ae){je.x=Ne+Le/2,je.y=ze+Le*Ie/2/ke;// s += "\nRightborder";
break}// Case: Intersects the left border
if(0>ke&&-1*Ae<=Oe&&Oe<=Ae){je.x=Ne-Le/2,je.y=ze-Le*Ie/2/ke;// s += "\nLeftborder";
break}// Case: Intersects the top border
if(0<Ie&&(Oe<=-1*Ae||Oe>=Ae)){je.x=Ne+Be*ke/2/Ie,je.y=ze+Be/2;// s += "\nTop border";
break}// Case: Intersects the bottom border
if(0>Ie&&(Oe<=-1*Ae||Oe>=Ae)){je.x=Ne-Be*ke/2/Ie,je.y=ze-Be/2;// s += "\nBottom border";
break}}// s += "\nClipping point found at " + res.x + ", " + res.y;
// logDebug(s);
return je},xe=function(Te){// Iterate over all edges
for(var ke=0;ke<Te.edgeSize;ke++){// Get edge, source & target nodes
var Ie=Te.layoutEdges[ke],Ne=Te.idToIndex[Ie.sourceId],ze=Te.layoutNodes[Ne],Be=Te.idToIndex[Ie.targetId],Le=Te.layoutNodes[Be],Oe=Le.positionX-ze.positionX,Ae=Le.positionY-ze.positionY;// Get direction of line connecting both node centers
// If both centers are the same, do nothing.
// A random force has already been applied as node repulsion
if(0==Oe&&0==Ae)return;// Get clipping points for both nodes
var je=fe(ze,Oe,Ae),Re=fe(Le,-1*Oe,-1*Ae),qe=Re.x-je.x,Ve=Re.y-je.y,Fe=Math.sqrt(qe*qe+Ve*Ve),Xe=Math.pow(Ie.idealLength-Fe,2)/Ie.elasticity;if(0!==Fe)var Ye=Xe*qe/Fe,We=Xe*Ve/Fe;else var Ye=0,We=0;// Add this force to target and source nodes
ze.isLocked||(ze.offsetX+=Ye,ze.offsetY+=We),Le.isLocked||(Le.offsetX-=Ye,Le.offsetY-=We)}},ve=function(Te,ke){// var s = 'calculateGravityForces';
// logDebug(s);
for(var Ie=0;Ie<Te.graphSet.length;Ie++){var Ne=Te.graphSet[Ie],ze=Ne.length;// s = "Set: " + graph.toString();
// logDebug(s);
// Compute graph center
if(0===Ie)var Be=Te.clientHeight/2,Le=Te.clientWidth/2;else// Get Parent node for this graph, and use its position as center
var Oe=Te.layoutNodes[Te.idToIndex[Ne[0]]],Ae=Te.layoutNodes[Te.idToIndex[Oe.parentId]],Be=Ae.positionX,Le=Ae.positionY;// s = "Center found at: " + centerX + ", " + centerY;
// logDebug(s);
// Apply force to all nodes in graph
for(var je=0;je<ze;je++){var Re=Te.layoutNodes[Te.idToIndex[Ne[je]]];// s = "Node: " + node.id;
if(!Re.isLocked){var qe=Be-Re.positionX,Ve=Le-Re.positionY,Fe=Math.sqrt(qe*qe+Ve*Ve);if(1<Fe){var Xe=ke.gravity*qe/Fe,Ye=ke.gravity*Ve/Fe;Re.offsetX+=Xe,Re.offsetY+=Ye}}}}},be=function(Te){// Inline implementation of a queue, used for traversing the graph in BFS order
var ke=[],Ie=0,Ne=-1;// Points to the start the queue
// Points to the end of the queue
// logDebug('propagateForces');
// Start by visiting the nodes in the root graph
// Traverse the graph, level by level,
for(ke.push.apply(ke,Te.graphSet[0]),Ne+=Te.graphSet[0].length;Ie<=Ne;){// Get the node to visit and remove it from queue
var ze=ke[Ie++],Be=Te.idToIndex[ze],Le=Te.layoutNodes[Be],Oe=Le.children;// We only need to process the node if it's compound
if(0<Oe.length&&!Le.isLocked){var Ae=Le.offsetX,je=Le.offsetY;// var s = "Propagating offset from parent node : " + node.id +
//   ". OffsetX: " + offX + ". OffsetY: " + offY;
// s += "\n Children: " + children.toString();
// logDebug(s);
for(var Re=0;Re<Oe.length;Re++){var qe=Te.layoutNodes[Te.idToIndex[Oe[Re]]];// Propagate offset
qe.offsetX+=Ae,qe.offsetY+=je,ke[++Ne]=Oe[Re]}// Reset parent offsets
Le.offsetX=0,Le.offsetY=0}}},we=function(Te){// var s = 'Updating positions';
// logDebug(s);
// Reset boundaries for compound nodes
for(var ke=0;ke<Te.nodeSize;ke++){var Ie=Te.layoutNodes[ke];0<Ie.children.length&&(Ie.maxX=void 0,Ie.minX=void 0,Ie.maxY=void 0,Ie.minY=void 0)}for(var ke=0;ke<Te.nodeSize;ke++){var Ie=Te.layoutNodes[ke];if(!(0<Ie.children.length||Ie.isLocked)){// s = "Node: " + n.id + " Previous position: (" +
// n.positionX + ", " + n.positionY + ").";
// Limit displacement in order to improve stability
var Ne=Ee(Ie.offsetX,Ie.offsetY,Te.temperature);Ie.positionX+=Ne.x,Ie.positionY+=Ne.y,Ie.offsetX=0,Ie.offsetY=0,Ie.minX=Ie.positionX-Ie.width,Ie.maxX=Ie.positionX+Ie.width,Ie.minY=Ie.positionY-Ie.height,Ie.maxY=Ie.positionY+Ie.height,Se(Ie,Te)}}// Update size, position of compund nodes
for(var ke=0;ke<Te.nodeSize;ke++){var Ie=Te.layoutNodes[ke];0<Ie.children.length&&!Ie.isLocked&&(Ie.positionX=(Ie.maxX+Ie.minX)/2,Ie.positionY=(Ie.maxY+Ie.minY)/2,Ie.width=Ie.maxX-Ie.minX,Ie.height=Ie.maxY-Ie.minY)}},Ee=function(Te,ke,Ie){// var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
var Ne=Math.sqrt(Te*Te+ke*ke);if(Ne>Ie)var ze={x:Ie*Te/Ne,y:Ie*ke/Ne};else var ze={x:Te,y:ke};// s += ".\nResult: (" + res.x + ", " + res.y + ")";
// logDebug(s);
return ze},Se=function(Te,ke){// var s = "Propagating new position/size of node " + node.id;
var Ie=Te.parentId;// s += ". No changes in boundaries/position of parent node " + p.id;
// logDebug(s);
if(null!=Ie){// Get Parent Node
var Ne=ke.layoutNodes[ke.idToIndex[Ie]],ze=!1;// MaxX
// If updated boundaries, propagate changes upward
if((null==Ne.maxX||Te.maxX+Ne.padRight>Ne.maxX)&&(Ne.maxX=Te.maxX+Ne.padRight,ze=!0),(null==Ne.minX||Te.minX-Ne.padLeft<Ne.minX)&&(Ne.minX=Te.minX-Ne.padLeft,ze=!0),(null==Ne.maxY||Te.maxY+Ne.padBottom>Ne.maxY)&&(Ne.maxY=Te.maxY+Ne.padBottom,ze=!0),(null==Ne.minY||Te.minY-Ne.padTop<Ne.minY)&&(Ne.minY=Te.minY-Ne.padTop,ze=!0),ze)// logDebug(s);
return Se(Ne,ke)}},_e=function(Te){// logDebug("New temperature: " + layoutInfo.temperature);
return ce(ue,ge,Te),ue.temperature=ue.temperature*ge.coolingFactor,!(ue.temperature<ge.minTemp)},Pe=0,Ce;/**
     * @brief          : Performs one iteration of the physical simulation
     * @arg layoutInfo : LayoutInfo object already initialized
     * @arg cy         : Cytoscape object
     * @arg options    : Layout options
     *//**
     * @brief : Computes the node repulsion forces
     *//**
     * @brief : Compute the node repulsion forces between a pair of nodes
     *//**
     * @brief  : Determines whether two nodes overlap or not
     * @return : Amount of overlapping (0 => no overlap)
     *//**
     * @brief : Finds the point in which an edge (direction dX, dY) intersects
     *          the rectangular bounding box of it's source/target node
     *//**
     * @brief : Calculates all edge forces
     *//**
     * @brief : Computes gravity forces for all nodes
     *//**
     * @brief          : This function propagates the existing offsets from
     *                   parent nodes to its descendents.
     * @arg layoutInfo : layoutInfo Object
     * @arg cy         : cytoscape Object
     * @arg options    : Layout options
     *//**
     * @brief : Updates the layout model positions, based on
     *          the accumulated forces
     *//**
     * @brief : Limits a force (forceX, forceY) to be not
     *          greater (in modulo) than max.
     8          Preserves force direction.
     *//**
     * @brief : Function used for keeping track of compound node
     *          sizes, since they should bound all their subnodes.
     */do{for(var De=0;De<ge.refresh&&Pe<ge.numIter;){var Ce=_e(Pe);if(!Ce)break;De++,Pe++}ge.animate&&broadcast(ue.layoutNodes)}while(Ce&&Pe+1<ge.numIter);return function(Te,ke){var Ie=ue.layoutNodes,Ne=[];for(var ze=0;ze<Ie.length;ze++){var Be=Ie[ze],Le=Be.cmptId,Oe=Ne[Le]=Ne[Le]||[];Oe.push(Be)}var Ae=0;for(var ze=0;ze<Ne.length;ze++){var je=Ne[ze];if(je){je.x1=1/0,je.x2=-(1/0),je.y1=1/0,je.y2=-(1/0);for(var Re=0;Re<je.length;Re++){var qe=je[Re];je.x1=Math.min(je.x1,qe.positionX-qe.width/2),je.x2=Math.max(je.x2,qe.positionX+qe.width/2),je.y1=Math.min(je.y1,qe.positionY-qe.height/2),je.y2=Math.max(je.y2,qe.positionY+qe.height/2)}je.w=je.x2-je.x1,je.h=je.y2-je.y1,Ae+=je.w*je.h}}Ne.sort(function(He,$e){return $e.w*$e.h-He.w*He.h});var Ve=0,Fe=0,Xe=0,Ye=0,We=Math.sqrt(Ae)*ue.clientWidth/ue.clientHeight;for(var ze=0;ze<Ne.length;ze++){var je=Ne[ze];if(je){for(var Re=0;Re<je.length;Re++){var qe=je[Re];qe.isLocked||(qe.positionX+=Ve,qe.positionY+=Fe)}Ve+=je.w+ke.componentSpacing,Xe+=je.w+ke.componentSpacing,Ye=Math.max(Ye,je.h),Xe>We&&(Fe+=Ye+ke.componentSpacing,Ve=0,Xe=0,Ye=0)}}}(ue,ge),ue}).then(function(pe){ne.layoutNodes=pe.layoutNodes,ae.stop(),le()});var le=function(){se({force:!0,next:function(){te.one("layoutstop",J.stop),te.trigger({type:"layoutstop",layout:te})}})};return this;// chaining
},D.prototype.stop=function(){return this.stopped=!0,this.thread&&this.thread.stop(),this.trigger("layoutstop"),this;// chaining
},D.prototype.destroy=function(){return this.thread&&this.thread.stop(),this;// chaining
};/**
 * @brief     : Creates an object which is contains all the data
 *              used in the layout process
 * @arg cy    : cytoscape.js object
 * @return    : layoutInfo object initialized
 */var $=function(J,ee,te){// Shortcut
var ae=te.eles.edges(),ne=te.eles.nodes(),re={isCompound:J.hasCompoundNodes(),layoutNodes:[],idToIndex:{},nodeSize:ne.size(),graphSet:[],indexToGraph:[],layoutEdges:[],edgeSize:ae.size(),temperature:te.initialTemp,clientWidth:J.width(),clientHeight:J.width(),boundingBox:I.makeBoundingBox(te.boundingBox?te.boundingBox:{x1:0,y1:0,w:J.width(),h:J.height()})},oe=te.eles.components(),se={};for(var le=0;le<oe.length;le++){var pe=oe[le];for(var ue=0;ue<pe.length;ue++){var ge=pe[ue];se[ge.id()]=le}}// Iterate over all nodes, creating layout nodes
for(var le=0;le<re.nodeSize;le++){var ce=ne[le],he=ce.boundingBox(),ye={};ye.isLocked=ce.locked(),ye.id=ce.data("id"),ye.parentId=ce.data("parent"),ye.cmptId=se[ce.id()],ye.children=[],ye.positionX=ce.position("x"),ye.positionY=ce.position("y"),ye.offsetX=0,ye.offsetY=0,ye.height=he.w,ye.width=he.h,ye.maxX=ye.positionX+ye.width/2,ye.minX=ye.positionX-ye.width/2,ye.maxY=ye.positionY+ye.height/2,ye.minY=ye.positionY-ye.height/2,ye.padLeft=parseFloat(ce.style("padding-left")),ye.padRight=parseFloat(ce.style("padding-right")),ye.padTop=parseFloat(ce.style("padding-top")),ye.padBottom=parseFloat(ce.style("padding-bottom")),ye.nodeRepulsion=O.fn(te.nodeRepulsion)?te.nodeRepulsion(ce):te.nodeRepulsion,re.layoutNodes.push(ye),re.idToIndex[ye.id]=le}// Inline implementation of a queue, used for traversing the graph in BFS order
var me=[],fe=0,xe=-1,ve=[];// Points to the start the queue
// Points to the end of the queue
// Second pass to add child information and
// initialize queue for hierarchical traversal
for(var le=0;le<re.nodeSize;le++){var ce=re.layoutNodes[le],be=ce.parentId;// Check if node n has a parent node
null==be?(me[++xe]=ce.id,ve.push(ce.id)):re.layoutNodes[re.idToIndex[be]].children.push(ce.id)}// Add root graph to graphSet
// Traverse the graph, level by level,
for(re.graphSet.push(ve);fe<=xe;){// Get the node to visit and remove it from queue
var we=me[fe++],Ee=re.idToIndex[we],ge=re.layoutNodes[Ee],Se=ge.children;if(0<Se.length){re.graphSet.push(Se);// Add children to que queue to be visited
for(var le=0;le<Se.length;le++)me[++xe]=Se[le]}}// Create indexToGraph map
for(var le=0;le<re.graphSet.length;le++){var _e=re.graphSet[le];for(var ue=0;ue<_e.length;ue++){var Pe=re.idToIndex[_e[ue]];re.indexToGraph[Pe]=le}}// Iterate over all edges, creating Layout Edges
for(var le=0;le<re.edgeSize;le++){var Ce=ae[le],De={};De.id=Ce.data("id"),De.sourceId=Ce.data("source"),De.targetId=Ce.data("target");// Compute ideal length
var Te=O.fn(te.idealEdgeLength)?te.idealEdgeLength(Ce):te.idealEdgeLength,ke=O.fn(te.edgeElasticity)?te.edgeElasticity(Ce):te.edgeElasticity,Ie=re.idToIndex[De.sourceId],Ne=re.idToIndex[De.targetId],ze=re.indexToGraph[Ie],Be=re.indexToGraph[Ne];// Check if it's an inter graph edge
if(ze!=Be){// Compute sum of node depths, relative to lca graph
// Source depth
for(// Find lowest common graph ancestor
var Le=M(De.sourceId,De.targetId,re),Oe=re.graphSet[Le],Ae=0,ye=re.layoutNodes[Ie];-1===Oe.indexOf(ye.id);)ye=re.layoutNodes[re.idToIndex[ye.parentId]],Ae++;// Target depth
for(ye=re.layoutNodes[Ne];-1===Oe.indexOf(ye.id);)ye=re.layoutNodes[re.idToIndex[ye.parentId]],Ae++;// logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
//  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
//  ". Depth: " + depth);
// Update idealLength
Te*=Ae*te.nestingFactor}De.idealLength=Te,De.elasticity=ke,re.layoutEdges.push(De)}// Finally, return layoutInfo object
return re},M=function(J,ee,te){// Find their common ancester, starting from the root graph
var ae=U(J,ee,0,te);return 2>ae.count?0:ae.graph},U=function(J,ee,te,ae){var ne=ae.graphSet[te];// If both nodes belongs to graphIx
if(-1<ne.indexOf(J)&&-1<ne.indexOf(ee))return{count:2,graph:te};// Make recursive calls for all subgraphs
var re=0;for(var oe=0;oe<ne.length;oe++){var se=ne[oe],le=ae.idToIndex[se],pe=ae.layoutNodes[le].children;// If the node has no child, skip it
if(0!==pe.length){var ue=ae.indexToGraph[ae.idToIndex[pe[0]]],ge=U(J,ee,ue,ae);if(0===ge.count)// Neither node1 nor node2 are present in this subgraph
continue;else{if(1!==ge.count)// Both nodes are present in this subgraph
return ge;if(re++,2==re)// We've already found both nodes, no need to keep searching
break}}}return{count:re,graph:te}},Z=function(J){/* eslint-disable */if(R){console.debug("layoutNodes:");for(var ee=0;ee<J.nodeSize;ee++){var te=J.layoutNodes[ee],ae="\nindex: "+ee+"\nId: "+te.id+"\nChildren: "+te.children.toString()+"\nparentId: "+te.parentId+"\npositionX: "+te.positionX+"\npositionY: "+te.positionY+"\nOffsetX: "+te.offsetX+"\nOffsetY: "+te.offsetY+"\npadLeft: "+te.padLeft+"\npadRight: "+te.padRight+"\npadTop: "+te.padTop+"\npadBottom: "+te.padBottom;console.debug(ae)}for(var ee in console.debug("idToIndex"),J.idToIndex)console.debug("Id: "+ee+"\nIndex: "+J.idToIndex[ee]);console.debug("Graph Set");var ne=J.graphSet;for(var ee=0;ee<ne.length;ee++)console.debug("Set : "+ee+": "+ne[ee].toString());var ae="IndexToGraph";for(var ee=0;ee<J.indexToGraph.length;ee++)ae+="\nIndex : "+ee+" Graph: "+J.indexToGraph[ee];console.debug(ae),ae="Layout Edges";for(var ee=0;ee<J.layoutEdges.length;ee++){var re=J.layoutEdges[ee];ae+="\nEdge Index: "+ee+" ID: "+re.id+" SouceID: "+re.sourceId+" TargetId: "+re.targetId+" Ideal Length: "+re.idealLength}console.debug(ae),ae="nodeSize: "+J.nodeSize,ae+="\nedgeSize: "+J.edgeSize,ae+="\ntemperature: "+J.temperature,console.debug(ae)}},G=function(J){var ee=J.clientWidth,te=J.clientHeight;for(var ae=0;ae<J.nodeSize;ae++){var ne=J.layoutNodes[ae];// No need to randomize compound nodes or locked nodes
0!==ne.children.length||ne.isLocked||(ne.positionX=Math.random()*ee,ne.positionY=Math.random()*te)}},K=function(J,ee,te){// var s = 'Refreshing positions';
// logDebug(s);
var ae=te.layout,ne=te.eles.nodes(),re=J.boundingBox,oe={x1:1/0,x2:-(1/0),y1:1/0,y2:-(1/0)};te.boundingBox&&(ne.forEach(function(se){var le=J.layoutNodes[J.idToIndex[se.data("id")]];oe.x1=Math.min(oe.x1,le.positionX),oe.x2=Math.max(oe.x2,le.positionX),oe.y1=Math.min(oe.y1,le.positionY),oe.y2=Math.max(oe.y2,le.positionY)}),oe.w=oe.x2-oe.x1,oe.h=oe.y2-oe.y1),ne.positions(function(se){var le=J.layoutNodes[J.idToIndex[se.data("id")]];// s = "Node: " + lnode.id + ". Refreshed position: (" +
// lnode.positionX + ", " + lnode.positionY + ").";
// logDebug(s);
if(te.boundingBox){// then add extra bounding box constraint
var pe=(le.positionX-oe.x1)/oe.w,ue=(le.positionY-oe.y1)/oe.h;return{x:re.x1+pe*re.w,y:re.y1+ue*re.h}}return{x:le.positionX,y:le.positionY}}),!0!==J.ready&&(J.ready=!0,ae.one("layoutready",te.ready),ae.trigger({type:"layoutready",layout:this}))};/**
 * @brief : This function finds the index of the lowest common
 *          graph ancestor between 2 nodes in the subtree
 *          (from the graph hierarchy induced tree) whose
 *          root is graphIx
 *
 * @arg node1: node1's ID
 * @arg node2: node2's ID
 * @arg layoutInfo: layoutInfo object
 *
 *//**
 * @brief          : Auxiliary function used for LCA computation
 *
 * @arg node1      : node1's ID
 * @arg node2      : node2's ID
 * @arg graphIx    : subgraph index
 * @arg layoutInfo : layoutInfo object
 *
 * @return         : object of the form {count: X, graph: Y}, where:
 *                   X is the number of ancesters (max: 2) found in
 *                   graphIx (and it's subgraphs),
 *                   Y is the graph index of the lowest graph containing
 *                   all X nodes
 *//**
 * @brief: printsLayoutInfo into js console
 *         Only used for debbuging
 *//**
 * @brief : Randomizes the position of all nodes
 *//**
 * @brief          : Updates the positions of nodes in the network
 * @arg layoutInfo : LayoutInfo object
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 *//**
 * @brief : Logs a debug message in JS console, if DEBUG is ON
 */// var logDebug = function(text) {
//   if (DEBUG) {
//     console.debug(text);
//   }
// };
_.exports=D},{"../../is":83,"../../math":84,"../../thread":97,"../../util":99}],52:[function(E,_){"use strict";function D(O){this.options=T.extend({},L,O)}var T=E("../../util"),I=E("../../math"),L={fit:!0,// whether to fit the viewport to the graph
padding:30,// padding used on fit
boundingBox:void 0,// constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
avoidOverlap:!0,// prevents node overlap, may overflow boundingBox if not enough space
avoidOverlapPadding:10,// extra spacing around nodes when avoidOverlap: true
condense:!1,// uses all available space on false, uses minimal space on true
rows:void 0,// force num of rows in the grid
cols:void 0,// force num of columns in the grid
position:function(){},// returns { row, col } for element
sort:void 0,// a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
animate:!1,// whether to transition the node positions
animationDuration:500,// duration of animation in ms if enabled
animationEasing:void 0,// easing of animation if enabled
ready:void 0,// callback on layoutready
stop:void 0// callback on layoutstop
};D.prototype.run=function(){var O=this.options,R=O,F=O.cy,$=R.eles,M=$.nodes().not(":parent");R.sort&&(M=M.sort(R.sort));var U=I.makeBoundingBox(R.boundingBox?R.boundingBox:{x1:0,y1:0,w:F.width(),h:F.height()});if(0===U.h||0===U.w)M.layoutPositions(this,R,function(){return{x:U.x1,y:U.y1}});else{// width/height * splits^2 = cells where splits is number of times to split width
var Z=M.size(),G=Math.sqrt(Z*U.h/U.w),K=Math.round(G),J=Math.round(U.w/U.h*G),ee=function(Ce){if(null==Ce)return Math.min(K,J);var De=Math.min(K,J);De==K?K=Ce:J=Ce},te=function(Ce){if(null==Ce)return Math.max(K,J);var De=Math.max(K,J);De==K?K=Ce:J=Ce},ae=R.rows,ne=null==R.cols?R.columns:R.cols;// if rows or columns were set in options, use those values
if(null!=ae&&null!=ne)K=ae,J=ne;else if(null!=ae&&null==ne)K=ae,J=Math.ceil(Z/K);else if(null==ae&&null!=ne)J=ne,K=Math.ceil(Z/J);// otherwise use the automatic values and adjust accordingly
// if rounding was up, see if we can reduce rows or columns
else if(J*K>Z){var re=ee(),oe=te();(re-1)*oe>=Z?ee(re-1):(oe-1)*re>=Z&&te(oe-1)}else// if rounding was too low, add rows or columns
for(;J*K<Z;){var re=ee(),oe=te();(oe+1)*re>=Z?te(oe+1):ee(re+1)}var se=U.w/J,le=U.h/K;if(R.condense&&(se=0,le=0),R.avoidOverlap)for(var pe=0;pe<M.length;pe++){var ue=M[pe],ge=ue._private.position;(null==ge.x||null==ge.y)&&(ge.x=0,ge.y=0);var ce=ue.boundingBox(),he=R.avoidOverlapPadding,ye=ce.w+he,me=ce.h+he;se=Math.max(se,ye),le=Math.max(le,me)}var fe={},xe=function(Ce,De){return!!fe["c-"+Ce+"-"+De]},ve=function(Ce,De){fe["c-"+Ce+"-"+De]=!0},be=0,we=0,Ee=function(){we++,we>=J&&(we=0,be++)},Se={};// e.g. 'c-0-2' => true
// to keep track of current cell position
// get a cache of all the manual positions
for(var pe=0;pe<M.length;pe++){var ue=M[pe],_e=R.position(ue);if(_e&&(void 0!==_e.row||void 0!==_e.col)){// must have at least row or col def'd
var ge={row:_e.row,col:_e.col};if(void 0===ge.col)for(ge.col=0;xe(ge.row,ge.col);)ge.col++;else if(void 0===ge.row)for(ge.row=0;xe(ge.row,ge.col);)ge.row++;Se[ue.id()]=ge,ve(ge.row,ge.col)}}var Pe=function(Ce){var De,Te;if(Ce.locked()||Ce.isParent())return!1;// see if we have a manual position set
var ke=Se[Ce.id()];if(ke)De=ke.col*se+se/2+U.x1,Te=ke.row*le+le/2+U.y1;else{// otherwise set automatically
for(;xe(be,we);)Ee();De=we*se+se/2+U.x1,Te=be*le+le/2+U.y1,ve(be,we),Ee()}return{x:De,y:Te}};M.layoutPositions(this,R,Pe)}return this;// chaining
},_.exports=D},{"../../math":84,"../../util":99}],53:[function(E,_){"use strict";_.exports=[{name:"breadthfirst",impl:E("./breadthfirst")},{name:"circle",impl:E("./circle")},{name:"concentric",impl:E("./concentric")},{name:"cose",impl:E("./cose")},{name:"grid",impl:E("./grid")},{name:"null",impl:E("./null")},{name:"preset",impl:E("./preset")},{name:"random",impl:E("./random")}]},{"./breadthfirst":48,"./circle":49,"./concentric":50,"./cose":51,"./grid":52,"./null":54,"./preset":55,"./random":56}],54:[function(E,_){"use strict";// constructor
// options : object containing layout options
function D(L){this.options=T.extend({},I,L)}// runs the layout
var T=E("../../util"),I={ready:function(){},// on layoutready
stop:function(){}// on layoutstop
};// default layout options
D.prototype.run=function(){var L=this.options,O=L.eles,R=this;// elements to consider in the layout
// cy is automatically populated for us in the constructor
return L.cy,R.trigger("layoutstart"),O.nodes().positions(function(){return{x:0,y:0}}),R.one("layoutready",L.ready),R.trigger("layoutready"),R.one("layoutstop",L.stop),R.trigger("layoutstop"),this;// chaining
},D.prototype.stop=function(){return this;// chaining
},_.exports=D},{"../../util":99}],55:[function(E,_){"use strict";function D(O){this.options=T.extend({},L,O)}var T=E("../../util"),I=E("../../is"),L={positions:void 0,// map of (node id) => (position obj); or function(node){ return somPos; }
zoom:void 0,// the zoom level to set (prob want fit = false if set)
pan:void 0,// the pan level to set (prob want fit = false if set)
fit:!0,// whether to fit to viewport
padding:30,// padding on fit
animate:!1,// whether to transition the node positions
animationDuration:500,// duration of animation in ms if enabled
animationEasing:void 0,// easing of animation if enabled
ready:void 0,// callback on layoutready
stop:void 0// callback on layoutstop
};D.prototype.run=function(){function O(U){if(null==R.positions)return null;if(M)return R.positions(U);var Z=R.positions[U._private.data.id];return null==Z?null:Z}var R=this.options,F=R.eles,$=F.nodes(),M=I.fn(R.positions);return $.layoutPositions(this,R,function(U){var Z=O(U);return U.locked()||null==Z?!1:Z}),this;// chaining
},_.exports=D},{"../../is":83,"../../util":99}],56:[function(E,_){"use strict";function D(O){this.options=T.extend({},L,O)}var T=E("../../util"),I=E("../../math"),L={fit:!0,// whether to fit to viewport
padding:30,// fit padding
boundingBox:void 0,// constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
animate:!1,// whether to transition the node positions
animationDuration:500,// duration of animation in ms if enabled
animationEasing:void 0,// easing of animation if enabled
ready:void 0,// callback on layoutready
stop:void 0// callback on layoutstop
};D.prototype.run=function(){var O=this.options,R=O.cy,F=O.eles,$=F.nodes().not(":parent"),M=I.makeBoundingBox(O.boundingBox?O.boundingBox:{x1:0,y1:0,w:R.width(),h:R.height()});return $.layoutPositions(this,O,function(){return{x:M.x1+Math.round(Math.random()*M.w),y:M.y1+Math.round(Math.random()*M.h)}}),this;// chaining
},_.exports=D},{"../../math":84,"../../util":99}],57:[function(E,_){"use strict";var D=E("../../../math"),T=E("../../../is"),I=E("../../../util"),L={};L.arrowShapeWidth=0.3,L.registerArrowShapes=function(){var O=this.arrowShapes={},R=this,F=function(G,K,J,ee,te,ae){var ne=te.x-J/2-ae,re=te.x+J/2+ae,oe=te.y-J/2-ae,se=te.y+J/2+ae;return ne<=G&&G<=re&&oe<=K&&K<=se},$=function(G,K,J,ee,te){var ae=G*Math.cos(ee)-K*Math.sin(ee),ne=G*Math.sin(ee)+K*Math.cos(ee),re=ae*J+te.x,oe=ne*J+te.y;return{x:re,y:oe}},M=function(G,K,J,ee){var te=[];for(var ae=0;ae<G.length;ae+=2){var ne=G[ae],re=G[ae+1];te.push($(ne,re,K,J,ee))}return te},U=function(G){var K=[];for(var J=0;J<G.length;J++){var ee=G[J];K.push(ee.x,ee.y)}return K},Z=function(G,K){T.string(K)&&(K=O[K]),O[G]=I.extend({name:G,points:[-0.15,-0.3,0.15,-0.3,0.15,0.3,-0.15,0.3],collide:function(J,ee,te,ae,ne,re){var oe=U(M(this.points,te+2*re,ae,ne)),se=D.pointInsidePolygonPoints(J,ee,oe);return se},roughCollide:F,draw:function(J,ee,te,ae){var ne=M(this.points,ee,te,ae);R.arrowShapeImpl("polygon")(J,ne)},spacing:function(){return 0},gap:function(J){return 2*J.pstyle("width").pfValue}},K)};// Contract for arrow shapes:
// 0, 0 is arrow tip
// (0, 1) is direction towards node
// (1, 0) is right
//
// functional api:
// collide: check x, y in shape
// roughCollide: called before collide, no false negatives
// draw: draw
// spacing: dist(arrowTip, nodeBoundary)
// gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip
Z("none",{collide:I.falsify,roughCollide:I.falsify,draw:I.noop,spacing:I.zeroify,gap:I.zeroify}),Z("triangle",{points:[-0.15,-0.3,0,0,0.15,-0.3]}),Z("arrow","triangle"),Z("triangle-backcurve",{points:O.triangle.points,controlPoint:[0,-0.15],roughCollide:F,draw:function(G,K,J,ee){var te=M(this.points,K,J,ee),ae=this.controlPoint,ne=$(ae[0],ae[1],K,J,ee);R.arrowShapeImpl(this.name)(G,te,ne)},gap:function(G){return G.pstyle("width").pfValue}}),Z("triangle-tee",{points:[-0.15,-0.3,0,0,0.15,-0.3,-0.15,-0.3],pointsTee:[-0.15,-0.4,-0.15,-0.5,0.15,-0.5,0.15,-0.4],collide:function(G,K,J,ee,te,ae){var ne=U(M(this.points,J+2*ae,ee,te)),re=U(M(this.pointsTee,J+2*ae,ee,te)),oe=D.pointInsidePolygonPoints(G,K,ne)||D.pointInsidePolygonPoints(G,K,re);return oe},draw:function(G,K,J,ee){var te=M(this.points,K,J,ee),ae=M(this.pointsTee,K,J,ee);R.arrowShapeImpl(this.name)(G,te,ae)}}),Z("vee",{points:[-0.15,-0.3,0,0,0.15,-0.3,0,-0.15],gap:function(G){return G.pstyle("width").pfValue}}),Z("circle",{radius:0.15,collide:function(G,K,J,ee,te,ae){var ne=te,re=Math.pow(ne.x-G,2)+Math.pow(ne.y-K,2)<=Math.pow((J+2*ae)*this.radius,2);return re},draw:function(G,K,J,ee){R.arrowShapeImpl(this.name)(G,ee.x,ee.y,this.radius*K)},spacing:function(G){return R.getArrowWidth(G.pstyle("width").pfValue)*this.radius}}),Z("inhibitor",{points:[-0.15,0,-0.15,-0.1,0.15,-0.1,0.15,0],spacing:function(){return 1},gap:function(){return 1}}),Z("tee","inhibitor"),Z("square",{points:[-0.15,0,0.15,0,0.15,-0.3,-0.15,-0.3]}),Z("diamond",{points:[-0.15,-0.15,0,-0.3,0.15,-0.15,0,0],gap:function(G){return G.pstyle("width").pfValue}})},_.exports=L},{"../../../is":83,"../../../math":84,"../../../util":99}],58:[function(E,_){"use strict";function D($,M,U){var Z=function(te,ae,ne,re){return T.qbezierAt(te,ae,ne,re)},G=M._private,K=G.rstyle.bezierPts;for(var J=0;J<$.bezierProjPcts.length;J++){var ee=$.bezierProjPcts[J];K.push({x:Z(U[0],U[2],U[4],ee),y:Z(U[1],U[3],U[5],ee)})}}var T=E("../../../math"),I=E("../../../is"),L=E("../../../util"),O=E("../../../collection/zsort"),R={};R.registerCalculationListeners=function(){var $=this.cy,M=$.collection(),U=this,Z=function(G,K){M.merge(G);for(var J=0;J<G.length;J++){var ee=G[J],te=ee._private,ae=te.rstyle;ae.clean=!1,te.bbCache=null;var ne=ae.dirtyEvents=ae.dirtyEvents||{length:0};ne[K.type]||(ne[K.type]=!0,ne.length++)}};U.binder($)// nodes
.on("position.* style.* free.*","node",function(K){var J=K.target;if(Z(J,K),Z(J.connectedEdges(),K),$.hasCompoundNodes()){var ee=J.parents();Z(ee,K),Z(ee.connectedEdges(),K)}}).on("add.* background.*","node",function(K){var J=K.target;Z(J,K)})// edges
.on("add.* style.*","edge",function(K){var J=K.target;Z(J,K),Z(J.parallelEdges(),K)}).on("remove.*","edge",function(K){var J=K.target,ee=J.parallelEdges();for(var te=0;te<ee.length;te++){var ae=ee[te];ae.removed()||Z(ae,K)}}),U.beforeRender(function(G){if(G){var K=U.onUpdateEleCalcsFns;if(K)for(var J=0;J<K.length;J++){var ee=K[J];ee(G,M)}U.recalculateRenderedStyle(M,!1);for(var J=0;J<M.length;J++)M[J]._private.rstyle.dirtyEvents=null;M=$.collection()}},U.beforeRenderPriorities.eleCalcs)},R.onUpdateEleCalcs=function($){var M=this.onUpdateEleCalcsFns=this.onUpdateEleCalcsFns||[];M.push($)},R.recalculateRenderedStyle=function($,M){var U=[],Z=[];// the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()
if(!this.destroyed){void 0===M&&(M=!0);for(var G=0;G<$.length;G++){var K=$[G],J=K._private,ee=J.rstyle;// only update if dirty and in graph
if(!(M&&ee.clean||K.removed())){if("nodes"===J.group){var te=J.position;Z.push(K),ee.nodeX=te.x,ee.nodeY=te.y,ee.nodeW=K.pstyle("width").pfValue,ee.nodeH=K.pstyle("height").pfValue}else U.push(K);// if edges
ee.clean=!0}}this.recalculateEdgeProjections(U),this.recalculateLabelProjections(Z,U);// update edge data from projections
for(var G=0;G<U.length;G++){var K=U[G],J=K._private,ee=J.rstyle,ae=J.rscratch;ee.srcX=ae.arrowStartX,ee.srcY=ae.arrowStartY,ee.tgtX=ae.arrowEndX,ee.tgtY=ae.arrowEndY,ee.midX=ae.midX,ee.midY=ae.midY,ee.labelAngle=ae.labelAngle,ee.sourceLabelAngle=ae.sourceLabelAngle,ee.targetLabelAngle=ae.targetLabelAngle}}// use cache by default for perf
},R.projectIntoViewport=function($,M){var U=this.findContainerClientCoords(),Z=U[0],G=U[1],K=$-Z,J=M-G;return K-=this.cy.pan().x,J-=this.cy.pan().y,K/=this.cy.zoom(),J/=this.cy.zoom(),[K,J]},R.findContainerClientCoords=function(){var $=this.container,M=this.containerBB=this.containerBB||$.getBoundingClientRect();return[M.left,M.top,M.right-M.left,M.bottom-M.top]},R.invalidateContainerClientCoordsCache=function(){this.containerBB=null},R.findNearestElement=function($,M,U,Z){return this.findNearestElements($,M,U,Z)[0]},R.findNearestElements=function($,M,U,Z){function G(xe,ve){if(xe.isNode()){if(ye)return;// can't replace node
ye=xe,oe.push(xe)}if(xe.isEdge()&&(null==ve||ve<ce))if(!he)oe.push(xe),he=xe,ce=null==ve?ce:ve;else// then replace existing edge
// can replace only if same z-index
if(he.pstyle("z-index").value===xe.pstyle("z-index").value)for(var be=0;be<oe.length;be++)if(oe[be].isEdge()){oe[be]=xe,he=xe,ce=null==ve?ce:ve;break}}function K(xe){var ve=xe._private,be=xe.outerWidth()+2*ue,we=xe.outerHeight()+2*ue,Ee=be/2,Se=we/2,_e=ve.position;if(_e.x-Ee<=$&&$<=_e.x+Ee// bb check x
&&_e.y-Se<=M&&M<=_e.y+Se// bb check y
){var Pe=ne.nodeShapes[ae.getNodeShape(xe)];Pe.checkPoint($,M,0,be,we,_e.x,_e.y)&&G(xe,0)}}function J(xe){var ve=xe._private,be=ve.rscratch,we=xe.pstyle("width").pfValue/2+pe,Ee=we*we,Se=2*we,_e=ve.source,Pe=ve.target,Ce=!1,De;// more like a distance radius from centre
if("segments"===be.edgeType||"straight"===be.edgeType||"haystack"===be.edgeType){var Te=be.allpts;for(var ke=0;ke+3<Te.length;ke+=2)(Ce=T.inLineVicinity($,M,Te[ke],Te[ke+1],Te[ke+2],Te[ke+3],Se))&&Ee>(De=T.sqdistToFiniteLine($,M,Te[ke],Te[ke+1],Te[ke+2],Te[ke+3]))&&G(xe,De)}else if("bezier"===be.edgeType||"multibezier"===be.edgeType||"self"===be.edgeType||"compound"===be.edgeType){var Te=be.allpts;for(var ke=0;ke+5<be.allpts.length;ke+=4)(Ce=T.inBezierVicinity($,M,Te[ke],Te[ke+1],Te[ke+2],Te[ke+3],Te[ke+4],Te[ke+5],Se))&&Ee>(De=T.sqdistToQuadraticBezier($,M,Te[ke],Te[ke+1],Te[ke+2],Te[ke+3],Te[ke+4],Te[ke+5]))&&G(xe,De)}// if we're close to the edge but didn't hit it, maybe we hit its arrows
if(Ce){var _e=_e||ve.source,Pe=Pe||ve.target,Ie=xe.pstyle("width").pfValue,Ne=ae.getArrowWidth(Ie),ze=[{name:"source",x:be.arrowStartX,y:be.arrowStartY,angle:be.srcArrowAngle},{name:"target",x:be.arrowEndX,y:be.arrowEndY,angle:be.tgtArrowAngle},{name:"mid-source",x:be.midX,y:be.midY,angle:be.midsrcArrowAngle},{name:"mid-target",x:be.midX,y:be.midY,angle:be.midtgtArrowAngle}];for(var ke=0;ke<ze.length;ke++){var Be=ze[ke],Le=ne.arrowShapes[xe.pstyle(Be.name+"-arrow-shape").value];if(Le.roughCollide($,M,Ne,Be.angle,{x:Be.x,y:Be.y},pe)&&Le.collide($,M,Ne,Be.angle,{x:Be.x,y:Be.y},pe)){G(xe);break}}}// for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
le&&0<oe.length&&(K(_e),K(Pe))}function ee(xe,ve,be){return L.getPrefixedProperty(xe,ve,be)}function te(xe,ve){var be=xe._private,we=ge,Ee;if(Ee=ve?ve+"-":"","no"!==xe.pstyle("text-events").strValue){var Se=xe.pstyle(Ee+"text-rotation");// adjust bb w/ angle
if("autorotate"===Se.strValue||!!Se.pfValue){var _e=be.rstyle,Pe=xe.pstyle("text-border-width").pfValue,Ce=ee(_e,"labelWidth",ve)+Pe/2+2*we,De=ee(_e,"labelHeight",ve)+Pe/2+2*we,Te=ee(_e,"labelX",ve),ke=ee(_e,"labelY",ve),Ie=ee(be.rscratch,"labelAngle",ve),Ne=Math.cos(Ie),ze=Math.sin(Ie),Be=function(We,He){return We=We-Te,He=He-ke,{x:We*Ne-He*ze+Te,y:We*ze+He*Ne+ke}},Le=Te-Ce/2,Oe=Te+Ce/2,Ae=ke-De/2,je=ke+De/2,Re=Be(Le,Ae),qe=Be(Le,je),Ve=Be(Oe,Ae),Fe=Be(Oe,je),Xe=[Re.x,Re.y,Ve.x,Ve.y,Fe.x,Fe.y,qe.x,qe.y];T.pointInsidePolygonPoints($,M,Xe)&&G(xe)}else{var Ye=xe.boundingBox({includeLabels:!0,includeNodes:!1,includeEdges:!1});// adjust bb w/ threshold
Ye.x1-=we,Ye.y1-=we,Ye.x2+=we,Ye.y2+=we,Ye.w=Ye.x2-Ye.x1,Ye.h=Ye.y2-Ye.y1,T.inBoundingBox(Ye,$,M)&&G(xe)}}}var ae=this,ne=this,re=ne.getCachedZSortedEles(),oe=[],se=ne.cy.zoom(),le=ne.cy.hasCompoundNodes(),pe=(Z?24:8)/se,ue=(Z?8:2)/se,ge=(Z?8:2)/se,ce=1/0,he,ye;// 1 node max, 1 edge max
U&&(re=re.interactive);for(var me=re.length-1;0<=me;me--){// reverse order for precedence
var fe=re[me];fe.isNode()?(K(fe),te(fe)):(J(fe),te(fe),te(fe,"source"),te(fe,"target"))}return oe},R.getAllInBox=function($,M,U,Z){var G=this.getCachedZSortedEles().interactive,K=[],J=Math.min($,U),ee=Math.max($,U),te=Math.min(M,Z),ae=Math.max(M,Z);$=J,U=ee,M=te,Z=ae;var ne=T.makeBoundingBox({x1:$,y1:M,x2:U,y2:Z});for(var re=0;re<G.length;re++){var oe=G[re];if(oe.isNode()){var se=oe,le=se.boundingBox({includeNodes:!0,includeEdges:!1,includeLabels:!1,includeShadows:!1});T.boundingBoxesIntersect(ne,le)&&K.push(se)}else{var pe=oe,ue=pe._private,ge=ue.rscratch;if(null!=ge.startX&&null!=ge.startY&&!T.inBoundingBox(ne,ge.startX,ge.startY))continue;if(null!=ge.endX&&null!=ge.endY&&!T.inBoundingBox(ne,ge.endX,ge.endY))continue;if("bezier"===ge.edgeType||"multibezier"===ge.edgeType||"self"===ge.edgeType||"compound"===ge.edgeType||"segments"===ge.edgeType||"haystack"===ge.edgeType){var ce=ue.rstyle.bezierPts||ue.rstyle.linePts||ue.rstyle.haystackPts,he=!0;for(var ye=0;ye<ce.length;ye++)if(!T.pointInBoundingBox(ne,ce[ye])){he=!1;break}he&&K.push(pe)}else("haystack"===ge.edgeType||"straight"===ge.edgeType)&&K.push(pe)}}return K},R.getNodeShape=function($){var M=this,U=$.pstyle("shape").value;if($.isParent()){if("rectangle"===U||"roundrectangle"===U)return U;return"rectangle"}if("polygon"===U){var Z=$.pstyle("shape-polygon-points").value;return M.nodeShapes.makePolygon(Z).name}return U},R.updateCachedZSortedEles=function(){this.getCachedZSortedEles(!0)},R.updateCachedGrabbedEles=function(){var $=this.cachedZSortedEles;$.drag=[],$.nondrag=[];var M;for(var U=0;U<$.length;U++){var Z=$[U],G=Z._private.rscratch;G.isGrabTarget&&!Z.isParent()?M=Z:G.inDragLayer?$.drag.push(Z):$.nondrag.push(Z)}// put the grab target node last so it's on top of its neighbourhood
M&&$.drag.push(M)},R.getCachedZSortedEles=function($){if($||!this.cachedZSortedEles){//console.time('cachezorder')
var M=this.cy.mutableElements().toArray();M.sort(O),M.interactive=M.filter(function(U){return U.interactive()}),this.cachedZSortedEles=M,this.updateCachedGrabbedEles()}else M=this.cachedZSortedEles;return M},R.projectLines=function($){var M=$._private,U=M.rscratch,Z=U.edgeType;// clear the cached points state
if(M.rstyle.bezierPts=null,M.rstyle.linePts=null,M.rstyle.haystackPts=null,"multibezier"===Z||"bezier"===Z||"self"===Z||"compound"===Z){M.rstyle.bezierPts=[];// jshint ignore:line
for(var G=0;G+5<U.allpts.length;G+=4)D(this,$,U.allpts.slice(G,G+6))}else if("segments"===Z){var K=M.rstyle.linePts=[];for(var G=0;G+1<U.allpts.length;G+=2)K.push({x:U.allpts[G],y:U.allpts[G+1]})}else if("haystack"===Z){var J=U.haystackPts;M.rstyle.haystackPts=[{x:J[0],y:J[1]},{x:J[2],y:J[3]}]}M.rstyle.arrowWidth=this.getArrowWidth($.pstyle("width").pfValue)*this.arrowShapeWidth},R.projectBezier=R.projectLines,R.recalculateNodeLabelProjection=function($){var M=$.pstyle("label").strValue;if(!I.emptyString(M)){var G=$._private,K=$.width(),J=$.height(),ee=$.pstyle("padding-left").pfValue,te=$.pstyle("padding-right").pfValue,ae=$.pstyle("padding-top").pfValue,ne=$.pstyle("padding-bottom").pfValue,re=G.position,oe=$.pstyle("text-halign").strValue,se=$.pstyle("text-valign").strValue,le=G.rscratch,pe=G.rstyle,U,Z;U="left"===oe?re.x-K/2-ee:"right"===oe?re.x+K/2+te:re.x,Z="top"===se?re.y-J/2-ae:"bottom"===se?re.y+J/2+ne:re.y,le.labelX=U,le.labelY=Z,pe.labelX=U,pe.labelY=Z,this.applyLabelDimensions($)}},R.recalculateEdgeLabelProjections=function($){var M,U=$._private,Z=U.rscratch,G=this,K={mid:$.pstyle("label").strValue,source:$.pstyle("source-label").strValue,target:$.pstyle("target-label").strValue};if(K.mid||K.source||K.target){M={x:Z.midX,y:Z.midY};var J=function(ae,ne,re){L.setPrefixedProperty(U.rscratch,ae,ne,re),L.setPrefixedProperty(U.rstyle,ae,ne,re)};J("labelX",null,M.x),J("labelY",null,M.y);var ee=function(){function ae(ye,me,fe,xe,ve){var be=T.dist(me,fe),we=ye.segments[ye.segments.length-1],Ee={p0:me,p1:fe,t0:xe,t1:ve,startDist:we?we.startDist+we.length:0,length:be};ye.segments.push(Ee),ye.length+=be}// update each ctrlpt with segment info
if(ee.cache)return ee.cache;// use cache so only 1x per edge
var ne=[];// store each ctrlpt info init
for(var re=0;re+5<Z.allpts.length;re+=4){var oe={x:Z.allpts[re],y:Z.allpts[re+1]},se={x:Z.allpts[re+2],y:Z.allpts[re+3]},le={x:Z.allpts[re+4],y:Z.allpts[re+5]};// ctrlpt
ne.push({p0:oe,p1:se,p2:le,startDist:0,length:0,segments:[]})}var pe=U.rstyle.bezierPts,ue=G.bezierProjPcts.length;for(var re=0;re<ne.length;re++){var ge=ne[re],ce=ne[re-1];ce&&(ge.startDist=ce.startDist+ce.length),ae(ge,ge.p0,pe[re*ue],0,G.bezierProjPcts[0]);// first
for(var he=0;he<ue-1;he++)ae(ge,pe[re*ue+he],pe[re*ue+he+1],G.bezierProjPcts[he],G.bezierProjPcts[he+1]);ae(ge,pe[re*ue+ue-1],ge.p2,G.bezierProjPcts[ue-1],1)}return ee.cache=ne},te=function(ae){var re="source"===ae,ne;if(K[ae]){var oe=$.pstyle(ae+"-text-offset").pfValue,se=function(ke,Ie){var Ne=Ie.x-ke.x,ze=Ie.y-ke.y;return Math.atan(ze/Ne)},le=function(ke,Ie,Ne,ze){var Be=T.bound(0,ze-0.001,1),Le=T.bound(0,ze+0.001,1),Oe=T.qbezierPtAt(ke,Ie,Ne,Be),Ae=T.qbezierPtAt(ke,Ie,Ne,Le);return se(Oe,Ae)};switch(Z.edgeType){case"self":case"compound":case"bezier":case"multibezier":var pe=ee(),ge=0,ce=0,ue;// find the segment we're on
for(var he=0;he<pe.length;he++){var ye=pe[re?he:pe.length-1-he];for(var me=0;me<ye.segments.length;me++){var fe=ye.segments[re?me:ye.segments.length-1-me],xe=he===pe.length-1&&me===ye.segments.length-1;if(ge=ce,ce+=fe.length,ce>=oe||xe){ue={cp:ye,segment:fe};break}}if(ue)break}var ye=ue.cp,fe=ue.segment,ve=(oe-ge)/fe.length,be=fe.t1-fe.t0,we=re?fe.t0+be*ve:fe.t1-be*ve;we=T.bound(0,we,1),M=T.qbezierPtAt(ye.p0,ye.p1,ye.p2,we),ne=le(ye.p0,ye.p1,ye.p2,we,M);break;case"straight":case"segments":case"haystack":var Ee=0,De=Z.allpts.length,Se,_e,Pe,Ce;for(var he=0;he+3<De&&(re?(Pe={x:Z.allpts[he],y:Z.allpts[he+1]},Ce={x:Z.allpts[he+2],y:Z.allpts[he+3]}):(Pe={x:Z.allpts[De-2-he],y:Z.allpts[De-1-he]},Ce={x:Z.allpts[De-4-he],y:Z.allpts[De-3-he]}),Se=T.dist(Pe,Ce),_e=Ee,Ee+=Se,!(Ee>=oe));he+=2);var Te=oe-_e,we=Te/Se;we=T.bound(0,we,1),M=T.lineAt(Pe,Ce,we),ne=se(Pe,Ce);}J("labelX",ae,M.x),J("labelY",ae,M.y),J("labelAutoAngle",ae,ne)}};te("source"),te("target"),this.applyLabelDimensions($)}// add center point to style so bounding box calculations can use it
//
},R.applyLabelDimensions=function($){this.applyPrefixedLabelDimensions($),$.isEdge()&&(this.applyPrefixedLabelDimensions($,"source"),this.applyPrefixedLabelDimensions($,"target"))},R.applyPrefixedLabelDimensions=function($,M){var U=$._private,Z=this.getLabelText($,M),G=this.calculateLabelDimensions($,Z);L.setPrefixedProperty(U.rstyle,"labelWidth",M,G.width),L.setPrefixedProperty(U.rscratch,"labelWidth",M,G.width),L.setPrefixedProperty(U.rstyle,"labelHeight",M,G.height),L.setPrefixedProperty(U.rscratch,"labelHeight",M,G.height)},R.getLabelText=function($,M){var U=$._private,Z=M?M+"-":"",G=$.pstyle(Z+"label").strValue,K=$.pstyle("text-transform").value,J=function(fe,xe){return xe?(L.setPrefixedProperty(U.rscratch,fe,M,xe),xe):L.getPrefixedProperty(U.rscratch,fe,M)};if("none"==K||("uppercase"==K?G=G.toUpperCase():"lowercase"==K&&(G=G.toLowerCase())),"wrap"===$.pstyle("text-wrap").value){//console.log('wrap');
var ee=J("labelKey");// save recalc if the label is the same as before
if(ee&&J("labelWrapKey")===ee)// console.log('wrap cache hit');
return J("labelWrapCachedText");// console.log('wrap cache miss');
var te=G.split("\n"),ae=$.pstyle("text-max-width").pfValue,ne=[];for(var re=0;re<te.length;re++){var oe=te[re],se=this.calculateLabelDimensions($,oe,"line="+oe),le=se.width;if(le>ae){// line is too long
var pe=oe.split(/\s+/),ue="";// NB: assume collapsed whitespace into single space
for(var ge=0;ge<pe.length;ge++){var ce=pe[ge],he=0===ue.length?ce:ue+" "+ce,ye=this.calculateLabelDimensions($,he,"testLine="+he),me=ye.width;me<=ae?ue+=ce+" ":(ne.push(ue),ue=ce+" ")}// if there's remaining text, put it in a wrapped line
ue.match(/^\s+$/)||ne.push(ue)}else ne.push(oe)}// for
J("labelWrapCachedLines",ne),G=J("labelWrapCachedText",ne.join("\n")),J("labelWrapKey",ee)}// if wrap
return G},R.calculateLabelDimensions=function($,M,U){var Z=this,G=$._private.labelStyleKey+"$@$"+M;U&&(G+="$@$"+U);var K=Z.labelDimCache||(Z.labelDimCache={});if(K[G])return K[G];var J=1,ee=$.pstyle("font-style").strValue,te=J*$.pstyle("font-size").pfValue+"px",ae=$.pstyle("font-family").strValue,ne=$.pstyle("font-weight").strValue,re=this.labelCalcDiv;// increase the scale to increase accuracy w.r.t. zoomed text
re||(re=this.labelCalcDiv=document.createElement("div"),document.body.appendChild(re));var oe=re.style;// from ele style
return oe.fontFamily=ae,oe.fontStyle=ee,oe.fontSize=te,oe.fontWeight=ne,oe.position="absolute",oe.left="-9999px",oe.top="-9999px",oe.zIndex="-1",oe.visibility="hidden",oe.pointerEvents="none",oe.padding="0",oe.lineHeight="1",oe.whiteSpace="wrap"===$.pstyle("text-wrap").value?"pre":"normal",re.textContent=M,K[G]={width:Math.ceil(re.clientWidth/J),height:Math.ceil(re.clientHeight/J)},K[G]},R.recalculateLabelProjections=function($,M){for(var U=0;U<$.length;U++)this.recalculateNodeLabelProjection($[U]);for(var U=0;U<M.length;U++)this.recalculateEdgeLabelProjections(M[U])},R.recalculateEdgeProjections=function($){this.findEdgeControlPoints($)},R.findEdgeControlPoints=function($){if($&&0!==$.length){var M=this,U=M.cy,Z=U.hasCompoundNodes(),G={},K=[],J=[],ee;// create a table of edge (src, tgt) => list of edges between them
for(var te=0;te<$.length;te++){var ae=$[te],ne=ae._private,re=ne.data,oe=ae.pstyle("curve-style").value,se="unbundled-bezier"===oe||"segments"===oe;// ignore edges who are not to be displayed
// they shouldn't take up space
if("none"!==ae.pstyle("display").value){if("haystack"===oe){J.push(ae);continue}var le=re.source,pe=re.target;ee=le>pe?pe+"$-$"+le:le+"$-$"+pe,se&&(ee="unbundled$-$"+re.id),null==G[ee]&&(G[ee]=[],K.push(ee)),G[ee].push(ae),se&&(G[ee].hasUnbundled=!0)}}var ue,ge,ce,he,ye,me,fe,xe,ve,be,we,Ee,Se,_e;// for each pair (src, tgt), create the ctrl pts
// Nested for loop is OK; total number of iterations for both loops = edgeCount
for(var Pe=0;Pe<K.length;Pe++){ee=K[Pe];var Ce=G[ee];// for each pair id, the edges should be sorted by index
// make sure src/tgt distinction is consistent for bundled edges
if(Ce.sort(function(ya,ma){return ya.poolIndex()-ma.poolIndex()}),ue=Ce[0]._private.source,ge=Ce[0]._private.target,!Ce.hasUnbundled&&ue.id()>ge.id()){var De=ue;ue=ge,ge=De}if(ce=ue._private,he=ge._private,ye=ce.position,me=he.position,fe=ue.outerWidth(),xe=ue.outerHeight(),ve=ge.outerWidth(),be=ge.outerHeight(),we=M.nodeShapes[this.getNodeShape(ue)],Ee=M.nodeShapes[this.getNodeShape(ge)],_e=!1,1<Ce.length&&ue!==ge||Ce.hasUnbundled){// pt outside src shape to calc distance/displacement from src to tgt
var Te=we.intersectLine(ye.x,ye.y,fe,xe,me.x,me.y,0),ke=Ee.intersectLine(me.x,me.y,ve,be,ye.x,ye.y,0),Ie={x1:Te[0],x2:ke[0],y1:Te[1],y2:ke[1]},Ne={x1:ye.x,x2:me.x,y1:ye.y,y2:me.y},ze=ke[1]-Te[1],Be=ke[0]-Te[0],Le=Math.sqrt(Be*Be+ze*ze),Oe={x:Be,y:ze},Ae={x:Oe.x/Le,y:Oe.y/Le};// pt outside tgt shape to calc distance/displacement from src to tgt
Se={x:-Ae.y,y:Ae.x},Ee.checkPoint(Te[0],Te[1],0,ve,be,me.x,me.y)&&we.checkPoint(ke[0],ke[1],0,fe,xe,ye.x,ye.y)&&(Se={},_e=!0)}var ae,je,Re;for(var te=0;te<Ce.length;te++){ae=Ce[te],je=ae._private,Re=je.rscratch;var qe=Re.lastEdgeIndex,Ve=te,Fe=Re.lastNumEdges,Xe=Ce.length,oe=ae.pstyle("curve-style").value,Ye=ae.pstyle("control-point-distances"),We=ae.pstyle("control-point-weights"),He=Ye&&We?Math.min(Ye.value.length,We.value.length):1,$e=ae.pstyle("control-point-step-size").pfValue,Me=Ye?Ye.pfValue[0]:void 0,Ue=We.value[0],se="unbundled-bezier"===oe||"segments"===oe,Ze=Re.lastSrcCtlPtX,Ge=ye.x,Ke=Re.lastSrcCtlPtY,Qe=ye.y,Je=Re.lastSrcCtlPtW,tt=ue.outerWidth(),at=Re.lastSrcCtlPtH,nt=ue.outerHeight(),it=Re.lastTgtCtlPtX,rt=me.x,ot=Re.lastTgtCtlPtY,st=me.y,lt=Re.lastTgtCtlPtW,ut=ge.outerWidth(),gt=Re.lastTgtCtlPtH,ct=ge.outerHeight(),ht=Re.lastW,yt=ae.pstyle("control-point-step-size").pfValue,ft=ae.pstyle("edge-distances").value;if(Re.badBezier=!!_e,Ze===Ge&&Ke===Qe&&Je===tt&&at===nt&&it===rt&&ot===st&&lt===ut&&gt===ct&&ht===yt&&(qe===Ve&&Fe===Xe||se))// console.log('edge ctrl pt cache HIT')
continue;// then the control points haven't changed and we can skip calculating them
else Re.lastSrcCtlPtX=Ge,Re.lastSrcCtlPtY=Qe,Re.lastSrcCtlPtW=tt,Re.lastSrcCtlPtH=nt,Re.lastTgtCtlPtX=rt,Re.lastTgtCtlPtY=st,Re.lastTgtCtlPtW=ut,Re.lastTgtCtlPtH=ct,Re.lastEdgeIndex=Ve,Re.lastNumEdges=Xe,Re.lastWidth=yt;if(ue===ge){Re.edgeType="self";var xt=te,vt=$e;se&&(xt=0,vt=Me),Re.ctrlpts=[ye.x,ye.y-(1+Math.pow(xe,1.12)/100)*vt*(xt/3+1),ye.x-(1+Math.pow(fe,1.12)/100)*vt*(xt/3+1),ye.y]}else if(Z&&(ue.isParent()||ue.isChild()||ge.isParent()||ge.isChild())&&(ue.parents().anySame(ge)||ge.parents().anySame(ue))){Re.edgeType="compound",Re.badBezier=!1;var xt=te,vt=$e;se&&(xt=0,vt=Me);var bt=50,wt={x:ye.x-fe/2,y:ye.y-xe/2},Et={x:me.x-ve/2,y:me.y-be/2},St={x:Math.min(wt.x,Et.x),y:Math.min(wt.y,Et.y)},_t=0.5,Pt=Math.max(_t,Math.log(0.01*fe)),Ct=Math.max(_t,Math.log(0.01*ve));// avoids cases with impossible beziers
Re.ctrlpts=[St.x,St.y-(1+Math.pow(bt,1.12)/100)*vt*(xt/3+1)*Pt,St.x-(1+Math.pow(bt,1.12)/100)*vt*(xt/3+1)*Ct,St.y]}else if("segments"===oe){Re.edgeType="segments",Re.segpts=[];var Dt=ae.pstyle("segment-weights").pfValue,Tt=ae.pstyle("segment-distances").pfValue,kt=Math.min(Dt.length,Tt.length);for(var It=0;It<kt;It++){var Nt=Dt[It],zt=Tt[It],Bt=1-Nt,Lt=Nt,Ot="node-position"===ft?Ne:Ie,At={x:Ot.x1*Bt+Ot.x2*Lt,y:Ot.y1*Bt+Ot.y2*Lt};Re.segpts.push(At.x+Se.x*zt,At.y+Se.y*zt)}// Straight edge
}else if(1==Ce.length%2&&te===Math.floor(Ce.length/2)&&!se)Re.edgeType="straight";else{// (Multi)bezier
var jt=se;Re.edgeType=jt?"multibezier":"bezier",Re.ctrlpts=[];for(var Rt=0;Rt<He;Rt++){var qt=(0.5-Ce.length/2+te)*$e,Ft=T.signum(qt),Vt;jt&&(Me=Ye?Ye.pfValue[Rt]:$e,Ue=We.value[Rt]),Vt=se?Me:void 0===Me?void 0:Ft*Me;var Xt=void 0==Vt?qt:Vt,Bt=1-Ue,Lt=Ue,Ot="node-position"===ft?Ne:Ie,At={x:Ot.x1*Bt+Ot.x2*Lt,y:Ot.y1*Bt+Ot.y2*Lt};Re.ctrlpts.push(At.x+Se.x*Xt,At.y+Se.y*Xt)}}// find endpts for edge
this.findEndpoints(ae);var Yt=!I.number(Re.startX)||!I.number(Re.startY),Wt=!I.number(Re.arrowStartX)||!I.number(Re.arrowStartY),Ht=!I.number(Re.endX)||!I.number(Re.endY),$t=!I.number(Re.arrowEndX)||!I.number(Re.arrowEndY),Mt=this.getArrowWidth(ae.pstyle("width").pfValue)*this.arrowShapeWidth,Ut=3*Mt;if("bezier"===Re.edgeType){var Zt=T.dist({x:Re.ctrlpts[0],y:Re.ctrlpts[1]},{x:Re.startX,y:Re.startY}),Gt=Zt<Ut,Kt=T.dist({x:Re.ctrlpts[0],y:Re.ctrlpts[1]},{x:Re.endX,y:Re.endY}),Qt=Kt<Ut,Jt=!1;if(Yt||Wt||Gt){Jt=!0;// project control point along line from src centre to outside the src shape
// (otherwise intersection will yield nothing)
var ea={// delta
x:Re.ctrlpts[0]-ye.x,y:Re.ctrlpts[1]-ye.y},ta=Math.sqrt(ea.x*ea.x+ea.y*ea.y),aa={// normalised delta
x:ea.x/ta,y:ea.y/ta},na=Math.max(fe,xe),ia={// *2 radius guarantees outside shape
x:Re.ctrlpts[0]+2*aa.x*na,y:Re.ctrlpts[1]+2*aa.y*na},ra=we.intersectLine(ye.x,ye.y,fe,xe,ia.x,ia.y,0);// length of line
Gt?(Re.ctrlpts[0]=Re.ctrlpts[0]+aa.x*(Ut-Zt),Re.ctrlpts[1]=Re.ctrlpts[1]+aa.y*(Ut-Zt)):(Re.ctrlpts[0]=ra[0]+aa.x*Ut,Re.ctrlpts[1]=ra[1]+aa.y*Ut)}if(Ht||$t||Qt){Jt=!0;// project control point along line from tgt centre to outside the tgt shape
// (otherwise intersection will yield nothing)
var ea={// delta
x:Re.ctrlpts[0]-me.x,y:Re.ctrlpts[1]-me.y},ta=Math.sqrt(ea.x*ea.x+ea.y*ea.y),aa={// normalised delta
x:ea.x/ta,y:ea.y/ta},na=Math.max(fe,xe),ia={// *2 radius guarantees outside shape
x:Re.ctrlpts[0]+2*aa.x*na,y:Re.ctrlpts[1]+2*aa.y*na},oa=Ee.intersectLine(me.x,me.y,ve,be,ia.x,ia.y,0);// length of line
Qt?(Re.ctrlpts[0]=Re.ctrlpts[0]+aa.x*(Ut-Kt),Re.ctrlpts[1]=Re.ctrlpts[1]+aa.y*(Ut-Kt)):(Re.ctrlpts[0]=oa[0]+aa.x*Ut,Re.ctrlpts[1]=oa[1]+aa.y*Ut)}Jt&&this.findEndpoints(ae)}if("multibezier"===Re.edgeType||"bezier"===Re.edgeType||"self"===Re.edgeType||"compound"===Re.edgeType){Re.allpts=[],Re.allpts.push(Re.startX,Re.startY);for(var Rt=0;Rt+1<Re.ctrlpts.length;Rt+=2)Re.allpts.push(Re.ctrlpts[Rt],Re.ctrlpts[Rt+1]),Rt+3<Re.ctrlpts.length&&Re.allpts.push((Re.ctrlpts[Rt]+Re.ctrlpts[Rt+2])/2,(Re.ctrlpts[Rt+1]+Re.ctrlpts[Rt+3])/2);Re.allpts.push(Re.endX,Re.endY);var sa,la;0==Re.ctrlpts.length/2%2?(sa=Re.allpts.length/2-1,Re.midX=Re.allpts[sa],Re.midY=Re.allpts[sa+1]):(sa=Re.allpts.length/2-3,la=0.5,Re.midX=T.qbezierAt(Re.allpts[sa],Re.allpts[sa+2],Re.allpts[sa+4],la),Re.midY=T.qbezierAt(Re.allpts[sa+1],Re.allpts[sa+3],Re.allpts[sa+5],la))}else if("straight"===Re.edgeType)Re.allpts=[Re.startX,Re.startY,Re.endX,Re.endY],Re.midX=(Re.startX+Re.endX+Re.arrowStartX+Re.arrowEndX)/4,Re.midY=(Re.startY+Re.endY+Re.arrowStartY+Re.arrowEndY)/4;else if("segments"===Re.edgeType)if(Re.allpts=[],Re.allpts.push(Re.startX,Re.startY),Re.allpts.push.apply(Re.allpts,Re.segpts),Re.allpts.push(Re.endX,Re.endY),0==Re.segpts.length%4){var da=Re.segpts.length/2,pa=da-2;Re.midX=(Re.segpts[pa]+Re.segpts[da])/2,Re.midY=(Re.segpts[pa+1]+Re.segpts[da+1])/2}else{var pa=Re.segpts.length/2-1;Re.midX=Re.segpts[pa],Re.midY=Re.segpts[pa+1]}this.projectLines(ae),this.calculateArrowAngles(ae),this.recalculateEdgeLabelProjections(ae),this.calculateLabelAngles(ae)}// for pair edges
}// for pair ids
for(var te=0;te<J.length;te++){var ae=J[te],ne=ae._private,ga=ne.rscratch,Re=ga;if(!ga.haystack){var ca=2*Math.random()*Math.PI;ga.source={x:Math.cos(ca),y:Math.sin(ca)};var ca=2*Math.random()*Math.PI;ga.target={x:Math.cos(ca),y:Math.sin(ca)}}var ue=ne.source,ge=ne.target,ye=ue._private.position,me=ge._private.position,fe=ue.width(),ve=ge.width(),xe=ue.height(),be=ge.height(),na=ae.pstyle("haystack-radius").value,ha=na/2;Re.haystackPts=Re.allpts=[Re.source.x*fe*ha+ye.x,Re.source.y*xe*ha+ye.y,Re.target.x*ve*ha+me.x,Re.target.y*be*ha+me.y],Re.midX=(Re.allpts[0]+Re.allpts[2])/2,Re.midY=(Re.allpts[1]+Re.allpts[3])/2,ga.edgeType="haystack",ga.haystack=!0,this.projectLines(ae),this.calculateArrowAngles(ae),this.recalculateEdgeLabelProjections(ae),this.calculateLabelAngles(ae)}return G}};var F=function($,M){return Math.atan2(M,$)-Math.PI/2};R.calculateArrowAngles=function($){var M=$._private.rscratch,U="haystack"===M.edgeType,Z="multibezier"===M.edgeType,G="segments"===M.edgeType,K="compound"===M.edgeType,J="self"===M.edgeType,se=$._private.source._private.position,le=$._private.target._private.position,ee,te,ae,ne,re,oe;// Displacement gives direction for arrowhead orientation
if(U?(ae=M.haystackPts[0],ne=M.haystackPts[1],re=M.haystackPts[2],oe=M.haystackPts[3]):(ae=M.arrowStartX,ne=M.arrowStartY,re=M.arrowEndX,oe=M.arrowEndY),ee=se.x-ae,te=se.y-ne,M.srcArrowAngle=F(ee,te),M.midX,M.midY,U,ee=re-ae,te=oe-ne,J)ee=-1,te=1;else if(G){var pe=M.allpts;if(0==pe.length/2%2){var ue=pe.length/2,ge=ue-2;ee=pe[ue]-pe[ge],te=pe[ue+1]-pe[ge+1]}else{var ue=pe.length/2-1,ge=ue-2,ce=ue+2;ee=pe[ue]-pe[ge],te=pe[ue+1]-pe[ge+1]}}else if(Z||K){var pe=M.allpts,he=M.ctrlpts,ye,me,fe,xe;if(0==he.length/2%2){var ve=pe.length/2-1,be=ve+2,we=be+2;// startpt
ye=T.qbezierAt(pe[ve],pe[be],pe[we],0),me=T.qbezierAt(pe[ve+1],pe[be+1],pe[we+1],0),fe=T.qbezierAt(pe[ve],pe[be],pe[we],0.0001),xe=T.qbezierAt(pe[ve+1],pe[be+1],pe[we+1],0.0001)}else{var be=pe.length/2-1,ve=be-2,we=be+2;// ctrpt
// startpt
ye=T.qbezierAt(pe[ve],pe[be],pe[we],0.4999),me=T.qbezierAt(pe[ve+1],pe[be+1],pe[we+1],0.4999),fe=T.qbezierAt(pe[ve],pe[be],pe[we],0.5),xe=T.qbezierAt(pe[ve+1],pe[be+1],pe[we+1],0.5)}ee=fe-ye,te=xe-me}if(M.midtgtArrowAngle=F(ee,te),M.midDispX=ee,M.midDispY=te,ee*=-1,te*=-1,G){var pe=M.allpts;if(0!=pe.length/2%2){var ue=pe.length/2-1,ce=ue+2;ee=-(pe[ce]-pe[ue]),te=-(pe[ce+1]-pe[ue+1])}}M.midsrcArrowAngle=F(ee,te),ee=le.x-re,te=le.y-oe,M.tgtArrowAngle=F(ee,te)},R.calculateLabelAngles=function($){var M=$._private,U=M.rscratch,Z=$.isEdge(),G=$.pstyle("text-rotation"),K=G.strValue;"none"===K?U.labelAngle=U.sourceLabelAngle=U.targetLabelAngle=0:Z&&"autorotate"===K?(U.labelAngle=Math.atan(U.midDispY/U.midDispX),U.sourceLabelAngle=U.sourceLabelAutoAngle,U.targetLabelAngle=U.targetLabelAutoAngle):"autorotate"===K?U.labelAngle=U.sourceLabelAngle=U.targetLabelAngle=0:U.labelAngle=U.sourceLabelAngle=U.targetLabelAngle=G.pfValue},R.findEndpoints=function($){var M=this,U,Z=$.source()[0],G=$.target()[0],K=Z._private,J=G._private,ee=K.position,te=J.position,ae=$.pstyle("target-arrow-shape").value,ne=$.pstyle("source-arrow-shape").value,re=$._private.rscratch,oe=re.edgeType,se="bezier"===oe||"multibezier"===oe||"self"===oe||"compound"===oe,le="bezier"!==oe,pe="straight"===oe||"segments"===oe,ue="segments"===oe,ge,ce;if(se){var he=[re.ctrlpts[0],re.ctrlpts[1]],ye=le?[re.ctrlpts[re.ctrlpts.length-2],re.ctrlpts[re.ctrlpts.length-1]]:he;ge=ye,ce=he}else if(pe){var me=ue?re.segpts.slice(0,2):[te.x,te.y],fe=ue?re.segpts.slice(re.segpts.length-2):[ee.x,ee.y];ge=fe,ce=me}U=M.nodeShapes[this.getNodeShape(G)].intersectLine(te.x,te.y,G.outerWidth(),G.outerHeight(),ge[0],ge[1],0);var xe=T.shortenIntersection(U,ge,M.arrowShapes[ae].spacing($)),ve=T.shortenIntersection(U,ge,M.arrowShapes[ae].gap($));re.endX=ve[0],re.endY=ve[1],re.arrowEndX=xe[0],re.arrowEndY=xe[1],U=M.nodeShapes[this.getNodeShape(Z)].intersectLine(ee.x,ee.y,Z.outerWidth(),Z.outerHeight(),ce[0],ce[1],0);var be=T.shortenIntersection(U,ce,M.arrowShapes[ne].spacing($)),we=T.shortenIntersection(U,ce,M.arrowShapes[ne].gap($));re.startX=we[0],re.startY=we[1],re.arrowStartX=be[0],re.arrowStartY=be[1],(se||le||pe)&&(I.number(re.startX)&&I.number(re.startY)&&I.number(re.endX)&&I.number(re.endY)?re.badLine=!1:re.badLine=!0)},R.getArrowWidth=R.getArrowHeight=function($){var M=this.arrowWidthCache=this.arrowWidthCache||{},U=M[$];return U?U:(U=Math.max(Math.pow(13.37*$,0.9),29),M[$]=U,U)},_.exports=R},{"../../../collection/zsort":32,"../../../is":83,"../../../math":84,"../../../util":99}],59:[function(E,_){"use strict";var D={};D.getCachedImage=function(T,I){var L=this,O=L.imageCache=L.imageCache||{},R=O[T];if(R)return R.image.complete||R.image.addEventListener("load",I),R.image;R=O[T]=O[T]||{};var F=R.image=new Image;// eslint-disable-line no-undef
F.addEventListener("load",I);// #1582 safari doesn't load data uris with crossOrigin properly
// https://bugs.webkit.org/show_bug.cgi?id=123978
var $="data:",M=T.substring(0,$.length).toLowerCase()===$;return M||(F.crossOrigin="Anonymous"),F.src=T,F},_.exports=D},{}],60:[function(E,_){"use strict";var D=E("../../../is"),T=E("../../../util"),I=function(O){this.init(O)},L=I.prototype;L.clientFunctions=["redrawHint","render","renderTo","matchCanvasSize","nodeShapeImpl","arrowShapeImpl"],L.init=function(O){var R=this;R.options=O,R.cy=O.cy,R.container=O.cy.container(),R.selection=[void 0,void 0,void 0,void 0,0],R.bezierProjPcts=[0.05,0.225,0.4,0.5,0.6,0.775,0.95],R.hoverData={down:null,last:null,downTime:null,triggerMode:null,dragging:!1,initialPan:[null,null],capture:!1},R.dragData={possibleDragElements:[]},R.touchData={start:null,capture:!1,// These 3 fields related to tap, taphold events
startPosition:[null,null,null,null,null,null],singleTouchStartTime:null,singleTouchMoved:!0,now:[null,null,null,null,null,null],earlier:[null,null,null,null,null,null]},R.redraws=0,R.showFps=O.showFps,R.hideEdgesOnViewport=O.hideEdgesOnViewport,R.hideLabelsOnViewport=O.hideLabelsOnViewport,R.textureOnViewport=O.textureOnViewport,R.wheelSensitivity=O.wheelSensitivity,R.motionBlurEnabled=O.motionBlur,R.forcedPixelRatio=O.pixelRatio,R.motionBlur=O.motionBlur,R.motionBlurOpacity=O.motionBlurOpacity,R.motionBlurTransparency=1-R.motionBlurOpacity,R.motionBlurPxRatio=1,R.mbPxRBlurry=1,R.minMbLowQualFrames=4,R.fullQualityMb=!1,R.clearedForMotionBlur=[],R.desktopTapThreshold=O.desktopTapThreshold,R.desktopTapThreshold2=O.desktopTapThreshold*O.desktopTapThreshold,R.touchTapThreshold=O.touchTapThreshold,R.touchTapThreshold2=O.touchTapThreshold*O.touchTapThreshold,R.tapholdDuration=500,R.bindings=[],R.beforeRenderCallbacks=[],R.beforeRenderPriorities={// higher priority execs before lower one
animations:400,eleCalcs:300,eleTxrDeq:200,lyrTxrDeq:100},R.registerNodeShapes(),R.registerArrowShapes(),R.registerCalculationListeners(),R.load()},L.notify=function(O){var R,F=this;// the renderer can't be notified after it's destroyed
if(!this.destroyed){R=D.array(O.type)?O.type:[O.type];var $={};for(var M=0;M<R.length;M++){var U=R[M];$[U]=!0}// for
return $.destroy?void F.destroy():void(($.add||$.remove||$.load||$.style)&&F.updateCachedZSortedEles(),$.viewport&&F.redrawHint("select",!0),($.load||$.resize)&&(F.invalidateContainerClientCoordsCache(),F.matchCanvasSize(F.container)),F.redrawHint("eles",!0),F.redrawHint("drag",!0),this.startRenderLoop(),this.redraw())}},L.destroy=function(){var O=this;O.destroyed=!0,O.cy.stopAnimationLoop();for(var R=0;R<O.bindings.length;R++){var F=O.bindings[R],$=F,M=$.target;(M.off||M.removeEventListener).apply(M,$.args)}if(O.bindings=[],O.beforeRenderCallbacks=[],O.onUpdateEleCalcsFns=[],O.removeObserver&&O.removeObserver.disconnect(),O.styleObserver&&O.styleObserver.disconnect(),O.labelCalcDiv)try{document.body.removeChild(O.labelCalcDiv)}catch(U){// ie10 issue #1014
}},[E("./arrow-shapes"),E("./coord-ele-math"),E("./images"),E("./load-listeners"),E("./node-shapes"),E("./redraw")].forEach(function(O){T.extend(L,O)}),_.exports=I},{"../../../is":83,"../../../util":99,"./arrow-shapes":57,"./coord-ele-math":58,"./images":59,"./load-listeners":61,"./node-shapes":62,"./redraw":63}],61:[function(E,_){"use strict";var D=E("../../../is"),T=E("../../../util"),I=E("../../../math"),L=E("../../../event"),O={};O.registerBinding=function(R){var F=Array.prototype.slice.apply(arguments,[1]),$=this.binder(R);// copy
return $.on.apply($,F)},O.binder=function(R){var F=this,$=function(){var M=arguments;return F.bindings.push({target:R,args:M}),(R.addEventListener||R.on).apply(R,M),this};return{on:$,addEventListener:$,addListener:$,bind:$}},O.nodeIsDraggable=function(R){return R&&R.isNode()&&!R.locked()&&R.grabbable()},O.nodeIsGrabbable=function(R){return this.nodeIsDraggable(R)&&R.interactive()},O.load=function(){var R=this,F=function(Fe,Xe,Ye,We){null==Fe&&(Fe=R.cy);for(var He=0;He<Xe.length;He++){var $e=Xe[He],Me=new L(Ye,T.extend({type:$e},We));Fe.trigger(Me)}},$=function(Fe){return Fe.shiftKey||Fe.metaKey||Fe.ctrlKey;// maybe e.altKey
},M=function(Fe,Xe){var Ye=!0;if(R.cy.hasCompoundNodes()&&Fe&&Fe.isEdge())// a compound node below the edge => no passthrough panning
for(var We=0;Xe&&We<Xe.length;We++){var Fe=Xe[We];if(Fe.isNode()&&Fe.isParent()){Ye=!1;break}}else Ye=!0;return Ye},U=function(Fe){var Xe;if(Fe.addToList&&R.cy.hasCompoundNodes()){// only needed for compound graphs
if(!Fe.addToList.hasId){Fe.addToList.hasId={};for(var Ye=0;Ye<Fe.addToList.length;Ye++){var We=Fe.addToList[Ye];Fe.addToList.hasId[We.id()]=!0}}Xe=Fe.addToList.hasId}return Xe||{}},Z=function(Fe){Fe[0]._private.grabbed=!0},G=function(Fe){Fe[0]._private.grabbed=!1},K=function(Fe){Fe[0]._private.rscratch.inDragLayer=!0},J=function(Fe){Fe[0]._private.rscratch.inDragLayer=!1},ee=function(Fe){Fe[0]._private.rscratch.isGrabTarget=!0},te=function(Fe){Fe[0]._private.rscratch.isGrabTarget=!1},ae=function(Fe,Xe){var Ye=U(Xe);Ye[Fe.id()]||(Xe.addToList.push(Fe),Ye[Fe.id()]=!0,Z(Fe))},ne=function(Fe,Xe){// nothing to do
if(Fe.cy().hasCompoundNodes()&&(null!=Xe.inDragLayer||null!=Xe.addToList)){var Ye=Fe.descendants();Xe.inDragLayer&&(Ye.forEach(K),Ye.connectedEdges().forEach(K)),Xe.addToList&&Ye.forEach(function(We){ae(We,Xe)})}},re=function(Fe,Xe){Xe=Xe||{};var Ye=Fe.cy().hasCompoundNodes();Xe.inDragLayer&&(Fe.forEach(K),Fe.neighborhood().stdFilter(function(We){return!Ye||We.isEdge()}).forEach(K)),Xe.addToList&&Fe.forEach(function(We){ae(We,Xe)}),ne(Fe,Xe),le(Fe,{inDragLayer:Xe.inDragLayer}),R.updateCachedGrabbedEles()},oe=re,se=function(Fe){Fe&&(Fe.hasId={},R.getCachedZSortedEles().forEach(function(Xe){G(Xe),J(Xe),te(Xe)}),R.updateCachedGrabbedEles())},le=function(Fe,Xe){// find top-level parent
// no parent node: no nodes to add to the drag layer
if((null!=Xe.inDragLayer||null!=Xe.addToList)&&Fe.cy().hasCompoundNodes()){var Ye=Fe.ancestors().orphans();if(!Ye.same(Fe)){var We=Ye.descendants().spawnSelf().merge(Ye).unmerge(Fe).unmerge(Fe.descendants()),He=We.connectedEdges();Xe.inDragLayer&&(He.forEach(K),We.forEach(K)),Xe.addToList&&We.forEach(function($e){ae($e,Xe)})}}// nothing to do
},pe="undefined"!=typeof MutationObserver;// helper function to determine which child nodes and inner edges
// of a compound node to be dragged as well as the grabbed and selected nodes
// adds the given nodes and its neighbourhood to the drag layer
// helper function to determine which ancestor nodes and edges should go
// to the drag layer (or should be removed from drag layer).
pe?(R.removeObserver=new MutationObserver(function(Fe){// eslint-disable-line no-undef
for(var Xe=0;Xe<Fe.length;Xe++){var Ye=Fe[Xe],We=Ye.removedNodes;if(We)for(var He=0;He<We.length;He++){var $e=We[He];if($e===R.container){R.destroy();break}}}}),R.container.parentNode&&R.removeObserver.observe(R.container.parentNode,{childList:!0})):R.registerBinding(R.container,"DOMNodeRemoved",function(){R.destroy()});var ue=T.debounce(function(){R.cy.invalidateSize(),R.invalidateContainerClientCoordsCache(),R.matchCanvasSize(R.container),R.redrawHint("eles",!0),R.redrawHint("drag",!0),R.redraw()},100);pe&&(R.styleObserver=new MutationObserver(ue),R.styleObserver.observe(R.container,{attributes:!0})),R.registerBinding(window,"resize",ue);for(// eslint-disable-line no-undef
var ge=function(Fe){R.registerBinding(Fe,"scroll",function(){R.invalidateContainerClientCoordsCache()})},ce=R.cy.container();;)if(ge(ce),ce.parentNode)ce=ce.parentNode;else break;// stop right click menu from appearing on cy
R.registerBinding(R.container,"contextmenu",function(Fe){Fe.preventDefault()});var he=function(){return 0!==R.selection[4]};// Primary key
R.registerBinding(R.container,"mousedown",function(Xe){Xe.preventDefault(),R.hoverData.capture=!0,R.hoverData.which=Xe.which;var Ye=R.cy,We=[Xe.clientX,Xe.clientY],He=R.projectIntoViewport(We[0],We[1]),$e=R.selection,Me=R.findNearestElements(He[0],He[1],!0,!1),Ue=Me[0],Ze=R.dragData.possibleDragElements;R.hoverData.mdownPos=He,R.hoverData.mdownGPos=We;var Ge=function(){R.hoverData.tapholdCancelled=!1,clearTimeout(R.hoverData.tapholdTimeout),R.hoverData.tapholdTimeout=setTimeout(function(){if(!R.hoverData.tapholdCancelled){var at=R.hoverData.down;at?at.trigger(new L(Xe,{type:"taphold",position:{x:He[0],y:He[1]}})):Ye.trigger(new L(Xe,{type:"taphold",position:{x:He[0],y:He[1]}}))}},R.tapholdDuration)};// Right click button
if(3==Xe.which){R.hoverData.cxtStarted=!0;var Ke=new L(Xe,{type:"cxttapstart",position:{x:He[0],y:He[1]}});Ue?(Ue.activate(),Ue.trigger(Ke),R.hoverData.down=Ue):Ye.trigger(Ke),R.hoverData.downTime=new Date().getTime(),R.hoverData.cxtDragged=!1}else if(1==Xe.which){Ue&&Ue.activate();// Element dragging
{// If something is under the cursor and it is draggable, prepare to grab it
if(null!=Ue&&R.nodeIsGrabbable(Ue)){var Qe=function(at){return new L(Xe,{type:at,position:{x:He[0],y:He[1]}})},Je=function(at){at.trigger(Qe("grab"))};if(ee(Ue),!Ue.selected())Ze=R.dragData.possibleDragElements=[],oe(Ue,{addToList:Ze}),Ue.trigger(Qe("grabon")).trigger(Qe("grab"));else{Ze=R.dragData.possibleDragElements=[];var tt=Ye.$(function(at){return at.isNode()&&at.selected()&&R.nodeIsGrabbable(at)});re(tt,{addToList:Ze}),Ue.trigger(Qe("grabon")),tt.forEach(Je)}R.redrawHint("eles",!0),R.redrawHint("drag",!0)}R.hoverData.down=Ue,R.hoverData.downs=Me,R.hoverData.downTime=new Date().getTime()}F(Ue,["mousedown","tapstart","vmousedown"],Xe,{position:{x:He[0],y:He[1]}}),null==Ue?($e[4]=1,R.data.bgActivePosistion={x:He[0],y:He[1]},R.redrawHint("select",!0),R.redraw()):Ue.isEdge()&&($e[4]=1),Ge()}// Initialize selection box coordinates
$e[0]=$e[2]=He[0],$e[1]=$e[3]=He[1]},!1),R.registerBinding(window,"mousemove",function(Xe){// eslint-disable-line no-undef
var Ye=!1,We=R.hoverData.capture;// save cycles if mouse events aren't to be captured
if(!We){var He=R.findContainerClientCoords();if(!(Xe.clientX>He[0]&&Xe.clientX<He[0]+R.canvasWidth&&Xe.clientY>He[1]&&Xe.clientY<He[1]+R.canvasHeight))return;for(var $e=R.container,Me=Xe.target,Ue=Me.parentNode,Ze=!1;Ue;){if(Ue===$e){Ze=!0;break}Ue=Ue.parentNode}if(!Ze)return;// if target is outisde cy container, then this event is not for us
}var Ge=R.cy,Ke=Ge.zoom(),Qe=[Xe.clientX,Xe.clientY],Je=R.projectIntoViewport(Qe[0],Qe[1]),tt=R.hoverData.mdownPos,at=R.hoverData.mdownGPos,nt=R.selection,it=null;R.hoverData.draggingEles||R.hoverData.dragging||R.hoverData.selecting||(it=R.findNearestElement(Je[0],Je[1],!0,!1));var rt=R.hoverData.last,ot=R.hoverData.down,st=[Je[0]-nt[2],Je[1]-nt[3]],lt=R.dragData.possibleDragElements,ut;if(at){var gt=Qe[0]-at[0],ct=Qe[1]-at[1];ut=gt*gt+ct*ct>=R.desktopTapThreshold2}var ht=$(Xe);ut&&(R.hoverData.tapholdCancelled=!0);var yt=function(){var kt=R.hoverData.dragDelta=R.hoverData.dragDelta||[];0===kt.length?(kt.push(st[0]),kt.push(st[1])):(kt[0]+=st[0],kt[1]+=st[1])};// trigger context drag if rmouse down
if(Ye=!0,F(it,["mousemove","vmousemove","tapdrag"],Xe,{position:{x:Je[0],y:Je[1]}}),3===R.hoverData.which){// but only if over threshold
if(ut){var ft=new L(Xe,{type:"cxtdrag",position:{x:Je[0],y:Je[1]}});ot?ot.trigger(ft):Ge.trigger(ft),R.hoverData.cxtDragged=!0,R.hoverData.cxtOver&&it===R.hoverData.cxtOver||(R.hoverData.cxtOver&&R.hoverData.cxtOver.trigger(new L(Xe,{type:"cxtdragout",position:{x:Je[0],y:Je[1]}})),R.hoverData.cxtOver=it,it&&it.trigger(new L(Xe,{type:"cxtdragover",position:{x:Je[0],y:Je[1]}})))}// Check if we are drag panning the entire graph
}else if(R.hoverData.dragging){if(Ye=!0,Ge.panningEnabled()&&Ge.userPanningEnabled()){var xt;if(R.hoverData.justStartedPan){var vt=R.hoverData.mdownPos;xt={x:(Je[0]-vt[0])*Ke,y:(Je[1]-vt[1])*Ke},R.hoverData.justStartedPan=!1}else xt={x:st[0]*Ke,y:st[1]*Ke};Ge.panBy(xt),R.hoverData.dragged=!0}// Needs reproject due to pan changing viewport
Je=R.projectIntoViewport(Xe.clientX,Xe.clientY)}else if(!(1==nt[4]&&(null==ot||ot.isEdge()))){if(ot&&ot.isEdge()&&ot.active()&&ot.unactivate(),ot&&ot.grabbed()||it==rt||(rt&&F(rt,["mouseout","tapdragout"],Xe,{position:{x:Je[0],y:Je[1]}}),it&&F(it,["mouseover","tapdragover"],Xe,{position:{x:Je[0],y:Je[1]}}),R.hoverData.last=it),ot&&R.nodeIsDraggable(ot))if(ut){// then drag
var wt=!R.dragData.didDrag;wt&&R.redrawHint("eles",!0),R.dragData.didDrag=!0;// indicate that we actually did drag the node
var Et=[];// now, add the elements to the drag layer if not done already
R.hoverData.draggingEles||re(Ge.collection(lt),{inDragLayer:!0});for(var St=0;St<lt.length;St++){var _t=lt[St];// Locked nodes not draggable, as well as non-visible nodes
if(R.nodeIsDraggable(_t)&&_t.grabbed()){var Pt=_t._private.position;if(Et.push(_t),D.number(st[0])&&D.number(st[1])){var Ct=!_t.isParent();if(Ct&&(Pt.x+=st[0],Pt.y+=st[1]),wt){var Dt=R.hoverData.dragDelta;Ct&&Dt&&D.number(Dt[0])&&D.number(Dt[1])&&(Pt.x+=Dt[0],Pt.y+=Dt[1])}}}}R.hoverData.draggingEles=!0;var Tt=Ge.collection(Et);Tt.updateCompoundBounds(),Tt.trigger("position drag"),R.redrawHint("drag",!0),R.redraw()}else yt();// prevent the dragging from triggering text selection on the page
Ye=!0}else if(ut){if(!R.hoverData.dragging&&Ge.boxSelectionEnabled()&&(ht||!Ge.panningEnabled()||!Ge.userPanningEnabled()))R.data.bgActivePosistion=void 0,R.hoverData.selecting||Ge.trigger("boxstart"),R.hoverData.selecting=!0,R.redrawHint("select",!0),R.redraw();else if(!R.hoverData.selecting&&Ge.panningEnabled()&&Ge.userPanningEnabled()){var bt=M(ot,R.hoverData.downs);bt&&(R.hoverData.dragging=!0,R.hoverData.justStartedPan=!0,nt[4]=0,R.data.bgActivePosistion=I.array2point(tt),R.redrawHint("select",!0),R.redraw())}ot&&ot.isEdge()&&ot.active()&&ot.unactivate()}return(nt[2]=Je[0],nt[3]=Je[1],Ye)?(Xe.stopPropagation&&Xe.stopPropagation(),Xe.preventDefault&&Xe.preventDefault(),!1):void 0},!1),R.registerBinding(window,"mouseup",function(Xe){// eslint-disable-line no-undef
var Ye=R.hoverData.capture;if(Ye){R.hoverData.capture=!1;var We=R.cy,He=R.projectIntoViewport(Xe.clientX,Xe.clientY),$e=R.selection,Me=R.findNearestElement(He[0],He[1],!0,!1),Ue=R.dragData.possibleDragElements,Ze=R.hoverData.down,Ge=$(Xe);if(R.data.bgActivePosistion&&(R.redrawHint("select",!0),R.redraw()),R.hoverData.tapholdCancelled=!0,R.data.bgActivePosistion=void 0,Ze&&Ze.unactivate(),3===R.hoverData.which){var Ke=new L(Xe,{type:"cxttapend",position:{x:He[0],y:He[1]}});if(Ze?Ze.trigger(Ke):We.trigger(Ke),!R.hoverData.cxtDragged){var Qe=new L(Xe,{type:"cxttap",position:{x:He[0],y:He[1]}});Ze?Ze.trigger(Qe):We.trigger(Qe)}R.hoverData.cxtDragged=!1,R.hoverData.which=null}else if(1===R.hoverData.which){if(null!=Ze||R.dragData.didDrag// didn't move the node around
||R.hoverData.selecting// not box selection
||R.hoverData.dragged// didn't pan
||$(Xe)||(We.$(function(nt){return nt.selected()}).unselect(),0<Ue.length&&R.redrawHint("eles",!0),R.dragData.possibleDragElements=Ue=[]),F(Me,["mouseup","tapend","vmouseup"],Xe,{position:{x:He[0],y:He[1]}}),R.dragData.didDrag||R.hoverData.dragged// didn't pan
||R.hoverData.selecting// not box selection
||F(Ze,["click","tap","vclick"],Xe,{position:{x:He[0],y:He[1]}}),Me!=Ze||R.dragData.didDrag||R.hoverData.selecting||null==Me||!Me._private.selectable||(R.hoverData.dragging||("additive"===We.selectionType()||Ge?Me.selected()?Me.unselect():Me.select():!Ge&&(We.$(":selected").unmerge(Me).unselect(),Me.select())),R.redrawHint("eles",!0)),R.hoverData.selecting){var Je=We.collection(R.getAllInBox($e[0],$e[1],$e[2],$e[3]));R.redrawHint("select",!0),0<Je.length&&R.redrawHint("eles",!0),We.trigger("boxend");var tt=function(nt){return nt.selectable()&&!nt.selected()};"additive"===We.selectionType()?Je.trigger("box").stdFilter(tt).select().trigger("boxselect"):(!Ge&&We.$(":selected").unmerge(Je).unselect(),Je.trigger("box").stdFilter(tt).select().trigger("boxselect")),R.redraw()}// Cancel drag pan
if(R.hoverData.dragging&&(R.hoverData.dragging=!1,R.redrawHint("select",!0),R.redrawHint("eles",!0),R.redraw()),!$e[4]){R.redrawHint("drag",!0),R.redrawHint("eles",!0);var at=Ze&&Ze.grabbed();se(Ue),at&&Ze.trigger("free")}}// else not right mouse
$e[4]=0,R.hoverData.down=null,R.hoverData.cxtStarted=!1,R.hoverData.draggingEles=!1,R.hoverData.selecting=!1,R.dragData.didDrag=!1,R.hoverData.dragged=!1,R.hoverData.dragDelta=[],R.hoverData.mdownPos=null,R.hoverData.mdownGPos=null}},!1),R.registerBinding(R.container,"wheel",function(Fe){if(!R.scrollingPage){// while scrolling, ignore wheel-to-zoom
var Xe=R.cy,Ye=R.projectIntoViewport(Fe.clientX,Fe.clientY),We=[Ye[0]*Xe.zoom()+Xe.pan().x,Ye[1]*Xe.zoom()+Xe.pan().y];if(R.hoverData.draggingEles||R.hoverData.dragging||R.hoverData.cxtStarted||he())return void Fe.preventDefault();if(Xe.panningEnabled()&&Xe.userPanningEnabled()&&Xe.zoomingEnabled()&&Xe.userZoomingEnabled()){Fe.preventDefault(),R.data.wheelZooming=!0,clearTimeout(R.data.wheelTimeout),R.data.wheelTimeout=setTimeout(function(){R.data.wheelZooming=!1,R.redrawHint("eles",!0),R.redraw()},150);var He=Fe.deltaY/-250||Fe.wheelDeltaY/1000||Fe.wheelDelta/1000;He=He*R.wheelSensitivity;var $e=1===Fe.deltaMode;$e&&(He*=33),Xe.zoom({level:Xe.zoom()*Math.pow(10,He),renderedPosition:{x:We[0],y:We[1]}})}}},!0),R.registerBinding(window,"scroll",function(){R.scrollingPage=!0,clearTimeout(R.scrollingPageTimeout),R.scrollingPageTimeout=setTimeout(function(){R.scrollingPage=!1},250)},!0),R.registerBinding(R.container,"mouseout",function(Xe){var Ye=R.projectIntoViewport(Xe.clientX,Xe.clientY);R.cy.trigger(new L(Xe,{type:"mouseout",position:{x:Ye[0],y:Ye[1]}}))},!1),R.registerBinding(R.container,"mouseover",function(Xe){var Ye=R.projectIntoViewport(Xe.clientX,Xe.clientY);R.cy.trigger(new L(Xe,{type:"mouseover",position:{x:Ye[0],y:Ye[1]}}))},!1);var Te=function(Fe,Xe,Ye,We){return Math.sqrt((Ye-Fe)*(Ye-Fe)+(We-Xe)*(We-Xe))},ke=function(Fe,Xe,Ye,We){return(Ye-Fe)*(Ye-Fe)+(We-Xe)*(We-Xe)},ye,me,fe,xe,ve,be,we,Ee,Se,_e,Pe,Ce,De,Ie;// starting points for pinch-to-zoom
// initial distance between finger 1 and finger 2 for pinch-to-zoom
// center point on start pinch to zoom
R.registerBinding(R.container,"touchstart",Ie=function(Fe){R.touchData.capture=!0,R.data.bgActivePosistion=void 0;var Xe=R.cy,Ye=R.touchData.now,We=R.touchData.earlier;if(Fe.touches[0]){var He=R.projectIntoViewport(Fe.touches[0].clientX,Fe.touches[0].clientY);Ye[0]=He[0],Ye[1]=He[1]}if(Fe.touches[1]){var He=R.projectIntoViewport(Fe.touches[1].clientX,Fe.touches[1].clientY);Ye[2]=He[0],Ye[3]=He[1]}if(Fe.touches[2]){var He=R.projectIntoViewport(Fe.touches[2].clientX,Fe.touches[2].clientY);Ye[4]=He[0],Ye[5]=He[1]}// record starting points for pinch-to-zoom
if(Fe.touches[1]){se(R.dragData.touchDragEles);var $e=R.findContainerClientCoords();Se=$e[0],_e=$e[1],Pe=$e[2],Ce=$e[3],ye=Fe.touches[0].clientX-Se,me=Fe.touches[0].clientY-_e,fe=Fe.touches[1].clientX-Se,xe=Fe.touches[1].clientY-_e,De=0<=ye&&ye<=Pe&&0<=fe&&fe<=Pe&&0<=me&&me<=Ce&&0<=xe&&xe<=Ce;var Me=Xe.pan(),Ue=Xe.zoom();ve=Te(ye,me,fe,xe),be=ke(ye,me,fe,xe),we=[(ye+fe)/2,(me+xe)/2],Ee=[(we[0]-Me.x)/Ue,(we[1]-Me.y)/Ue];// consider context tap
var Ze=200;if(be<Ze*Ze&&!Fe.touches[2]){var Ge=R.findNearestElement(Ye[0],Ye[1],!0,!0),Ke=R.findNearestElement(Ye[2],Ye[3],!0,!0);return Ge&&Ge.isNode()?(Ge.activate().trigger(new L(Fe,{type:"cxttapstart",position:{x:Ye[0],y:Ye[1]}})),R.touchData.start=Ge):Ke&&Ke.isNode()?(Ke.activate().trigger(new L(Fe,{type:"cxttapstart",position:{x:Ye[0],y:Ye[1]}})),R.touchData.start=Ke):(Xe.trigger(new L(Fe,{type:"cxttapstart",position:{x:Ye[0],y:Ye[1]}})),R.touchData.start=null),R.touchData.start&&(R.touchData.start._private.grabbed=!1),R.touchData.cxt=!0,R.touchData.cxtDragged=!1,R.data.bgActivePosistion=void 0,void R.redraw()}}if(Fe.touches[2]);else if(Fe.touches[1]);else if(Fe.touches[0]){var Qe=R.findNearestElements(Ye[0],Ye[1],!0,!0),Je=Qe[0];if(null!=Je&&(Je.activate(),R.touchData.start=Je,R.touchData.starts=Qe,R.nodeIsGrabbable(Je))){var tt=R.dragData.touchDragEles=[],at=null;R.redrawHint("eles",!0),R.redrawHint("drag",!0),Je.selected()?(at=Xe.$(function(rt){return rt.selected()&&R.nodeIsGrabbable(rt)}),re(at,{addToList:tt})):oe(Je,{addToList:tt}),ee(Je);var nt=function(rt){return new L(Fe,{type:rt,position:{x:Ye[0],y:Ye[1]}})};Je.trigger(nt("grabon")),at?at.forEach(function(rt){rt.trigger(nt("grab"))}):Je.trigger(nt("grab"))}F(Je,["touchstart","tapstart","vmousedown"],Fe,{position:{x:Ye[0],y:Ye[1]}}),null==Je&&(R.data.bgActivePosistion={x:He[0],y:He[1]},R.redrawHint("select",!0),R.redraw()),R.touchData.startPosition=[];for(var it=0;it<Ye.length;it++)We[it]=Ye[it],R.touchData.startPosition[it]=Ye[it];R.touchData.startGPosition=[Fe.touches[0].clientX,Fe.touches[0].clientY],R.touchData.singleTouchMoved=!1,R.touchData.singleTouchStartTime=+new Date,clearTimeout(R.touchData.tapholdTimeout),R.touchData.tapholdTimeout=setTimeout(function(){!1!==R.touchData.singleTouchMoved||R.pinching// if pinching, then taphold unselect shouldn't take effect
||R.touchData.selecting// box selection shouldn't allow taphold through
||(F(R.touchData.start,["taphold"],Fe,{position:{x:Ye[0],y:Ye[1]}}),!R.touchData.start&&Xe.$(":selected").unselect())},R.tapholdDuration)}},!1);var Ne;R.registerBinding(window,"touchmove",Ne=function(Fe){// eslint-disable-line no-undef
var Xe=R.selection,Ye=R.touchData.capture,We=R.cy,He=R.touchData.now,$e=R.touchData.earlier,Me=We.zoom();if(Fe.touches[0]){var Ue=R.projectIntoViewport(Fe.touches[0].clientX,Fe.touches[0].clientY);He[0]=Ue[0],He[1]=Ue[1]}if(Fe.touches[1]){var Ue=R.projectIntoViewport(Fe.touches[1].clientX,Fe.touches[1].clientY);He[2]=Ue[0],He[3]=Ue[1]}if(Fe.touches[2]){var Ue=R.projectIntoViewport(Fe.touches[2].clientX,Fe.touches[2].clientY);He[4]=Ue[0],He[5]=Ue[1]}var Ze;if(Ye&&Fe.touches[0]){var Ge=[];for(var Ke=0;Ke<He.length;Ke++)Ge[Ke]=He[Ke]-$e[Ke];var Qe=R.touchData.startGPosition,Je=Fe.touches[0].clientX-Qe[0],tt=Fe.touches[0].clientY-Qe[1];Ze=Je*Je+tt*tt>=R.touchTapThreshold2}// context swipe cancelling
if(Ye&&R.touchData.cxt){Fe.preventDefault();var at=Fe.touches[0].clientX-Se,nt=Fe.touches[0].clientY-_e,it=Fe.touches[1].clientX-Se,rt=Fe.touches[1].clientY-_e,ot=ke(at,nt,it,rt),st=ot/be,lt=150,ut=1.5;// var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
// cancel ctx gestures if the distance b/t the fingers increases
if(st>=ut*ut||ot>=lt*lt){R.touchData.cxt=!1,R.touchData.start&&(R.touchData.start.unactivate(),R.touchData.start=null),R.data.bgActivePosistion=void 0,R.redrawHint("select",!0);var gt=new L(Fe,{type:"cxttapend",position:{x:He[0],y:He[1]}});R.touchData.start?R.touchData.start.trigger(gt):We.trigger(gt)}}// context swipe
if(Ye&&R.touchData.cxt){var gt=new L(Fe,{type:"cxtdrag",position:{x:He[0],y:He[1]}});R.data.bgActivePosistion=void 0,R.redrawHint("select",!0),R.touchData.start?R.touchData.start.trigger(gt):We.trigger(gt),R.touchData.start&&(R.touchData.start._private.grabbed=!1),R.touchData.cxtDragged=!0;var ct=R.findNearestElement(He[0],He[1],!0,!0);R.touchData.cxtOver&&ct===R.touchData.cxtOver||(R.touchData.cxtOver&&R.touchData.cxtOver.trigger(new L(Fe,{type:"cxtdragout",position:{x:He[0],y:He[1]}})),R.touchData.cxtOver=ct,ct&&ct.trigger(new L(Fe,{type:"cxtdragover",position:{x:He[0],y:He[1]}})))}else if(Ye&&Fe.touches[2]&&We.boxSelectionEnabled())Fe.preventDefault(),R.data.bgActivePosistion=void 0,this.lastThreeTouch=+new Date,R.touchData.selecting||We.trigger("boxstart"),R.touchData.selecting=!0,R.redrawHint("select",!0),Xe&&0!==Xe.length&&void 0!==Xe[0]?(Xe[2]=(He[0]+He[2]+He[4])/3,Xe[3]=(He[1]+He[3]+He[5])/3):(Xe[0]=(He[0]+He[2]+He[4])/3,Xe[1]=(He[1]+He[3]+He[5])/3,Xe[2]=(He[0]+He[2]+He[4])/3+1,Xe[3]=(He[1]+He[3]+He[5])/3+1),Xe[4]=1,R.touchData.selecting=!0,R.redraw();else if(Ye&&Fe.touches[1]&&We.zoomingEnabled()&&We.panningEnabled()&&We.userZoomingEnabled()&&We.userPanningEnabled()){Fe.preventDefault(),R.data.bgActivePosistion=void 0,R.redrawHint("select",!0);var ht=R.dragData.touchDragEles;if(ht){R.redrawHint("drag",!0);for(var yt=0;yt<ht.length;yt++)ht[yt]._private.grabbed=!1,ht[yt]._private.rscratch.inDragLayer=!1}// (x2, y2) for fingers 1 and 2
var at=Fe.touches[0].clientX-Se,nt=Fe.touches[0].clientY-_e,it=Fe.touches[1].clientX-Se,rt=Fe.touches[1].clientY-_e,ft=Te(at,nt,it,rt),xt=ft/ve;// var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
// var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
if(1!=xt&&De){// delta finger1
var vt=at-ye,bt=nt-me,wt=it-fe,Et=rt-xe,St=We.zoom(),_t=St*xt,Pt=We.pan(),Ct=Ee[0]*St+Pt.x,Dt=Ee[1]*St+Pt.y,Tt={x:-_t/St*(Ct-Pt.x-(vt+wt)/2)+Ct,y:-_t/St*(Dt-Pt.y-(bt+Et)/2)+Dt};// delta finger 2
// adjust factor by the speed multiplier
// var speed = 1.5;
// if( factor > 1 ){
//   factor = (factor - 1) * speed + 1;
// } else {
//   factor = 1 - (1 - factor) * speed;
// }
// now calculate the zoom
// translation is the normalised vector of the two fingers movement
// i.e. so pinching cancels out and moving together pans
// the model center point converted to the current rendered pos
// remove dragged eles
if(R.touchData.start){var ht=R.dragData.touchDragEles;se(ht),R.redrawHint("drag",!0),R.redrawHint("eles",!0),R.touchData.start.trigger("free").unactivate()}We.viewport({zoom:_t,pan:Tt,cancelOnFailedZoom:!0}),ve=ft,ye=at,me=nt,fe=it,xe=rt,R.pinching=!0}// Re-project
if(Fe.touches[0]){var Ue=R.projectIntoViewport(Fe.touches[0].clientX,Fe.touches[0].clientY);He[0]=Ue[0],He[1]=Ue[1]}if(Fe.touches[1]){var Ue=R.projectIntoViewport(Fe.touches[1].clientX,Fe.touches[1].clientY);He[2]=Ue[0],He[3]=Ue[1]}if(Fe.touches[2]){var Ue=R.projectIntoViewport(Fe.touches[2].clientX,Fe.touches[2].clientY);He[4]=Ue[0],He[5]=Ue[1]}}else if(Fe.touches[0]){var kt=R.touchData.start,It=R.touchData.last,ct;// dragging nodes
if(R.hoverData.draggingEles||R.swipePanning||(ct=R.findNearestElement(He[0],He[1],!0,!0)),Ye&&null!=kt&&Fe.preventDefault(),Ye&&null!=kt&&R.nodeIsDraggable(kt))if(Ze){// then dragging can happen
var ht=R.dragData.touchDragEles,Nt=!R.dragData.didDrag;Nt&&re(We.collection(ht),{inDragLayer:!0});for(var zt=0;zt<ht.length;zt++){var Bt=ht[zt];if(R.nodeIsDraggable(Bt)&&Bt.grabbed()){R.dragData.didDrag=!0;var Lt=Bt._private.position,Ot=!Bt.isParent();if(Ot&&D.number(Ge[0])&&D.number(Ge[1])&&(Lt.x+=Ge[0],Lt.y+=Ge[1]),Nt){R.redrawHint("eles",!0);var At=R.touchData.dragDelta;Ot&&At&&D.number(At[0])&&D.number(At[1])&&(Lt.x+=At[0],Lt.y+=At[1])}}}var jt=We.collection(ht);jt.updateCompoundBounds(),jt.trigger("position drag"),R.hoverData.draggingEles=!0,R.redrawHint("drag",!0),R.touchData.startPosition[0]==$e[0]&&R.touchData.startPosition[1]==$e[1]&&R.redrawHint("eles",!0),R.redraw()}else{// otherise keep track of drag delta for later
var At=R.touchData.dragDelta=R.touchData.dragDelta||[];0===At.length?(At.push(Ge[0]),At.push(Ge[1])):(At[0]+=Ge[0],At[1]+=Ge[1])}// touchmove
// check to cancel taphold
if(F(kt||ct,["touchmove","tapdrag","vmousemove"],Fe,{position:{x:He[0],y:He[1]}}),kt&&kt.grabbed()||ct==It||(It&&It.trigger(new L(Fe,{type:"tapdragout",position:{x:He[0],y:He[1]}})),ct&&ct.trigger(new L(Fe,{type:"tapdragover",position:{x:He[0],y:He[1]}}))),R.touchData.last=ct,Ye)for(var yt=0;yt<He.length;yt++)He[yt]&&R.touchData.startPosition[yt]&&Ze&&(R.touchData.singleTouchMoved=!0);// panning
if(Ye&&(null==kt||kt.isEdge())&&We.panningEnabled()&&We.userPanningEnabled()){var Rt=M(kt,R.touchData.starts);Rt&&(Fe.preventDefault(),R.swipePanning?We.panBy({x:Ge[0]*Me,y:Ge[1]*Me}):Ze&&(R.swipePanning=!0,We.panBy({x:Je*Me,y:tt*Me}),kt&&(kt.unactivate(),!R.data.bgActivePosistion&&(R.data.bgActivePosistion=I.array2point(R.touchData.startPosition)),R.redrawHint("select",!0),R.touchData.start=null)));// Re-project
var Ue=R.projectIntoViewport(Fe.touches[0].clientX,Fe.touches[0].clientY);He[0]=Ue[0],He[1]=Ue[1]}}for(var Ke=0;Ke<He.length;Ke++)$e[Ke]=He[Ke];//r.redraw();
},!1);var ze;R.registerBinding(window,"touchcancel",ze=function(){// eslint-disable-line no-undef
var Fe=R.touchData.start;R.touchData.capture=!1,Fe&&Fe.unactivate()});var Be;// fallback compatibility layer for ms pointer events
if(R.registerBinding(window,"touchend",Be=function(Fe){// eslint-disable-line no-undef
var Xe=R.touchData.start,Ye=R.touchData.capture;if(Ye)R.touchData.capture=!1,Fe.preventDefault();else return;var We=R.selection;R.swipePanning=!1,R.hoverData.draggingEles=!1;var He=R.cy,$e=He.zoom(),Me=R.touchData.now,Ue=R.touchData.earlier;if(Fe.touches[0]){var Ze=R.projectIntoViewport(Fe.touches[0].clientX,Fe.touches[0].clientY);Me[0]=Ze[0],Me[1]=Ze[1]}if(Fe.touches[1]){var Ze=R.projectIntoViewport(Fe.touches[1].clientX,Fe.touches[1].clientY);Me[2]=Ze[0],Me[3]=Ze[1]}if(Fe.touches[2]){var Ze=R.projectIntoViewport(Fe.touches[2].clientX,Fe.touches[2].clientY);Me[4]=Ze[0],Me[5]=Ze[1]}Xe&&Xe.unactivate();var Ge;if(R.touchData.cxt){if(Ge=new L(Fe,{type:"cxttapend",position:{x:Me[0],y:Me[1]}}),Xe?Xe.trigger(Ge):He.trigger(Ge),!R.touchData.cxtDragged){var Ke=new L(Fe,{type:"cxttap",position:{x:Me[0],y:Me[1]}});Xe?Xe.trigger(Ke):He.trigger(Ke)}return R.touchData.start&&(R.touchData.start._private.grabbed=!1),R.touchData.cxt=!1,R.touchData.start=null,void R.redraw()}// no more box selection if we don't have three fingers
if(!Fe.touches[2]&&He.boxSelectionEnabled()&&R.touchData.selecting){R.touchData.selecting=!1;var Qe=He.collection(R.getAllInBox(We[0],We[1],We[2],We[3]));We[0]=void 0,We[1]=void 0,We[2]=void 0,We[3]=void 0,We[4]=0,R.redrawHint("select",!0),He.trigger("boxend");var Je=function(st){return st.selectable()&&!st.selected()};Qe.trigger("box").stdFilter(Je).select().trigger("boxselect"),Qe.nonempty()&&R.redrawHint("eles",!0),R.redraw()}if(null!=Xe&&Xe.unactivate(),Fe.touches[2])R.data.bgActivePosistion=void 0,R.redrawHint("select",!0);else if(Fe.touches[1]);else if(Fe.touches[0]);else if(!Fe.touches[0]){R.data.bgActivePosistion=void 0,R.redrawHint("select",!0);var tt=R.dragData.touchDragEles;if(null!=Xe){var at=Xe._private.grabbed;se(tt),R.redrawHint("drag",!0),R.redrawHint("eles",!0),at&&Xe.trigger("free"),F(Xe,["touchend","tapend","vmouseup","tapdragout"],Fe,{position:{x:Me[0],y:Me[1]}}),Xe.unactivate(),R.touchData.start=null}else{var nt=R.findNearestElement(Me[0],Me[1],!0,!0);F(nt,["touchend","tapend","vmouseup","tapdragout"],Fe,{position:{x:Me[0],y:Me[1]}})}var it=R.touchData.startPosition[0]-Me[0],rt=R.touchData.startPosition[1]-Me[1];null!=Xe&&!R.dragData.didDrag// didn't drag nodes around
&&Xe._private.selectable&&(it*it+rt*rt)*$e*$e<R.touchTapThreshold2&&!R.pinching// pinch to zoom should not affect selection
&&("single"===He.selectionType()?(He.$(":selected").unmerge(Xe).unselect(),Xe.select()):Xe.selected()?Xe.unselect():Xe.select(),R.redrawHint("eles",!0)),R.touchData.singleTouchMoved||F(Xe,["tap","vclick"],Fe,{position:{x:Me[0],y:Me[1]}}),R.touchData.singleTouchMoved=!0}for(var ot=0;ot<Me.length;ot++)Ue[ot]=Me[ot];R.dragData.didDrag=!1,0===Fe.touches.length&&(R.touchData.dragDelta=[],R.touchData.startPosition=null,R.touchData.startGPosition=null),2>Fe.touches.length&&(R.pinching=!1,R.redrawHint("eles",!0),R.redraw())},!1),"undefined"==typeof TouchEvent){var Le=[],Oe=function(Fe){return{clientX:Fe.clientX,clientY:Fe.clientY,force:1,identifier:Fe.pointerId,pageX:Fe.pageX,pageY:Fe.pageY,radiusX:Fe.width/2,radiusY:Fe.height/2,screenX:Fe.screenX,screenY:Fe.screenY,target:Fe.target}},Ae=function(Fe){return{event:Fe,touch:Oe(Fe)}},je=function(Fe){Le.push(Ae(Fe))},Re=function(Fe){for(var Xe=0;Xe<Le.length;Xe++){var Ye=Le[Xe];Ye.event.pointerId===Fe.pointerId&&Le.splice(Xe,1)}},qe=function(Fe){var Xe=Le.filter(function(Ye){return Ye.event.pointerId===Fe.pointerId})[0];Xe.event=Fe,Xe.touch=Oe(Fe)},Ve=function(Fe){Fe.touches=Le.map(function(Xe){return Xe.touch})};R.registerBinding(R.container,"pointerdown",function(Fe){"mouse"===Fe.pointerType||(Fe.preventDefault(),je(Fe),Ve(Fe),Ie(Fe))}),R.registerBinding(R.container,"pointerup",function(Fe){"mouse"===Fe.pointerType||(Re(Fe),Ve(Fe),Be(Fe))}),R.registerBinding(R.container,"pointercancel",function(Fe){"mouse"===Fe.pointerType||(Re(Fe),Ve(Fe),ze(Fe))}),R.registerBinding(R.container,"pointermove",function(Fe){"mouse"===Fe.pointerType||(Fe.preventDefault(),qe(Fe),Ve(Fe),Ne(Fe))})}},_.exports=O},{"../../../event":45,"../../../is":83,"../../../math":84,"../../../util":99}],62:[function(E,_){"use strict";var D=E("../../../math"),T={};T.generatePolygon=function(I,L){return this.nodeShapes[I]={renderer:this,name:I,points:L,draw:function(O,R,F,$,M){this.renderer.nodeShapeImpl("polygon",O,R,F,$,M,this.points)},intersectLine:function(O,R,F,$,M,U,Z){return D.polygonIntersectLine(M,U,this.points,O,R,F/2,$/2,Z)},checkPoint:function(O,R,F,$,M,U,Z){return D.pointInsidePolygon(O,R,this.points,U,Z,$,M,[0,-1],F)}}},T.generateEllipse=function(){return this.nodeShapes.ellipse={renderer:this,name:"ellipse",draw:function(I,L,O,R,F){this.renderer.nodeShapeImpl(this.name,I,L,O,R,F)},intersectLine:function(I,L,O,R,F,$,M){return D.intersectLineEllipse(F,$,I,L,O/2+M,R/2+M)},checkPoint:function(I,L,O,R,F,$,M){return I-=$,L-=M,I/=R/2+O,L/=F/2+O,1>=I*I+L*L}}},T.generateRoundRectangle=function(){return this.nodeShapes.roundrectangle={renderer:this,name:"roundrectangle",points:D.generateUnitNgonPointsFitToSquare(4,0),draw:function(I,L,O,R,F){this.renderer.nodeShapeImpl(this.name,I,L,O,R,F)},intersectLine:function(I,L,O,R,F,$,M){return D.roundRectangleIntersectLine(F,$,I,L,O,R,M)},// Looks like the width passed into this function is actually the total width / 2
checkPoint:function(I,L,O,R,F,$,M){var U=D.getRoundRectangleRadius(R,F);// Check hBox
if(D.pointInsidePolygon(I,L,this.points,$,M,R,F-2*U,[0,-1],O))return!0;// Check vBox
if(D.pointInsidePolygon(I,L,this.points,$,M,R-2*U,F,[0,-1],O))return!0;var Z=function(G,K,J,ee,te,ae,ne){return G-=J,K-=ee,G/=te/2+ne,K/=ae/2+ne,1>=G*G+K*K};// Check top left quarter circle
// Check bottom right quarter circle
return!!Z(I,L,$-R/2+U,M-F/2+U,2*U,2*U,O)||!!Z(I,L,$+R/2-U,M-F/2+U,2*U,2*U,O)||!!Z(I,L,$+R/2-U,M+F/2-U,2*U,2*U,O)||!!Z(I,L,$-R/2+U,M+F/2-U,2*U,2*U,O);// Check top right quarter circle
// Check bottom left quarter circle
}}},T.registerNodeShapes=function(){var I=this.nodeShapes={},L=this;this.generateEllipse(),this.generatePolygon("triangle",D.generateUnitNgonPointsFitToSquare(3,0)),this.generatePolygon("rectangle",D.generateUnitNgonPointsFitToSquare(4,0)),I.square=I.rectangle,this.generateRoundRectangle(),this.generatePolygon("diamond",[0,1,1,0,0,-1,-1,0]),this.generatePolygon("pentagon",D.generateUnitNgonPointsFitToSquare(5,0)),this.generatePolygon("hexagon",D.generateUnitNgonPointsFitToSquare(6,0)),this.generatePolygon("heptagon",D.generateUnitNgonPointsFitToSquare(7,0)),this.generatePolygon("octagon",D.generateUnitNgonPointsFitToSquare(8,0));var O=Array(20);{var R=D.generateUnitNgonPoints(5,0),F=D.generateUnitNgonPoints(5,Math.PI/5),$=0.5*(3-Math.sqrt(5));// Outer radius is 1; inner radius of star is smaller
$*=1.57;for(var M=0;M<F.length/2;M++)F[2*M]*=$,F[2*M+1]*=$;for(var M=0;M<5;M++)O[4*M]=R[2*M],O[4*M+1]=R[2*M+1],O[4*M+2]=F[2*M],O[4*M+3]=F[2*M+1]}O=D.fitPolygonToSquare(O),this.generatePolygon("star",O),this.generatePolygon("vee",[-1,-1,0,-0.333,1,-1,0,1]),this.generatePolygon("rhomboid",[-1,-1,0.333,-1,1,1,-0.333,1]),I.makePolygon=function(U){// use caching on user-specified polygons so they are as fast as native shapes
var Z=U.join("$"),G="polygon-"+Z,K;return(K=this[G])?K:L.generatePolygon(G,U);// create and cache new shape
}},_.exports=T},{"../../../math":84}],63:[function(E,_){"use strict";var D=E("../../../util"),T={};T.timeToRender=function(){return this.redrawTotalTime/this.redrawCount},T.redraw=function(L){L=L||D.staticEmptyObject();var O=this;O.averageRedrawTime===void 0&&(O.averageRedrawTime=0),O.lastRedrawTime===void 0&&(O.lastRedrawTime=0),O.lastDrawTime===void 0&&(O.lastDrawTime=0),O.requestedFrame=!0,O.renderOptions=L},T.beforeRender=function(L,O){// the renderer can't add tick callbacks when destroyed
if(!this.destroyed){O=O||0;var R=this.beforeRenderCallbacks;R.push({fn:L,priority:O}),R.sort(function(F,$){return $.priority-F.priority})}};var I=function(L,O,R){var F=L.beforeRenderCallbacks;for(var $=0;$<F.length;$++)F[$].fn(O,R)};T.startRenderLoop=function(){var L=this;if(!L.renderLoopStarted){L.renderLoopStarted=!0;var O=function(R){if(!L.destroyed){if(L.requestedFrame&&!L.skipFrame){I(L,!0,R);var F=D.performanceNow();L.render(L.renderOptions);var $=L.lastDrawTime=D.performanceNow();void 0===L.averageRedrawTime&&(L.averageRedrawTime=$-F),void 0===L.redrawCount&&(L.redrawCount=0),L.redrawCount++,void 0===L.redrawTotalTime&&(L.redrawTotalTime=0);var M=$-F;L.redrawTotalTime+=M,L.lastRedrawTime=M,L.averageRedrawTime=L.averageRedrawTime/2+M/2,L.requestedFrame=!1}else I(L,!1,R);L.skipFrame=!1,D.requestAnimationFrame(O)}};D.requestAnimationFrame(O)}},_.exports=T},{"../../../util":99}],64:[function(E,_){"use strict";var D={},T;D.arrowShapeImpl=function(I){return(T||(T={polygon:function(L,O){for(var R=0;R<O.length;R++){var F=O[R];L.lineTo(F.x,F.y)}},"triangle-backcurve":function(L,O,R){var F;for(var $=0;$<O.length;$++){var M=O[$];0===$&&(F=M),L.lineTo(M.x,M.y)}L.quadraticCurveTo(R.x,R.y,F.x,F.y)},"triangle-tee":function(L,O,R){L.beginPath&&L.beginPath();var F=O;for(var $=0;$<F.length;$++){var M=F[$];L.lineTo(M.x,M.y)}L.closePath&&L.closePath(),L.beginPath&&L.beginPath();var U=R,Z=R[0];L.moveTo(Z.x,Z.y);for(var $=0;$<U.length;$++){var M=U[$];L.lineTo(M.x,M.y)}L.closePath&&L.closePath()},circle:function(L,O,R,F){L.arc(O,R,F,0,2*Math.PI,!1)}}))[I]},_.exports=D},{}],65:[function(E,_){"use strict";var D={};D.drawEdge=function(T,I,L,O,R){var F=I._private.rscratch,$=this.usePaths();// if bezier ctrl pts can not be calculated, then die
// Edge color & opacity
if(!(F.badLine||isNaN(F.allpts[0]))&&I.visible()){var M;L&&(M=L,T.translate(-M.x1,-M.y1));var U=I.pstyle("overlay-padding").pfValue,Z=I.pstyle("overlay-opacity").value,G=I.pstyle("overlay-color").value;if(R){if(0===Z)// exit early if no overlay
return;this.strokeStyle(T,G[0],G[1],G[2],Z),T.lineCap="round","self"!=F.edgeType||$||(T.lineCap="butt")}else{var K=I.pstyle("line-color").value;this.strokeStyle(T,K[0],K[1],K[2],I.pstyle("opacity").value),T.lineCap="butt"}T.lineJoin="round";var J=I.pstyle("width").pfValue+(R?2*U:0),ee=R?"solid":I.pstyle("line-style").value;T.lineWidth=J,this.drawEdgePath(I,T,F.allpts,ee,J),this.drawArrowheads(T,I,R),R||this.drawEdge(T,I,!1,O,!0),this.drawElementText(T,I,O),L&&T.translate(M.x1,M.y1)}},D.drawEdgePath=function(T,I,L,O){var R=T._private.rscratch,F=I,M=!1,U=this.usePaths(),$;if(U){var Z=L.join("$"),G=R.pathCacheKey&&R.pathCacheKey===Z;G?($=I=R.pathCache,M=!0):($=I=new Path2D,R.pathCacheKey=Z,R.pathCache=$)}if(F.setLineDash&&("dotted"===O?F.setLineDash([1,1]):"dashed"===O?F.setLineDash([6,3]):"solid"===O?F.setLineDash([]):void 0),!M&&!R.badLine)switch(I.beginPath&&I.beginPath(),I.moveTo(L[0],L[1]),R.edgeType){case"bezier":case"self":case"compound":case"multibezier":for(var K=2;K+3<L.length;K+=4)I.quadraticCurveTo(L[K],L[K+1],L[K+2],L[K+3]);break;case"straight":case"segments":case"haystack":for(var K=2;K+1<L.length;K+=2)I.lineTo(L[K],L[K+1]);}I=F,U?I.stroke($):I.stroke(),I.setLineDash&&I.setLineDash([])},D.drawArrowheads=function(T,I,L){if(!L){// don't do anything for overlays
var O=I._private.rscratch,R="haystack"===O.edgeType;R||this.drawArrowhead(T,I,"source",O.arrowStartX,O.arrowStartY,O.srcArrowAngle),this.drawArrowhead(T,I,"mid-target",O.midX,O.midY,O.midtgtArrowAngle),this.drawArrowhead(T,I,"mid-source",O.midX,O.midY,O.midsrcArrowAngle),R||this.drawArrowhead(T,I,"target",O.arrowEndX,O.arrowEndY,O.tgtArrowAngle)}},D.drawArrowhead=function(T,I,L,O,R,F){// otherwise, the opaque arrow clears it for free :)
if(!(isNaN(O)||null==O||isNaN(R)||null==R||isNaN(F)||null==F)){var $=this,M=I.pstyle(L+"-arrow-shape").value;if("none"!==M){var U=T.globalCompositeOperation,Z="hollow"===I.pstyle(L+"-arrow-fill").value?"both":"filled",G=I.pstyle(L+"-arrow-fill").value,K=I.pstyle("opacity").value;"half-triangle-overshot"===M&&(G="hollow",Z="hollow"),(1!==K||"hollow"===G)&&(T.globalCompositeOperation="destination-out",$.fillStyle(T,255,255,255,1),$.strokeStyle(T,255,255,255,1),$.drawArrowShape(I,L,T,Z,I.pstyle("width").pfValue,I.pstyle(L+"-arrow-shape").value,O,R,F),T.globalCompositeOperation=U);var J=I.pstyle(L+"-arrow-color").value;$.fillStyle(T,J[0],J[1],J[2],K),$.strokeStyle(T,J[0],J[1],J[2],K),$.drawArrowShape(I,L,T,G,I.pstyle("width").pfValue,I.pstyle(L+"-arrow-shape").value,O,R,F)}}},D.drawArrowShape=function(T,I,L,O,R,F,$,M,U){var Z=this,G=this.usePaths(),K=T._private.rscratch,J=!1,ee,te=L,ae=this.getArrowWidth(R),ne=Z.arrowShapes[F];if(G){var re=ae+"$"+F+"$"+U+"$"+$+"$"+M;K.arrowPathCacheKey=K.arrowPathCacheKey||{},K.arrowPathCache=K.arrowPathCache||{};var oe=K.arrowPathCacheKey[I]===re;oe?(ee=L=K.arrowPathCache[I],J=!0):(ee=L=new Path2D,K.arrowPathCacheKey[I]=re,K.arrowPathCache[I]=ee)}L.beginPath&&L.beginPath(),J||ne.draw(L,ae,U,{x:$,y:M}),!ne.leavePathOpen&&L.closePath&&L.closePath(),L=te,("filled"===O||"both"===O)&&(G?L.fill(ee):L.fill()),("hollow"===O||"both"===O)&&(L.lineWidth=ne.matchEdgeWidth?R:1,L.lineJoin="miter",G?L.stroke(ee):L.stroke())},_.exports=D},{}],66:[function(E,_){"use strict";var D=E("../../../math"),T={};T.drawElement=function(I,L,O,R){var F=this;L.isNode()?F.drawNode(I,L,O,R):F.drawEdge(I,L,O,R)},T.drawCachedElement=function(I,L,O,R){var F=L.boundingBox();const $=Math.round(F.w);if(0!==$){const Ue=Math.round(F.h);if(0!==Ue&&(!R||D.boundingBoxesIntersect(F,R))){var U=this,Z=U.data.eleTxrCache.getElement(L,F,O);Z?I.drawImage(Z.texture.canvas,Z.x,0,Z.width,Z.height,Math.round(F.x1),Math.round(F.y1),$,Ue):U.drawElement(I,L)}}},T.drawElements=function(I,L){var O=this;for(var R=0;R<L.length;R++)O.drawElement(I,L[R])},T.drawCachedElements=function(I,L,O,R){var F=this;for(var $=0;$<L.length;$++){var M=L[$];F.drawCachedElement(I,M,O,R)}},T.drawCachedNodes=function(I,L,O,R){var F=this;for(var $=0;$<L.length;$++){var M=L[$];M.isNode()&&F.drawCachedElement(I,M,O,R)}},T.drawLayeredElements=function(I,L,O,R){var F=this,$=F.data.lyrTxrCache.getLayers(L,O);if($)for(var M=0;M<$.length;M++){var U=$[M],Z=U.bb;//using whole integer
const G=Math.round(Z.w);if(0!==G){const Ue=Math.round(Z.h);0===Ue||I.drawImage(U.canvas,Math.round(Z.x1),Math.round(Z.y1),G,Ue)}}else F.drawCachedElements(I,L,O,R)},_.exports=T},{"../../../math":84}],67:[function(E,_){"use strict";var D={};D.safeDrawImage=function(T,I,L,O,R,F,$,M,U,Z){var G=this;try{T.drawImage(I,L,O,R,F,$,M,U,Z)}catch(K){G.redrawHint("eles",!0),G.redrawHint("drag",!0),G.drawingImage=!0,G.redraw()}},D.drawInscribedImage=function(T,I,L){var O=this,R=L._private.position.x,F=L._private.position.y,$=L.pstyle("background-fit").value,M=L.pstyle("background-position-x"),U=L.pstyle("background-position-y"),Z=L.pstyle("background-repeat").value,G=L.width(),K=L.height(),J=L._private.rscratch,ee=L.pstyle("background-clip").value,te="node"===ee,ae=L.pstyle("background-image-opacity").value,ne=I.width||I.cachedW,re=I.height||I.cachedH;(null==ne||null==re)&&(document.body.appendChild(I),ne=I.cachedW=I.width||I.offsetWidth,re=I.cachedH=I.height||I.offsetHeight,document.body.removeChild(I));var oe=ne,se=re,le=L.pstyle("background-width");"auto"!==le.value&&("%"===le.units?oe=le.value/100*G:oe=le.pfValue);var pe=L.pstyle("background-height");if("auto"!==pe.value&&("%"===pe.units?se=pe.value/100*K:se=pe.pfValue),0!==oe&&0!==se){if("contain"===$){var ue=Math.min(G/oe,K/se);oe*=ue,se*=ue}else if("cover"===$){var ue=Math.max(G/oe,K/se);oe*=ue,se*=ue}var ge=R-G/2;// left
ge+="%"===M.units?(G-oe)*M.value/100:M.pfValue;var ce=F-K/2;// top
ce+="%"===U.units?(K-se)*U.value/100:U.pfValue,J.pathCache&&(ge-=R,ce-=F,R=0,F=0);var he=T.globalAlpha;if(T.globalAlpha=ae,"no-repeat"===Z)te&&(T.save(),J.pathCache?T.clip(J.pathCache):(O.nodeShapes[O.getNodeShape(L)].draw(T,R,F,G,K),T.clip())),O.safeDrawImage(T,I,0,0,ne,re,ge,ce,oe,se),te&&T.restore();else{var ye=T.createPattern(I,Z);T.fillStyle=ye,O.nodeShapes[O.getNodeShape(L)].draw(T,R,F,G,K),T.translate(ge,ce),T.fill(),T.translate(-ge,-ce)}T.globalAlpha=he}},_.exports=D},{}],68:[function(E,_){"use strict";function D(O,R,F,$,M,U){var U=U||5;O.beginPath(),O.moveTo(R+U,F),O.lineTo(R+$-U,F),O.quadraticCurveTo(R+$,F,R+$,F+U),O.lineTo(R+$,F+M-U),O.quadraticCurveTo(R+$,F+M,R+$-U,F+M),O.lineTo(R+U,F+M),O.quadraticCurveTo(R,F+M,R,F+M-U),O.lineTo(R,F+U),O.quadraticCurveTo(R,F,R+U,F),O.closePath(),O.fill()}// Draw text
var T=E("../../../util"),I=E("../../../math"),L={};L.eleTextBiggerThanMin=function(O,R){if(!R){var F=O.cy().zoom(),$=this.getPixelRatio(),M=Math.ceil(I.log2(F*$));// the effective texture level
R=Math.pow(2,M)}var U=O.pstyle("font-size").pfValue*R,Z=O.pstyle("min-zoomed-font-size").pfValue;return!(U<Z)},L.drawElementText=function(O,R,F){var $=this;if(F===void 0){if(!$.eleTextBiggerThanMin(R))return;}else if(!F)return;if(R.isNode()){var M=R.pstyle("label");if(!M||!M.value)return;var U=R.pstyle("text-halign").strValue;R.pstyle("text-valign").strValue,O.textAlign="left"===U?"right":"right"===U?"left":"center",O.textBaseline="bottom"}else{var M=R.pstyle("label"),Z=R.pstyle("source-label"),G=R.pstyle("target-label");if((!M||!M.value)&&(!Z||!Z.value)&&(!G||!G.value))return;O.textAlign="center",O.textBaseline="bottom"}$.drawText(O,R),R.isEdge()&&($.drawText(O,R,"source"),$.drawText(O,R,"target"))},L.drawNodeText=L.drawEdgeText=L.drawElementText,L.getFontCache=function(O){var R;this.fontCaches=this.fontCaches||[];for(var F=0;F<this.fontCaches.length;F++)if(R=this.fontCaches[F],R.context===O)return R;return R={context:O},this.fontCaches.push(R),R},L.setupTextStyle=function(O,R){// Font style
var F=R.effectiveOpacity(),$=R.pstyle("font-style").strValue,M=R.pstyle("font-size").pfValue+"px",U=R.pstyle("font-family").strValue,Z=R.pstyle("font-weight").strValue,G=R.pstyle("text-opacity").value*R.pstyle("opacity").value*F,K=R.pstyle("text-outline-opacity").value*G,J=R.pstyle("color").value,ee=R.pstyle("text-outline-color").value,te=R._private.fontKey,ae=this.getFontCache(O);// var shadowBlur = ele.pstyle( 'text-shadow-blur' ).pfValue;
// var shadowOpacity = ele.pstyle( 'text-shadow-opacity' ).value;
// var shadowColor = ele.pstyle( 'text-shadow-color' ).value;
// var shadowOffsetX = ele.pstyle( 'text-shadow-offset-x' ).pfValue;
// var shadowOffsetY = ele.pstyle( 'text-shadow-offset-y' ).pfValue;
ae.key!==te&&(O.font=$+" "+Z+" "+M+" "+U,ae.key=te),O.lineJoin="round",this.fillStyle(O,J[0],J[1],J[2],G),this.strokeStyle(O,ee[0],ee[1],ee[2],K)},L.drawText=function(O,R,F){var $=R._private,M=$.rscratch,U=R.effectiveOpacity();if(0!==U&&0!==R.pstyle("text-opacity").value){var Z=T.getPrefixedProperty(M,"labelX",F),G=T.getPrefixedProperty(M,"labelY",F),K=this.getLabelText(R,F);if(null!=K&&""!==K&&!isNaN(Z)&&!isNaN(G)){this.setupTextStyle(O,R);var J=F?F+"-":"",ee=T.getPrefixedProperty(M,"labelWidth",F),te=T.getPrefixedProperty(M,"labelHeight",F),ae=T.getPrefixedProperty(M,"labelAngle",F),ne=R.pstyle(J+"text-margin-x").pfValue,re=R.pstyle(J+"text-margin-y").pfValue,oe=R.isEdge(),se=R.isNode(),le=R.pstyle("text-halign").value,pe=R.pstyle("text-valign").value;oe&&(le="center",pe="center"),Z+=ne,G+=re;var ue=R.pstyle("text-rotation"),ge;if(ge="autorotate"===ue.strValue?oe?ae:0:"none"===ue.strValue?0:ue.pfValue,0!==ge){var ce=Z,he=G;O.translate(ce,he),O.rotate(ge),Z=0,G=0}if(se){var ye=R.pstyle("padding-left").pfValue,me=R.pstyle("padding-right").pfValue,fe=R.pstyle("padding-top").pfValue,xe=R.pstyle("padding-bottom").pfValue;Z+=ye/2,Z-=me/2,G+=fe/2,G-=xe/2}switch(pe){case"top":break;case"center":G+=te/2;break;case"bottom":G+=te;}var ve=R.pstyle("text-background-opacity").value,be=R.pstyle("text-border-opacity").value,we=R.pstyle("text-border-width").pfValue;if(0<ve||0<we&&0<be){var Ee=Z;switch(le){case"left":Ee-=ee;break;case"center":Ee-=ee/2;break;case"right":}var Se=G-te;if(0<ve){var _e=O.fillStyle,Pe=R.pstyle("text-background-color").value;O.fillStyle="rgba("+Pe[0]+","+Pe[1]+","+Pe[2]+","+ve*U+")";var Ce=R.pstyle("text-background-shape").strValue;"roundrectangle"==Ce?D(O,Ee,Se,ee,te,2):O.fillRect(Ee,Se,ee,te),O.fillStyle=_e}if(0<we&&0<be){var De=O.strokeStyle,Te=O.lineWidth,ke=R.pstyle("text-border-color").value,Ie=R.pstyle("text-border-style").value;if(O.strokeStyle="rgba("+ke[0]+","+ke[1]+","+ke[2]+","+be*U+")",O.lineWidth=we,O.setLineDash&&("dotted"===Ie?O.setLineDash([1,1]):"dashed"===Ie?O.setLineDash([4,2]):"double"===Ie?(O.lineWidth=we/4,O.setLineDash([])):"solid"===Ie?O.setLineDash([]):void 0),(O.strokeRect(Ee,Se,ee,te),"double"===Ie)){var Ne=we/2;O.strokeRect(Ee+Ne,Se+Ne,ee-2*Ne,te-2*Ne)}O.setLineDash&&O.setLineDash([]),O.lineWidth=Te,O.strokeStyle=De}}var ze=2*R.pstyle("text-outline-width").pfValue;// *2 b/c the stroke is drawn centred on the middle
if(0<ze&&(O.lineWidth=ze),"wrap"===R.pstyle("text-wrap").value){var Be=M.labelWrapCachedLines,Le=te/Be.length;"top"===pe?G-=(Be.length-1)*Le:"center"===pe||"bottom"===pe?G-=(Be.length-1)*Le:void 0;for(var Oe=0;Oe<Be.length;Oe++)0<ze&&O.strokeText(Be[Oe],Z,G),O.fillText(Be[Oe],Z,G),G+=Le}else 0<ze&&O.strokeText(K,Z,G),O.fillText(K,Z,G);0!==ge&&(O.rotate(-ge),O.translate(-ce,-he))}}},_.exports=L},{"../../../math":84,"../../../util":99}],69:[function(E,_){"use strict";var D=E("../../../is"),T={};T.drawNode=function(I,L,O,R){var F=this,U=L._private.rscratch,Z=L._private,G=G||Z.position,$,M;//
// setup shift
//
// load bg image
//
// setup styles
// so borders are square with the node shape
//
// draw shape
//
// pie
//
// border
//
// overlay
if(D.number(G.x)&&D.number(G.y)&&L.visible()){var K=L.effectiveOpacity(),J=this.usePaths(),te=!1,ee;$=L.width()+L.pstyle("padding-left").pfValue+L.pstyle("padding-right").pfValue,M=L.height()+L.pstyle("padding-top").pfValue+L.pstyle("padding-bottom").pfValue,I.lineWidth=L.pstyle("border-width").pfValue;var ae;O&&(ae=O,I.translate(-ae.x1,-ae.y1));var ne=L.pstyle("background-image"),re=ne.value[2]||ne.value[1],oe;if(void 0!==re){oe=this.getCachedImage(re,function(){L.trigger("background"),F.redrawHint("eles",!0),F.redrawHint("drag",!0),F.drawingImage=!0,F.redraw()});var se=Z.backgrounding;Z.backgrounding=!oe.complete,se!==Z.backgrounding&&L.updateStyle(!1)}var le=L.pstyle("background-color").value,pe=L.pstyle("border-color").value,ue=L.pstyle("border-style").value;this.fillStyle(I,le[0],le[1],le[2],L.pstyle("background-opacity").value*K),this.strokeStyle(I,pe[0],pe[1],pe[2],L.pstyle("border-opacity").value*K),I.lineJoin="miter",I.setLineDash&&("dotted"===ue?I.setLineDash([1,1]):"dashed"===ue?I.setLineDash([4,2]):"solid"===ue||"double"===ue?I.setLineDash([]):void 0);var ge=L.pstyle("shape").strValue,ce=L.pstyle("shape-polygon-points").pfValue;if(J){var he=ge+"$"+$+"$"+M+("polygon"===ge?"$"+ce.join("$"):"");I.translate(G.x,G.y),U.pathCacheKey===he?(ee=U.pathCache,te=!0):(ee=new Path2D,U.pathCacheKey=he,U.pathCache=ee)}if(!te){var ye=G;J&&(ye={x:0,y:0}),F.nodeShapes[this.getNodeShape(L)].draw(ee||I,ye.x,ye.y,$,M)}J?I.fill(ee):I.fill(),void 0!==re&&oe.complete&&this.drawInscribedImage(I,oe,L);var me=L.pstyle("background-blacken").value,fe=L.pstyle("border-width").pfValue;if(this.hasPie(L)&&(this.drawPie(I,L,K),(0!==me||0!==fe)&&!J&&F.nodeShapes[this.getNodeShape(L)].draw(I,G.x,G.y,$,M)),0<me?(this.fillStyle(I,0,0,0,me),J?I.fill(ee):I.fill()):0>me&&(this.fillStyle(I,255,255,255,-me),J?I.fill(ee):I.fill()),0<fe&&(J?I.stroke(ee):I.stroke(),"double"===ue)){I.lineWidth=L.pstyle("border-width").pfValue/3;var xe=I.globalCompositeOperation;I.globalCompositeOperation="destination-out",J?I.stroke(ee):I.stroke(),I.globalCompositeOperation=xe}J&&I.translate(-G.x,-G.y),I.setLineDash&&I.setLineDash([]),F.drawElementText(I,L,R);var ve=L.pstyle("overlay-padding").pfValue,be=L.pstyle("overlay-opacity").value,we=L.pstyle("overlay-color").value;0<be&&(this.fillStyle(I,we[0],we[1],we[2],be),F.nodeShapes.roundrectangle.draw(I,L._private.position.x,L._private.position.y,$+2*ve,M+2*ve),I.fill()),O&&I.translate(ae.x1,ae.y1)}},T.hasPie=function(I){// ensure ele ref
return I=I[0],I._private.hasPie},T.drawPie=function(I,L,O,R){L=L[0];// ensure ele ref
var F=L._private,$=L.cy().style(),M=L.pstyle("pie-size"),U=L.width(),Z=L.height(),R=R||F.position,G=R.x,K=R.y,J=Math.min(U,Z)/2,ee=0,te=this.usePaths();// must fit in node
// what % to continue drawing pie slices from on [0, 1]
te&&(G=0,K=0),"%"===M.units?J=J*M.value/100:M.pfValue!==void 0&&(J=M.pfValue/2);for(var ae=1;ae<=$.pieBackgroundN;ae++){// 1..N
var ne=L.pstyle("pie-"+ae+"-background-size").value,re=L.pstyle("pie-"+ae+"-background-color").value,oe=L.pstyle("pie-"+ae+"-background-opacity").value*O,se=ne/100;// map integer range [0, 100] to [0, 1]
// percent can't push beyond 1
1<se+ee&&(se=1-ee);var le=1.5*Math.PI+2*Math.PI*ee,pe=2*Math.PI*se;// start at 12 o'clock and go clockwise
// ignore if
// - zero size
// - we're already beyond the full circle
// - adding the current slice would go beyond the full circle
0===ne||1<=ee||1<ee+se||(I.beginPath(),I.moveTo(G,K),I.arc(G,K,J,le,le+pe),I.closePath(),this.fillStyle(I,re[0],re[1],re[2],oe),I.fill(),ee+=se)}},_.exports=T},{"../../../is":83}],70:[function(E,_){"use strict";// CRp.shadowStyle = function (context, color, opacity, blur, offsetX, offsetY) {
//     var zoom = this.cy.zoom();
//
//     // var cache = this.paintCache( context );
//     //
//     // // don't make expensive changes to the shadow style if it's not used
//     // if( cache.shadowOpacity === 0 && opacity === 0 ){
//     //   return;
//     // }
//     //
//     // cache.shadowOpacity = opacity;
//
//     if (opacity > 0) {
//         context.shadowBlur = blur * zoom;
//         context.shadowColor = 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + opacity + ')';
//         context.shadowOffsetX = offsetX * zoom;
//         context.shadowOffsetY = offsetY * zoom;
//     } else {
//         context.shadowBlur = 0;
//         context.shadowColor = 'transparent';
//         context.shadowOffsetX = 0;
//         context.shadowOffsetY = 0;
//     }
// };
// Resize canvas
function D(L,O,R,F,$){(L.width!==O||L.height!==R)&&(L.width=O,L.height=R,L.style.width=F,L.style.height=$)}var T={},I=E("../../../util");T.getPixelRatio=function(){var L=this.data.contexts[0];if(null!=this.forcedPixelRatio)return this.forcedPixelRatio;var O=L.backingStorePixelRatio||L.webkitBackingStorePixelRatio||L.mozBackingStorePixelRatio||L.msBackingStorePixelRatio||L.oBackingStorePixelRatio||L.backingStorePixelRatio||1;return(window.devicePixelRatio||1)/O;// eslint-disable-line no-undef
},T.paintCache=function(L){var O=this.paintCaches=this.paintCaches||[],R=!0,F;for(var $=0;$<O.length;$++)if(F=O[$],F.context===L){R=!1;break}return R&&(F={context:L},O.push(F)),F},T.fillStyle=function(L,O,R,F,$){L.fillStyle="rgba("+O+","+R+","+F+","+$+")"},T.strokeStyle=function(L,O,R,F,$){L.strokeStyle="rgba("+O+","+R+","+F+","+$+")"},T.matchCanvasSize=function(L){var O=this,R=O.data,F=L.clientWidth,$=L.clientHeight,M=O.getPixelRatio(),U=O.motionBlurPxRatio;(L===O.data.bufferCanvases[O.MOTIONBLUR_BUFFER_NODE]||L===O.data.bufferCanvases[O.MOTIONBLUR_BUFFER_DRAG])&&(M=U);var Z=F*M,G=$*M,K;if(Z!==O.canvasWidth||G!==O.canvasHeight){O.fontCaches=null;// resizing resets the style
var J=R.canvasContainer;const ee=F+"px";J.style.width=ee;//'px' shouldnot be necessary  //widthPx;
const te=$+"px";J.style.height=te;//'px' shouldnot be necessary //heightPx;
for(var ae=0;ae<O.CANVAS_LAYERS;ae++)K=R.canvases[ae],D(K,Z,G,ee,te);for(var ae=0;ae<O.BUFFER_COUNT;ae++)K=R.bufferCanvases[ae],D(K,Z,G,ee,te);O.textureMult=1,1>=M&&(K=R.bufferCanvases[O.TEXTURE_BUFFER],O.textureMult=2,K.width=Z*O.textureMult,K.height=G*O.textureMult),O.canvasWidth=Z,O.canvasHeight=G}},T.renderTo=function(L,O,R,F){this.render({forcedContext:L,forcedZoom:O,forcedPan:R,drawAllLayers:!0,forcedPxRatio:F})},T.render=function(L){function O(Ve,Fe,Xe,Ye,We){var He=Ve.globalCompositeOperation;Ve.globalCompositeOperation="destination-out",G.fillStyle(Ve,255,255,255,G.motionBlurTransparency),Ve.fillRect(Fe,Xe,Ye,We),Ve.globalCompositeOperation=He}function R(Ve,Fe){var Xe,Ye,We,He;G.clearingMotionBlur||Ve!==ee.bufferContexts[G.MOTIONBLUR_BUFFER_NODE]&&Ve!==ee.bufferContexts[G.MOTIONBLUR_BUFFER_DRAG]?(Xe=ye,Ye=ce,We=G.canvasWidth,He=G.canvasHeight):(Xe={x:he.x*re,y:he.y*re},Ye=ge*re,We=G.canvasWidth*re,He=G.canvasHeight*re),Ve.setTransform(1,0,0,1,0,0),"motionBlur"===Fe?O(Ve,0,0,We,He):!F&&(void 0===Fe||Fe)&&Ve.clearRect(0,0,We,He),$||(Ve.translate(Xe.x,Xe.y),Ve.scale(Ye,Ye)),Z&&Ve.translate(Z.x,Z.y),U&&Ve.scale(U,U)}L=L||I.staticEmptyObject();var F=L.forcedContext,$=L.drawAllLayers,M=L.drawOnlyNodeLayer,U=L.forcedZoom,Z=L.forcedPan,G=this,K=void 0===L.forcedPxRatio?this.getPixelRatio():L.forcedPxRatio,J=G.cy,ee=G.data,te=ee.canvasNeedsRedraw,ae=G.textureOnViewport&&!F&&(G.pinching||G.hoverData.dragging||G.swipePanning||G.data.wheelZooming),ne=void 0===L.motionBlur?G.motionBlur:L.motionBlur,re=G.motionBlurPxRatio,oe=J.hasCompoundNodes(),se=G.hoverData.draggingEles,le=G.hoverData.selecting||G.touchData.selecting;ne=ne&&!F&&G.motionBlurEnabled&&!le;var pe=ne;F||(G.prevPxRatio!==K&&(G.invalidateContainerClientCoordsCache(),G.matchCanvasSize(G.container),G.redrawHint("eles",!0),G.redrawHint("drag",!0)),G.prevPxRatio=K),!F&&G.motionBlurTimeout&&clearTimeout(G.motionBlurTimeout),ne&&(null==G.mbFrames&&(G.mbFrames=0),!G.drawingImage&&G.mbFrames++,3>G.mbFrames&&(pe=!1),G.mbFrames>G.minMbLowQualFrames&&(G.motionBlurPxRatio=G.mbPxRBlurry)),G.clearingMotionBlur&&(G.motionBlurPxRatio=1),G.textureDrawLastFrame&&!ae&&(te[G.NODE]=!0,te[G.SELECT_BOX]=!0);var ue=J.style()._private.coreStyle,ge=J.zoom(),ce=void 0===U?ge:U,he=J.pan(),ye={x:he.x,y:he.y},me={zoom:ge,pan:{x:he.x,y:he.y}},fe=G.prevViewport,xe=void 0===fe||me.zoom!==fe.zoom||me.pan.x!==fe.pan.x||me.pan.y!==fe.pan.y;xe||se&&!oe||(G.motionBlurPxRatio=1),Z&&(ye=Z),ce*=K,ye.x*=K,ye.y*=K;var ve=G.getCachedZSortedEles();if(ae||(G.textureDrawLastFrame=!1),ae){//var bb;
if(G.textureDrawLastFrame=!0,!G.textureCache){G.textureCache={},G.textureCache.bb=J.mutableElements().boundingBox(),G.textureCache.texture=G.data.bufferCanvases[G.TEXTURE_BUFFER];var be=G.data.bufferContexts[G.TEXTURE_BUFFER];be.setTransform(1,0,0,1,0,0),be.clearRect(0,0,G.canvasWidth*G.textureMult,G.canvasHeight*G.textureMult),G.render({forcedContext:be,drawOnlyNodeLayer:!0,forcedPxRatio:K*G.textureMult});var me=G.textureCache.viewport={zoom:J.zoom(),pan:J.pan(),width:G.canvasWidth,height:G.canvasHeight};me.mpan={x:(0-me.pan.x)/me.zoom,y:(0-me.pan.y)/me.zoom}}te[G.DRAG]=!1,te[G.NODE]=!1;var we=ee.contexts[G.NODE],Ee=G.textureCache.texture,me=G.textureCache.viewport;we.setTransform(1,0,0,1,0,0),ne?O(we,0,0,me.width,me.height):we.clearRect(0,0,me.width,me.height);var Se=ue["outside-texture-bg-color"].value,_e=ue["outside-texture-bg-opacity"].value;G.fillStyle(we,Se[0],Se[1],Se[2],_e),we.fillRect(0,0,me.width,me.height);var ge=J.zoom();R(we,!1),we.clearRect(me.mpan.x,me.mpan.y,me.width/me.zoom/K,me.height/me.zoom/K),we.drawImage(Ee,me.mpan.x,me.mpan.y,me.width/me.zoom/K,me.height/me.zoom/K)}else G.textureOnViewport&&!F&&(G.textureCache=null);var Pe=J.extent(),Ce=G.pinching||G.hoverData.dragging||G.swipePanning||G.data.wheelZooming||G.hoverData.draggingEles,De=G.hideEdgesOnViewport&&Ce,Te=[];if(Te[G.NODE]=!te[G.NODE]&&ne&&!G.clearedForMotionBlur[G.NODE]||G.clearingMotionBlur,Te[G.NODE]&&(G.clearedForMotionBlur[G.NODE]=!0),Te[G.DRAG]=!te[G.DRAG]&&ne&&!G.clearedForMotionBlur[G.DRAG]||G.clearingMotionBlur,Te[G.DRAG]&&(G.clearedForMotionBlur[G.DRAG]=!0),te[G.NODE]||$||M||Te[G.NODE]){var ke=ne&&!Te[G.NODE]&&1!==re,we=F||(ke?G.data.bufferContexts[G.MOTIONBLUR_BUFFER_NODE]:ee.contexts[G.NODE]),Ie=ne&&!ke?"motionBlur":void 0;R(we,Ie),De?G.drawCachedNodes(we,ve.nondrag,K,Pe):G.drawLayeredElements(we,ve.nondrag,K,Pe),$||ne||(te[G.NODE]=!1)}if(!M&&(te[G.DRAG]||$||Te[G.DRAG])){var ke=ne&&!Te[G.DRAG]&&1!==re,we=F||(ke?G.data.bufferContexts[G.MOTIONBLUR_BUFFER_DRAG]:ee.contexts[G.DRAG]);R(we,ne&&!ke?"motionBlur":void 0),De?G.drawCachedNodes(we,ve.drag,K,Pe):G.drawCachedElements(we,ve.drag,K,Pe),$||ne||(te[G.DRAG]=!1)}if(G.showFps||!M&&te[G.SELECT_BOX]&&!$){var we=F||ee.contexts[G.SELECT_BOX];if(R(we),1==G.selection[4]&&(G.hoverData.selecting||G.touchData.selecting)){var ge=G.cy.zoom(),Ne=ue["selection-box-border-width"].value/ge;we.lineWidth=Ne;const Ve=ue["selection-box-color"].value;if(we.fillStyle="rgba("+Ve[0]+","+Ve[1]+","+Ve[2]+","+ue["selection-box-opacity"].value+")",we.fillRect(G.selection[0],G.selection[1],G.selection[2]-G.selection[0],G.selection[3]-G.selection[1]),0<Ne){const Fe=ue["selection-box-border-color"].value;we.strokeStyle="rgba("+Fe[0]+","+Fe[1]+","+Fe[2]+","+ue["selection-box-opacity"].value+")",we.strokeRect(G.selection[0],G.selection[1],G.selection[2]-G.selection[0],G.selection[3]-G.selection[1])}}if(ee.bgActivePosistion&&!G.hoverData.selecting){var ge=G.cy.zoom(),ze=ee.bgActivePosistion;const Ve=ue["active-bg-color"].value;we.fillStyle="rgba("+Ve[0]+","+Ve[1]+","+Ve[2]+","+ue["active-bg-opacity"].value+")",we.beginPath(),we.arc(ze.x,ze.y,ue["active-bg-size"].pfValue/ge,0,2*Math.PI),we.fill()}var Be=G.lastRedrawTime;if(G.showFps&&Be){Be=Math.round(Be);var Le=Math.round(1000/Be);we.setTransform(1,0,0,1,0,0),we.fillStyle="rgba(255, 0, 0, 0.75)",we.strokeStyle="rgba(255, 0, 0, 0.75)",we.lineWidth=1,we.fillText("1 frame = "+Be+" ms = "+Le+" fps",0,20),we.strokeRect(0,30,250,20),we.fillRect(0,30,250*Math.min(Le/60,1),20)}$||(te[G.SELECT_BOX]=!1)}// motionblur: blit rendered blurry frames
if(ne&&1!==re){var Oe=ee.contexts[G.NODE],Ae=G.data.bufferCanvases[G.MOTIONBLUR_BUFFER_NODE],je=ee.contexts[G.DRAG],Re=G.data.bufferCanvases[G.MOTIONBLUR_BUFFER_DRAG],qe=function(Ve,Fe,Xe){Ve.setTransform(1,0,0,1,0,0),Xe||!pe?Ve.clearRect(0,0,G.canvasWidth,G.canvasHeight):O(Ve,0,0,G.canvasWidth,G.canvasHeight);var Ye=re;Ve.drawImage(Fe,// img
0,0,// sx, sy
G.canvasWidth*Ye,G.canvasHeight*Ye,// sw, sh
0,0,// x, y
G.canvasWidth,G.canvasHeight// w, h
)};(te[G.NODE]||Te[G.NODE])&&(qe(Oe,Ae,Te[G.NODE]),te[G.NODE]=!1),(te[G.DRAG]||Te[G.DRAG])&&(qe(je,Re,Te[G.DRAG]),te[G.DRAG]=!1)}G.prevViewport=me,G.clearingMotionBlur&&(G.clearingMotionBlur=!1,G.motionBlurCleared=!0,G.motionBlur=!0),ne&&(G.motionBlurTimeout=setTimeout(function(){G.motionBlurTimeout=null,G.clearedForMotionBlur[G.NODE]=!1,G.clearedForMotionBlur[G.DRAG]=!1,G.motionBlur=!1,G.clearingMotionBlur=!ae,G.mbFrames=0,te[G.NODE]=!0,te[G.DRAG]=!0,G.redraw()},100)),G.drawingImage=!1,F||J.trigger("render")},_.exports=T},{"../../../util":99}],71:[function(E,_){"use strict";var D=E("../../../math"),T={};// @O Polygon drawing
T.drawPolygonPath=function(M,U,Z,G,K,J){const ee=G/2,te=K/2;M.beginPath&&M.beginPath(),M.moveTo(Math.round(U+ee*J[0]),Math.round(Z+te*J[1]));var ae=2;for(var ne=1;ne<J.length/2;ne++)M.lineTo(Math.round(U+ee*J[ae++]),Math.round(Z+te*J[ae++]));M.closePath()},T.drawRoundRectanglePath=function(M,U,Z,G,K){var J=G/2,ee=K/2,te=D.getRoundRectangleRadius(G,K);M.beginPath&&M.beginPath(),M.moveTo(U,Z-ee),M.arcTo(U+J,Z-ee,U+J,Z,te),M.arcTo(U+J,Z+ee,U,Z+ee,te),M.arcTo(U-J,Z+ee,U-J,Z,te),M.arcTo(U-J,Z-ee,U,Z-ee,te),M.lineTo(U,Z-ee),M.closePath()};var I=Math.sin(0),L=Math.cos(0),O={},R={},F=Math.PI/40;for(var $=0*Math.PI;$<2*Math.PI;$+=F)O[$]=Math.sin($),R[$]=Math.cos($);T.drawEllipsePath=function(M,U,Z,G,K){if(M.beginPath&&M.beginPath(),M.ellipse)M.ellipse(U,Z,G/2,K/2,0,0,2*Math.PI);else{var J,ee;const ae=G/2,ne=K/2;for(var te=0*Math.PI;te<2*Math.PI;te+=F){const re=O[te],oe=R[te];J=U-ae*re*I+ae*oe*L,ee=Z+ne*oe*I+ne*re*L,0==te?M.moveTo(J,ee):M.lineTo(J,ee)}}M.closePath()},_.exports=T},{"../../../math":84}],72:[function(E,_){"use strict";var D=E("../../../math"),T=E("../../../util"),I=E("../../../heap"),L=E("./texture-cache-defs"),O=25,R=50,F=-4,$=2,M={dequeue:"dequeue",downscale:"downscale",highQuality:"highQuality"},U=function(G){var K=this;K.renderer=G,K.onDequeues=[],K.setupDequeueing()},Z=U.prototype;// the size of the texture cache for small height eles (special case)
// the min size of the regular cache, and the size it increases with each step up
// when scaling smaller than that we don't need to re-render
// number of eles to dequeue and render at higher texture in each batch
// when larger than this scale just render directly (caching is not helpful)
// beyond this zoom level, layered textures are not used
// spacing between elements on textures to avoid blitting overlaps
// default/minimum texture width
// the maximum width of a texture
// the maximum height of a texture
// if usage of texture is less than this, it is retired
// fullness of texture after which queue removal is checked
// dequeued after this many checks
// whether edges can be cached as textures (TODO maybe better on if webgl supported?)
// whether parent nodes can be cached as textures (TODO maybe better on if webgl supported?)
// % of add'l rendering cost allowed for dequeuing ele caches each frame
// % of add'l rendering cost compared to average overall redraw time
// % of avg frame time that can be used for dequeueing when not drawing
// % of frame time to be used when >60fps
// time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
Z.reasons=M,Z.getTextureQueue=function(G){var K=this;return K.eleImgCaches=K.eleImgCaches||{},K.eleImgCaches[G]=K.eleImgCaches[G]||[]},Z.getRetiredTextureQueue=function(G){var K=this,J=K.eleImgCaches.retired=K.eleImgCaches.retired||{},ee=J[G]=J[G]||[];return ee},Z.getElementQueue=function(){var G=this,K=G.eleCacheQueue=G.eleCacheQueue||new I(function(J,ee){return ee.reqs-J.reqs});return K},Z.getElementIdToQueue=function(){var G=this,K=G.eleIdToCacheQueue=G.eleIdToCacheQueue||{};return K},Z.getElement=function(G,K,J,ee,te){var ae=this,ne=this.renderer,re=G._private.rscratch,oe=ne.cy.zoom();if(0===K.w||0===K.h)return null;if(null==ee&&(ee=Math.ceil(D.log2(oe*J))),ee<F)ee=F;else if(3.99<=oe||ee>$)return null;var se=Math.pow(2,ee),le=K.h*se,pe=K.w*se,ue=re.imgCaches=re.imgCaches||{},ge=ue[ee];if(ge)return ge;var ce;// which texture height this ele belongs to
if(ce=le<=O?O:le<=R?R:Math.ceil(le/R)*R,1024<le||1024<pe||G.isEdge()||G.isParent())return null;// caching large elements is not efficient
var he=ae.getTextureQueue(ce),ye=he[he.length-2],me=function(){return ae.recycleTexture(ce,pe)||ae.addTexture(ce,pe)};// first try the second last one in case it has space at the end
ye||(ye=he[he.length-1]),ye||(ye=me()),ye.width-ye.usedWidth<pe&&(ye=me());var fe=ne.eleTextBiggerThanMin(G,se),xe=function(Te){return Te&&Te.scaledLabelShown===fe},ve=te&&te===M.dequeue,be=te&&te===M.highQuality,we=te&&te===M.downscale,Ee;// the nearest cache with a higher level
for(var Se=ee+1;Se<=$;Se++){var _e=ue[Se];if(_e){Ee=_e;break}}var Pe=Ee&&Ee.level===ee+1?Ee:null,Ce=function(){ye.context.drawImage(Pe.texture.canvas,Pe.x,0,Pe.width,Pe.height,ye.usedWidth,0,pe,le)};if(xe(Pe))Ce();else if(!xe(Ee)){var De;// the nearest cache with a lower level
if(!ve&&!be&&!we)for(var Se=ee-1;Se>=F;Se--){var _e=ue[Se];if(_e){De=_e;break}}if(xe(De))return ae.queueElement(G,K,ee),De;ye.context.translate(ye.usedWidth,0),ye.context.scale(se,se),ne.drawElement(ye.context,G,K,fe),ye.context.scale(1/se,1/se),ye.context.translate(-ye.usedWidth,0)}else// then use the higher cache for now and queue the next level down
// to cheaply scale towards the smaller level
if(be){for(var Se=Ee.level;Se>ee;Se--)Pe=ae.getElement(G,K,J,Se,M.downscale);Ce()}else return ae.queueElement(G,K,Ee.level-1),Ee;return ge=ue[ee]={ele:G,x:ye.usedWidth,texture:ye,level:ee,scale:se,width:pe,height:le,scaledLabelShown:fe},ye.usedWidth+=Math.ceil(pe+8),ye.eleCaches.push(ge),ae.checkTextureFullness(ye),ge},Z.invalidateElement=function(G){var K=this,J=G._private.rscratch.imgCaches;if(J)for(var ee=F;ee<=$;ee++){var te=J[ee];if(te){var ae=te.texture;// remove space from the texture it belongs to
ae.invalidatedWidth+=te.width,J[ee]=null,T.removeFromArray(ae.eleCaches,te),K.checkTextureUtility(ae)}}},Z.checkTextureUtility=function(G){G.invalidatedWidth>=0.5*G.width&&this.retireTexture(G)},Z.checkTextureFullness=function(G){// if texture has been mostly filled and passed over several times, remove
// it from the queue so we don't need to waste time looking at it to put new things
var K=this,J=K.getTextureQueue(G.height);0.8<G.usedWidth/G.width&&10<=G.fullnessChecks?T.removeFromArray(J,G):G.fullnessChecks++},Z.retireTexture=function(G){var K=this,J=G.height,ee=K.getTextureQueue(J);// retire the texture from the active / searchable queue:
T.removeFromArray(ee,G),G.retired=!0;// remove the refs from the eles to the caches:
var te=G.eleCaches;for(var ae=0;ae<te.length;ae++){var ne=te[ae],re=ne.ele,oe=ne.level,se=re._private.rscratch.imgCaches;se&&(se[oe]=null)}T.clearArray(te);// add the texture to a retired queue so it can be recycled in future:
var le=K.getRetiredTextureQueue(J);le.push(G)},Z.addTexture=function(G,K){var J=this,ee=J.getTextureQueue(G),te={};return ee.push(te),te.eleCaches=[],te.height=G,te.width=Math.max(1024,K),te.usedWidth=0,te.invalidatedWidth=0,te.fullnessChecks=0,te.canvas=document.createElement("canvas"),te.canvas.width=te.width,te.canvas.height=te.height,te.context=te.canvas.getContext("2d"),te},Z.recycleTexture=function(G,K){var J=this,ee=J.getTextureQueue(G),te=J.getRetiredTextureQueue(G);for(var ae=0;ae<te.length;ae++){var ne=te[ae];if(ne.width>=K)return ne.retired=!1,ne.usedWidth=0,ne.invalidatedWidth=0,ne.fullnessChecks=0,T.clearArray(ne.eleCaches),ne.context.clearRect(0,0,ne.width,ne.height),T.removeFromArray(te,ne),ee.push(ne),ne}},Z.queueElement=function(G,K,J){var ee=this,te=ee.getElementQueue(),ae=ee.getElementIdToQueue(),ne=G.id(),re=ae[ne];if(re)re.level=Math.max(re.level,J),re.reqs++,te.updateItem(re);else{var oe={ele:G,bb:K,position:D.copyPosition(G.position()),level:J,reqs:1};G.isEdge()&&(oe.positions={source:D.copyPosition(G.source().position()),target:D.copyPosition(G.target().position())}),te.push(oe),ae[ne]=oe}},Z.dequeue=function(G){var K=this,J=K.getElementQueue(),ee=K.getElementIdToQueue(),te=[];for(var ae=0;1>ae&&0<J.size();ae++){var ne=J.pop();ee[ne.ele.id()]=null,te.push(ne);var re=ne.ele,oe;oe=(!re.isEdge()||D.arePositionsSame(re.source().position(),ne.positions.source)&&D.arePositionsSame(re.target().position(),ne.positions.target))&&D.arePositionsSame(re.position(),ne.position)?ne.bb:re.boundingBox(),K.getElement(ne.ele,oe,G,ne.level,M.dequeue)}return te},Z.onDequeue=function(G){this.onDequeues.push(G)},Z.offDequeue=function(G){T.removeFromArray(this.onDequeues,G)},Z.setupDequeueing=L.setupDequeueing({deqRedrawThreshold:100,deqCost:0.15,deqAvgCost:0.1,deqNoDrawCost:0.9,deqFastCost:0.9,deq:function(G,K,J){return G.dequeue(K,J)},onDeqd:function(G,K){for(var J=0;J<G.onDequeues.length;J++){var ee=G.onDequeues[J];ee(K)}},shouldRedraw:function(G,K,J,ee){for(var te=0;te<K.length;te++){var ae=K[te].bb;if(D.boundingBoxesIntersect(ae,ee))return!0}return!1},priority:function(G){return G.renderer.beforeRenderPriorities.eleTxrDeq}}),_.exports=U},{"../../../heap":81,"../../../math":84,"../../../util":99,"./texture-cache-defs":77}],73:[function(E,_){"use strict";var D=E("../../../is"),T={};T.createBuffer=function(I,L){var O=document.createElement("canvas");// eslint-disable-line no-undef
return O.width=I,O.height=L,[O,O.getContext("2d")]},T.bufferCanvasImage=function(I){var L=this.cy,O=L.mutableElements(),R=O.boundingBox(),F=I.full?Math.ceil(R.w):this.container.clientWidth,$=I.full?Math.ceil(R.h):this.container.clientHeight,M=D.number(I.maxWidth)||D.number(I.maxHeight),U=this.getPixelRatio(),Z=1;if(I.scale!==void 0)F*=I.scale,$*=I.scale,Z=I.scale;else if(M){var G=1/0,K=1/0;D.number(I.maxWidth)&&(G=Z*I.maxWidth/F),D.number(I.maxHeight)&&(K=Z*I.maxHeight/$),Z=Math.min(G,K),F*=Z,$*=Z}M||(F*=U,$*=U,Z*=U);var J=document.createElement("canvas");// eslint-disable-line no-undef
J.width=F,J.height=$,J.style.width=F+"px",J.style.height=$+"px";var ee=J.getContext("2d");// Rasterize the layers, but only if container has nonzero size
if(0<F&&0<$){ee.clearRect(0,0,F,$),I.bg&&(ee.fillStyle=I.bg,ee.rect(0,0,F,$),ee.fill()),ee.globalCompositeOperation="source-over";var te=this.getCachedZSortedEles();if(I.full)ee.translate(-R.x1*Z,-R.y1*Z),ee.scale(Z,Z),this.drawElements(ee,te);else{// draw the current view
var ae=L.pan(),ne={x:ae.x*Z,y:ae.y*Z};Z*=L.zoom(),ee.translate(ne.x,ne.y),ee.scale(Z,Z),this.drawElements(ee,te)}}return J},T.png=function(I){return this.bufferCanvasImage(I).toDataURL("image/png")},T.jpg=function(I){return this.bufferCanvasImage(I).toDataURL("image/jpeg")},_.exports=T},{"../../../is":83}],74:[function(E,_){/*
The canvas renderer was written by Yue Dong.

Modifications tracked on Github.
*/"use strict";function D($){var M=this;M.data={canvases:Array(R.CANVAS_LAYERS),contexts:Array(R.CANVAS_LAYERS),canvasNeedsRedraw:Array(R.CANVAS_LAYERS),bufferCanvases:Array(R.BUFFER_COUNT),bufferContexts:Array(R.CANVAS_LAYERS)},M.data.canvasContainer=document.createElement("div");// eslint-disable-line no-undef
var U=M.data.canvasContainer.style;M.data.canvasContainer.setAttribute("style","-webkit-tap-highlight-color: rgba(0,0,0,0);"),U.position="relative",U.zIndex="0",U.overflow="hidden";var Z=$.cy.container();Z.appendChild(M.data.canvasContainer),Z.setAttribute("style",(Z.getAttribute("style")||"")+"-webkit-tap-highlight-color: rgba(0,0,0,0);");for(var G=0;G<R.CANVAS_LAYERS;G++){var K=M.data.canvases[G]=document.createElement("canvas");// eslint-disable-line no-undef
M.data.contexts[G]=K.getContext("2d"),K.setAttribute("style","-webkit-user-select: none; -moz-user-select: -moz-none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0); outline-style: none;"+(I.ms()?" -ms-touch-action: none; touch-action: none; ":"")),K.style.position="absolute",K.setAttribute("data-id","layer"+G),K.style.zIndex=R.CANVAS_LAYERS-G+"",M.data.canvasContainer.appendChild(K),M.data.canvasNeedsRedraw[G]=!1}M.data.topCanvas=M.data.canvases[0],M.data.canvases[R.NODE].setAttribute("data-id","layer"+R.NODE+"-node"),M.data.canvases[R.SELECT_BOX].setAttribute("data-id","layer"+R.SELECT_BOX+"-selectbox"),M.data.canvases[R.DRAG].setAttribute("data-id","layer"+R.DRAG+"-drag");for(var G=0;G<R.BUFFER_COUNT;G++)M.data.bufferCanvases[G]=document.createElement("canvas"),M.data.bufferContexts[G]=M.data.bufferCanvases[G].getContext("2d"),M.data.bufferCanvases[G].style.position="absolute",M.data.bufferCanvases[G].setAttribute("data-id","buffer"+G),M.data.bufferCanvases[G].style.zIndex=-G-1+"",M.data.bufferCanvases[G].style.visibility="hidden";M.pathsEnabled=!0,M.data.eleTxrCache=new L(M),M.data.lyrTxrCache=new O(M,M.data.eleTxrCache),M.onUpdateEleCalcs(function(ee,te){for(var ae=0;ae<te.length;ae++){var ne=te[ae],re=ne._private.rstyle,oe=re.dirtyEvents;ne.isNode()&&oe&&1===oe.length&&oe.position||M.data.eleTxrCache.invalidateElement(ne)}0<te.length&&M.data.lyrTxrCache.invalidateElements(te)})}var T=E("../../../util"),I=E("../../../is"),L=E("./ele-texture-cache"),O=E("./layered-texture-cache"),R=D.prototype;R.CANVAS_LAYERS=3,R.SELECT_BOX=0,R.DRAG=1,R.NODE=2,R.BUFFER_COUNT=3,R.TEXTURE_BUFFER=0,R.MOTIONBLUR_BUFFER_NODE=1,R.MOTIONBLUR_BUFFER_DRAG=2,R.redrawHint=function($,M){var U=this;"eles"===$?U.data.canvasNeedsRedraw[R.NODE]=M:"drag"===$?U.data.canvasNeedsRedraw[R.DRAG]=M:"select"===$?U.data.canvasNeedsRedraw[R.SELECT_BOX]=M:void 0};// whether to use Path2D caching for drawing
var F="undefined"!=typeof Path2D;R.path2dEnabled=function($){return void 0===$?this.pathsEnabled:void(this.pathsEnabled=!!$)},R.usePaths=function(){return F&&this.pathsEnabled},[E("./arrow-shapes"),E("./drawing-elements"),E("./drawing-edges"),E("./drawing-images"),E("./drawing-label-text"),E("./drawing-nodes"),E("./drawing-redraw"),E("./drawing-shapes"),E("./export-image"),E("./node-shapes")].forEach(function($){T.extend(R,$)}),_.exports=D},{"../../../is":83,"../../../util":99,"./arrow-shapes":64,"./drawing-edges":65,"./drawing-elements":66,"./drawing-images":67,"./drawing-label-text":68,"./drawing-nodes":69,"./drawing-redraw":70,"./drawing-shapes":71,"./ele-texture-cache":72,"./export-image":73,"./layered-texture-cache":75,"./node-shapes":76}],75:[function(E,_){"use strict";function D(ae,ne){null==ae.imageSmoothingEnabled?(ae.webkitImageSmoothingEnabled=ne,ae.mozImageSmoothingEnabled=ne,ae.msImageSmoothingEnabled=ne):ae.imageSmoothingEnabled=ne}var T=E("../../../util"),I=E("../../../math"),L=E("../../../heap"),O=E("../../../is"),R=E("./texture-cache-defs"),F=1,$=-4,M=2,U=!0,Z=250,G=!0,K=function(ae,ne){var re=this,oe=re.renderer=ae;re.layersByLevel={},re.firstGet=!0,re.lastInvalidationTime=T.performanceNow()-2*Z,re.skipping=!1,oe.beforeRender(function(se,le){re.skipping=!!(le-re.lastInvalidationTime<=Z)}),re.layersQueue=new L(function(se,le){return le.reqs-se.reqs}),re.eleTxrCache=ne,re.setupEleCacheInvalidation(),re.setupDequeueing()},J=K.prototype,ee=0,te=Math.pow(2,53)-1;// default number of layers to use
// when scaling smaller than that we don't need to re-render
// time to debounce sharper ele texture updates
// when larger than this scale just render directly (caching is not helpful)
// beyond this zoom level, layered textures are not used
// time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile
// number of eles to dequeue and render at higher texture in each batch
// when drawing eles on layers from an ele cache ; crisper and more performant when true
// % of add'l rendering cost allowed for dequeuing ele caches each frame
// % of add'l rendering cost compared to average overall redraw time
// % of avg frame time that can be used for dequeueing when not drawing
// % of frame time to be used when >60fps
// whether to use high quality ele txr requests (generally faster and cheaper in the longterm)
// time threshold for disabling b/c of invalidations
// layers can't be bigger than this
// never draw all the layers in a level on a frame; draw directly until all dequeued
// whether to use individual ele texture caching underneath this cache
// var log = function(){ console.log.apply( console, arguments ); };
J.makeLayer=function(ae,ne){var re=Math.pow(2,ne),oe=Math.ceil(ae.w*re),se=Math.ceil(ae.h*re),le=document.createElement("canvas");le.width=oe,le.height=se;var pe={id:ee=++ee%te,bb:ae,level:ne,width:oe,height:se,canvas:le,context:le.getContext("2d"),eles:[],elesQueue:[],reqs:0},ue=pe.context,ge=-pe.bb.x1,ce=-pe.bb.y1;// log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);
// do the transform on creation to save cycles (it's the same for all eles)
return ue.scale(re,re),ue.translate(ge,ce),pe},J.getLayers=function(ae,ne,re){var oe=this,se=oe.renderer,le=se.cy,pe=le.zoom(),ue=oe.firstGet;// log('--\nget layers with %s eles', eles.length);
//log eles.map(function(ele){ return ele.id() }) );
if(oe.firstGet=!1,null==re)if(re=Math.ceil(I.log2(pe*ne)),re<$)re=$;else if(3.99<=pe||re>M)return null;oe.validateLayersElesOrdering(re,ae);var ge=oe.layersByLevel,ce=Math.pow(2,re),he=ge[re]=ge[re]||[],me=oe.levelIsComplete(re,ae),xe=function(){var ke=function(Be){if(oe.validateLayersElesOrdering(Be,ae),oe.levelIsComplete(Be,ae))return fe=ge[Be],!0},Ie=function(Be){if(!fe)for(var Le=re+Be;$<=Le&&Le<=M&&!ke(Le);Le+=Be);};Ie(1),Ie(-1);// remove the invalid layers; they will be replaced as needed later in this function
for(var Ne=he.length-1;0<=Ne;Ne--){var ze=he[Ne];ze.invalid&&T.removeFromArray(he,ze)}},ye,fe;if(!me)xe();else// log('level complete, using existing layers\n--');
return he;var ve=function(){if(!ye){ye=I.makeBoundingBox();for(var ke=0;ke<ae.length;ke++)I.updateBoundingBox(ye,ae[ke].boundingBox())}return ye},be=function(ke){ke=ke||{};var Ie=ke.after;ve();var Ne=ye.w*ce*(ye.h*ce);if(16000000<Ne)return null;var ze=oe.makeLayer(ye,re);if(null!=Ie){var Be=he.indexOf(Ie)+1;he.splice(Be,0,ze)}else(void 0===ke.insert||ke.insert)&&he.unshift(ze);// if( tmpLayers ){
//self.queueLayer( layer );
// }
return ze};if(oe.skipping&&!ue)// log('skip layers');
return null;// log('do layers');
var we=null,Ee=ae.length/F,Se=!ue;for(var _e=0;_e<ae.length;_e++){var Pe=ae[_e],Ce=Pe._private.rscratch,De=Ce.imgLayerCaches=Ce.imgLayerCaches||{},Te=De[re];// log('look at ele', ele.id());
if(Te){we=Te;continue}if((!we||we.eles.length>=Ee||1<F)&&(we=be({insert:!0,after:we}),!we))return null;fe||Se?oe.queueLayer(we,Pe):oe.drawEleInLayer(we,Pe,re,ne),we.eles.push(Pe),De[re]=we}// log('--');
return fe?fe:Se?null:he},J.getEleLevelForLayerLevel=function(ae){return ae},J.drawEleInLayer=function(ae,ne,re,oe){var se=this,le=this.renderer,pe=ae.context,ue=ne.boundingBox();if(0!==ue.w&&0!==ue.h){var ge=se.eleTxrCache,ce=ge.reasons.highQuality;re=se.getEleLevelForLayerLevel(re,oe);var he=ge.getElement(ne,ue,null,re,ce);he?(D(pe,!1),pe.drawImage(he.texture.canvas,he.x,0,he.width,he.height,ue.x1,ue.y1,ue.w,ue.h),D(pe,!0)):le.drawElement(pe,ne)}},J.levelIsComplete=function(ae,ne){var re=this,oe=re.layersByLevel[ae];if(!oe||0===oe.length)return!1;var se=0;for(var le=0;le<oe.length;le++){var pe=oe[le];// if there are any eles needed to be drawn yet, the level is not complete
if(0<pe.reqs)return!1;// if the layer is invalid, the level is not complete
if(pe.invalid)return!1;se+=pe.eles.length}// we should have exactly the number of eles passed in to be complete
return!(se!==ne.length)},J.validateLayersElesOrdering=function(ae,ne){var re=this.layersByLevel[ae];if(re)// if in a layer the eles are not in the same order, then the layer is invalid
// (i.e. there is an ele in between the eles in the layer)
for(var oe=0;oe<re.length;oe++){var se=re[oe],le=-1;// find the offset
for(var pe=0;pe<ne.length;pe++)if(se.eles[0]===ne[pe]){le=pe;break}if(0>le){this.invalidateLayer(se);continue}// the eles in the layer must be in the same continuous order, else the layer is invalid
var ue=le;for(var pe=0;pe<se.eles.length;pe++)if(se.eles[pe]!==ne[ue+pe]){this.invalidateLayer(se);break}}},J.updateElementsInLayers=function(ae,ne){var re=this,oe=O.element(ae[0]);// collect udpated elements (cascaded from the layers) and update each
// layer itself along the way
for(var se=0;se<ae.length;se++){var le=oe?null:ae[se],pe=oe?ae[se]:ae[se].ele,ue=pe._private.rscratch,ge=ue.imgLayerCaches=ue.imgLayerCaches||{};for(var ce=$;ce<=M;ce++){var he=ge[ce];he&&(le&&re.getEleLevelForLayerLevel(he.level)!==le.level||ne(he,pe,le));// if update is a request from the ele cache, then it affects only
// the matching level
}}},J.haveLayers=function(){var ae=this,ne=!1;for(var re=$;re<=M;re++){var oe=ae.layersByLevel[re];if(oe&&0<oe.length){ne=!0;break}}return ne},J.invalidateElements=function(ae){var ne=this;ne.lastInvalidationTime=T.performanceNow();// log('update invalidate layer time from eles');
0!==ae.length&&ne.haveLayers()&&ne.updateElementsInLayers(ae,function(oe){ne.invalidateLayer(oe)})},J.invalidateLayer=function(ae){if(this.lastInvalidationTime=T.performanceNow(),!ae.invalid){// save cycles
var ne=ae.level,re=ae.eles,oe=this.layersByLevel[ne];T.removeFromArray(oe,ae),ae.elesQueue=[],ae.invalid=!0,ae.replacement&&(ae.replacement.invalid=!0);for(var se=0;se<re.length;se++){var le=re[se]._private.rscratch.imgLayerCaches;le&&(le[ne]=null)}}// log('invalidate layer', layer.id );
},J.refineElementTextures=function(ae){var ne=this;// log('refine', eles.length);
ne.updateElementsInLayers(ae,function(oe){var se=oe.replacement;if(se||(se=oe.replacement=ne.makeLayer(oe.bb,oe.level),se.replaces=oe,se.eles=oe.eles),!se.reqs)for(var le=0;le<se.eles.length;le++)ne.queueLayer(se,se.eles[le]);// log('queue replacement layer refinement', rLyr.id);
})},J.setupEleCacheInvalidation=function(){var ae=this,ne=[],re=T.debounce(function(){ae.refineElementTextures(ne),ne=[]},50);ae.eleTxrCache.onDequeue(function(oe){for(var se=0;se<oe.length;se++)ne.push(oe[se]);re()})},J.queueLayer=function(ae,ne){var re=this,oe=re.layersQueue,se=ae.elesQueue,le=se.hasId=se.hasId||{};// if a layer is going to be replaced, queuing is a waste of time
if(!ae.replacement){if(ne){if(le[ne.id()])return;se.push(ne),le[ne.id()]=!0}ae.reqs?(ae.reqs++,oe.updateItem(ae)):(ae.reqs=1,oe.push(ae))}},J.dequeue=function(ae){for(var ne=this,re=ne.layersQueue,oe=[],se=0;1>se&&!(0===re.size());){var le=re.peek();// if a layer has been or will be replaced, then don't waste time with it
if(le.replacement){re.pop();continue}// if this is a replacement layer that has been superceded, then forget it
if(le.replaces&&le!==le.replaces.replacement){re.pop();continue}if(le.invalid){re.pop();continue}var pe=le.elesQueue.shift();pe&&(ne.drawEleInLayer(le,pe,le.level,ae),se++),0===oe.length&&oe.push(!0),0===le.elesQueue.length&&(re.pop(),le.reqs=0,le.replaces&&ne.applyLayerReplacement(le),ne.requestRedraw())}return oe},J.applyLayerReplacement=function(ae){var ne=this,re=ne.layersByLevel[ae.level],oe=ae.replaces,se=re.indexOf(oe);// if the replaced layer is not in the active list for the level, then replacing
// refs would be a mistake (i.e. overwriting the true active layer)
if(!(0>se||oe.invalid)){re[se]=ae;// replace level ref
// replace refs in eles
for(var le=0;le<ae.eles.length;le++){var pe=ae.eles[le]._private,ue=pe.imgLayerCaches=pe.imgLayerCaches||{};ue&&(ue[ae.level]=ae)}// log('apply replacement layer %s over %s', layer.id, replaced.id);
ne.requestRedraw()}},J.requestRedraw=T.debounce(function(){var ae=this.renderer;ae.redrawHint("eles",!0),ae.redrawHint("drag",!0),ae.redraw()},100),J.setupDequeueing=R.setupDequeueing({deqRedrawThreshold:50,deqCost:0.15,deqAvgCost:0.1,deqNoDrawCost:0.9,deqFastCost:0.9,deq:function(ae,ne){return ae.dequeue(ne)},onDeqd:T.noop,shouldRedraw:T.trueify,priority:function(ae){return ae.renderer.beforeRenderPriorities.lyrTxrDeq}}),_.exports=K},{"../../../heap":81,"../../../is":83,"../../../math":84,"../../../util":99,"./texture-cache-defs":77}],76:[function(E,_){"use strict";var D={};D.nodeShapeImpl=function(T,I,L,O,R,F,$){return"ellipse"===T?this.drawEllipsePath(I,L,O,R,F):"polygon"===T?this.drawPolygonPath(I,L,O,R,F,$):"roundrectangle"===T?this.drawRoundRectanglePath(I,L,O,R,F):void 0},_.exports=D},{}],77:[function(E,_){"use strict";var D=E("../../../util"),T=1000/30;// assume 60 frames per second
_.exports={setupDequeueing:function(I){return function(){var O=this,R=this.renderer;if(!O.dequeueingSetup){O.dequeueingSetup=!0;var F=D.debounce(function(){R.redrawHint("eles",!0),R.redrawHint("drag",!0),R.redraw()},I.deqRedrawThreshold),$=I.priority||D.noop;R.beforeRender(function(M,U){for(var Z=D.performanceNow(),G=R.averageRedrawTime,K=R.lastRedrawTime,J=[],ee=R.cy.extent(),te=R.getPixelRatio();!0;){var ae=D.performanceNow(),ne=ae-Z,re=ae-U;if(K<T){// if we're rendering faster than the ideal fps, then do dequeueing
// during all of the remaining frame time
var oe=T-(M?G:0);if(re>=I.deqFastCost*oe)break}else if(M){if(ne>=I.deqCost*K||ne>=I.deqAvgCost*G)break;}else if(re>=I.deqNoDrawCost*T)break;var se=I.deq(O,te,ee);if(0<se.length)for(var le=0;le<se.length;le++)J.push(se[le]);else break}// callbacks on dequeue
0<J.length&&(I.onDeqd(O,J),!M&&I.shouldRedraw(O,J,te,ee)&&F())},$(O))}}}}},{"../../../util":99}],78:[function(E,_){"use strict";_.exports=[{name:"null",impl:E("./null")},{name:"base",impl:E("./base")},{name:"canvas",impl:E("./canvas")}]},{"./base":60,"./canvas":74,"./null":79}],79:[function(E,_){"use strict";function D(I){this.options=I,this.notifications=0}var T=function(){};D.prototype={recalculateRenderedStyle:T,notify:function(){this.notifications++},init:T},_.exports=D},{}],80:[function(E,_){/*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */"use strict";var D=E("./is"),T=E("./util"),I=E("./thread"),L=E("./promise"),O=E("./define"),R=function(U){if(!(this instanceof R))return new R(U);if(this._private={pass:[]},D.number(U),"undefined"!=typeof navigator&&null!=navigator.hardwareConcurrency)U=navigator.hardwareConcurrency;else try{U=E("os").cpus().length}catch(G){U=4}// TODO could use an estimation here but would the additional expense be worth it?
for(var Z=0;Z<U;Z++)this[Z]=new I;this.length=U},F=R.prototype;// short alias
T.extend(F,{instanceString:function(){return"fabric"},// require fn in all threads
require:function(U,Z){for(var G=0;G<this.length;G++){var K=this[G];K.require(U,Z)}return this},// get a random thread
random:function(){var U=Math.round((this.length-1)*Math.random()),Z=this[U];return Z},// run on random thread
run:function(U){var Z=this._private.pass.shift();return this.random().pass(Z).run(U)},// sends a random thread a message
message:function(U){return this.random().message(U)},// send all threads a message
broadcast:function(U){for(const Z of this)Z.message(U);// for( var i = 0; i < this.length; i++ ){
//   var thread = this[i];
//
//   thread.message( m );
// }
return this;// chaining
},// stop all threads
stop:function(){for(var U=0;U<this.length;U++){var Z=this[U];Z.stop()}return this;// chaining
},// pass data to be used with .spread() etc.
pass:function(U){var Z=this._private.pass;if(D.array(U))Z.push(U);else throw"Only arrays may be used with fabric.pass()";return this;// chaining
},spreadSize:function(){var U=Math.ceil(this._private.pass[0].length/this.length);// don't pass less than one ele to each thread
return U=Math.max(1,U),U},// split the data into slices to spread the data equally among threads
spread:function(U){var Z=this,G=Z._private,K=Z.spreadSize(),J=G.pass.shift().concat([]),ee=[];// number of pass eles to handle in each thread
// keep a copy
for(var te=0;te<this.length;te++){var ae=this[te],ne=J.splice(0,K),re=ae.pass(ne).run(U);ee.push(re);var oe=0===J.length;if(oe)break}return L.all(ee).then(function(se){var le=[],pe=0;// fill postpass with the total result joined from all threads
for(var ue=0;ue<se.length;ue++){var ge=se[ue];// array result from thread i
for(var ce=0;ce<ge.length;ce++){var he=ge[ce];// array element
le[pe++]=he}}return le})},// parallel version of array.map()
map:function(U){var Z=this;return Z.require(U,"_$_$_fabmap"),Z.spread(function(G){var K=[],J=resolve;resolve=function(re){K.push(re)};for(var ee=0;ee<G.length;ee++){var te=K.length,ae=_$_$_fabmap(G[ee]),ne=te===K.length;// jshint ignore:line
ne&&K.push(ae)}// jshint ignore:line
return resolve=J,K})},// parallel version of array.filter()
filter:function(U){var Z=this._private,G=Z.pass[0];return this.map(U).then(function(K){var J=[];for(var ee=0;ee<G.length;ee++){var te=G[ee],ae=K[ee];ae&&J.push(te)}return J})},// sorts the passed array using a divide and conquer strategy
sort:function(U){var Z=this,G=this._private.pass[0].length,K=this.spreadSize();return U=U||function(J,ee){// default comparison function
return J<ee?-1:J>ee?1:0},Z.require(U,"_$_$_cmp"),Z.spread(function(J){// sort each split normally
var ee=J.sort(_$_$_cmp);// jshint ignore:line
resolve(ee)}).then(function(J){// do all the merging in the main thread to minimise data transfer
// TODO could do merging in separate threads but would incur add'l cost of data transfer
// for each level of the merge
var ee=function(ne,re,oe){re=Math.min(re,G),oe=Math.min(oe,G);// left and right sides of merge
var se=ne,le=re,pe=[];for(var ue=se;ue<oe;ue++){var ge=J[ne],ce=J[re];ne<le&&(re>=oe||0>=U(ge,ce))?(pe.push(ge),ne++):(pe.push(ce),re++)}// in the array proper, put the sorted values
for(var ue=0;ue<pe.length;ue++){// kth sorted item
var he=se+ue;J[he]=pe[ue]}};for(var te=K;te<G;te*=2)// merge until array is "split" as 1
for(var ae=0;ae<G;ae+=2*te)ee(ae,ae+te,ae+2*te);return J})}});var $=function(U){return U=U||{},function(Z,G){var K=this._private.pass.shift();return this.random().pass(K)[U.threadFn](Z,G)}};T.extend(F,{randomMap:$({threadFn:"map"}),reduce:$({threadFn:"reduce"}),reduceRight:$({threadFn:"reduceRight"})});// aliases
var M=F;M.promise=M.run,M.terminate=M.halt=M.stop,M.include=M.require,T.extend(F,{on:O.on(),one:O.on({unbindSelfOnTrigger:!0}),off:O.off(),trigger:O.trigger()}),O.eventAliasesOn(F),_.exports=R},{"./define":44,"./is":83,"./promise":85,"./thread":97,"./util":99,os:void 0}],81:[function(E,_){/*!
Ported by Xueqiao Xu <xueqiaoxu@gmail.com>;

PSF LICENSE AGREEMENT FOR PYTHON 2.7.2

1. This LICENSE AGREEMENT is between the Python Software Foundation (“PSF”), and the Individual or Organization (“Licensee”) accessing and otherwise using Python 2.7.2 software in source or binary form and its associated documentation.
2. Subject to the terms and conditions of this License Agreement, PSF hereby grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce, analyze, test, perform and/or display publicly, prepare derivative works, distribute, and otherwise use Python 2.7.2 alone or in any derivative version, provided, however, that PSF’s License Agreement and PSF’s notice of copyright, i.e., “Copyright © 2001-2012 Python Software Foundation; All Rights Reserved” are retained in Python 2.7.2 alone or in any derivative version prepared by Licensee.
3. In the event Licensee prepares a derivative work that is based on or incorporates Python 2.7.2 or any part thereof, and wants to make the derivative work available to others as provided herein, then Licensee hereby agrees to include in any such work a brief summary of the changes made to Python 2.7.2.
4. PSF is making Python 2.7.2 available to Licensee on an “AS IS” basis. PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 2.7.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 2.7.2 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 2.7.2, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
6. This License Agreement will automatically terminate upon a material breach of its terms and conditions.
7. Nothing in this License Agreement shall be deemed to create any relationship of agency, partnership, or joint venture between PSF and Licensee. This License Agreement does not grant permission to use PSF trademarks or trade name in a trademark sense to endorse or promote products or services of Licensee, or any third party.
8. By copying, installing or otherwise using Python 2.7.2, Licensee agrees to be bound by the terms and conditions of this License Agreement.
*/"use strict";// Generated by CoffeeScript 1.8.0
var D,T,I,L,O,R,F,$,M,U,Z,G,K,J,ee;I=Math.floor,U=Math.min,T=function(te,ae){return te<ae?-1:te>ae?1:0},M=function(te,ae,ne,re,oe){var se;if(null==ne&&(ne=0),null==oe&&(oe=T),0>ne)throw new Error("lo must be non-negative");for(null==re&&(re=te.length);ne<re;)se=I((ne+re)/2),0>oe(ae,te[se])?re=se:ne=se+1;return[].splice.apply(te,[ne,ne-ne].concat(ae)),ae},R=function(te,ae,ne){return null==ne&&(ne=T),te.push(ae),J(te,0,te.length-1,ne)},O=function(te,ae){var ne,re;return null==ae&&(ae=T),ne=te.pop(),te.length?(re=te[0],te[0]=ne,ee(te,0,ae)):re=ne,re},$=function(te,ae,ne){var re;return null==ne&&(ne=T),re=te[0],te[0]=ae,ee(te,0,ne),re},F=function(te,ae,ne){var re;return null==ne&&(ne=T),te.length&&0>ne(te[0],ae)&&(re=[te[0],ae],ae=re[0],te[0]=re[1],ee(te,0,ne)),ae},L=function(te,ae){var ne,re,oe,se,le,pe;for(null==ae&&(ae=T),se=function(){pe=[];for(var ue=0,ge=I(te.length/2);0<=ge?ue<ge:ue>ge;0<=ge?ue++:ue--)pe.push(ue);return pe}.apply(this).reverse(),le=[],(re=0,oe=se.length);re<oe;re++)ne=se[re],le.push(ee(te,ne,ae));return le},K=function(te,ae,ne){var re;if(null==ne&&(ne=T),re=te.indexOf(ae),-1!==re)return J(te,0,re,ne),ee(te,re,ne)},Z=function(te,ae,ne){var re,oe,se,le,pe;if(null==ne&&(ne=T),oe=te.slice(0,ae),!oe.length)return oe;for(L(oe,ne),pe=te.slice(ae),(se=0,le=pe.length);se<le;se++)re=pe[se],F(oe,re,ne);return oe.sort(ne).reverse()},G=function(te,ae,ne){var re,oe,se,le,pe,ue,ge,ce,he,ye;if(null==ne&&(ne=T),10*ae<=te.length){if(le=te.slice(0,ae).sort(ne),!le.length)return le;for(se=le[le.length-1],ce=te.slice(ae),(pe=0,ge=ce.length);pe<ge;pe++)re=ce[pe],0>ne(re,se)&&(M(le,re,0,null,ne),le.pop(),se=le[le.length-1]);return le}for(L(te,ne),ye=[],(oe=ue=0,he=U(ae,te.length));0<=he?ue<he:ue>he;oe=0<=he?++ue:--ue)ye.push(O(te,ne));return ye},J=function(te,ae,ne,re){var oe,se,le;for(null==re&&(re=T),oe=te[ne];ne>ae;){if(le=ne-1>>1,se=te[le],0>re(oe,se)){te[ne]=se,ne=le;continue}break}return te[ne]=oe},ee=function(te,ae,ne){var re,oe,se,le,pe;for(null==ne&&(ne=T),oe=te.length,pe=ae,se=te[ae],re=2*ae+1;re<oe;)le=re+1,le<oe&&!(0>ne(te[re],te[le]))&&(re=le),te[ae]=te[re],ae=re,re=2*ae+1;return te[ae]=se,J(te,pe,ae,ne)},D=function(){function te(ae){this.cmp=null==ae?T:ae,this.nodes=[]}return te.push=R,te.pop=O,te.replace=$,te.pushpop=F,te.heapify=L,te.updateItem=K,te.nlargest=Z,te.nsmallest=G,te.prototype.push=function(ae){return R(this.nodes,ae,this.cmp)},te.prototype.pop=function(){return O(this.nodes,this.cmp)},te.prototype.peek=function(){return this.nodes[0]},te.prototype.contains=function(ae){return-1!==this.nodes.indexOf(ae)},te.prototype.replace=function(ae){return $(this.nodes,ae,this.cmp)},te.prototype.pushpop=function(ae){return F(this.nodes,ae,this.cmp)},te.prototype.heapify=function(){return L(this.nodes,this.cmp)},te.prototype.updateItem=function(ae){return K(this.nodes,ae,this.cmp)},te.prototype.clear=function(){return this.nodes=[]},te.prototype.empty=function(){return 0===this.nodes.length},te.prototype.size=function(){return this.nodes.length},te.prototype.clone=function(){var ae=new te;return ae.nodes=this.nodes.slice(0),ae},te.prototype.toArray=function(){return this.nodes.slice(0)},te.prototype.insert=te.prototype.push,te.prototype.top=te.prototype.peek,te.prototype.front=te.prototype.peek,te.prototype.has=te.prototype.contains,te.prototype.copy=te.prototype.clone,te}(),_.exports=D},{}],82:[function(E,_){"use strict";E("./-preamble"),E("./window");var D=E("./is"),T=E("./core"),I=E("./extension"),L=E("./stylesheet"),O=E("./thread"),R=E("./fabric"),F=function($){// create instance
return(void 0===$&&($={}),D.plainObject($))?new T($):D.string($)?I.apply(I,arguments):void 0;// allow for registration of extensions
};// replaced by build system
F.version=E("./version.json"),F.stylesheet=F.Stylesheet=L,F.thread=F.Thread=O,F.fabric=F.Fabric=R,_.exports=F},{"./-preamble":1,"./core":37,"./extension":46,"./fabric":80,"./is":83,"./stylesheet":96,"./thread":97,"./version.json":105,"./window":106}],83:[function(E,_){"use strict";/*global HTMLElement DocumentTouch */const D=E("./window"),T=D?D.navigator:null,I=D?D.document:null,L="function",O=typeof HTMLElement,R=O===void 0;var F=function(M){return M&&M.instanceString&&$.fn(M.instanceString)?M.instanceString():null},$={defined:function(M){return null!=M;// not undefined or null
},string:function(M){return null!==M&&"string"==typeof M},fn:function(M){return null!==M&&typeof M==L},array:function(M){//return Array.isArray ? Array.isArray( obj ) : obj !== null &&
return M instanceof Array},plainObject:function(M){//return obj !== null && typeof obj === typeofobj
return M instanceof Object&&!$.array(M)&&M.constructor===Object},object:function(M){//return obj !== null && typeof obj === typeofobj;
return M instanceof Object},number:function(M){return"number"==typeof M&&!Number.isNaN(M)},integer:function(M){return $.number(M)&&Math.floor(M)===M},bool:function(M){return!0===M||!1===M;//return obj !== null && typeof obj === typeof true;
},htmlElement:function(M){return"undefined"==O?void 0:M instanceof HTMLElement},elementOrCollection:function(M){return $.element(M)||$.collection(M)},element:function(M){return"collection"===F(M)&&M._private.single},collection:function(M){return"collection"===F(M)&&!M._private.single},core:function(M){return"core"===F(M)},style:function(M){return"style"===F(M)},stylesheet:function(M){return"stylesheet"===F(M)},event:function(M){return"event"===F(M)},thread:function(M){return"thread"===F(M)},fabric:function(M){return"fabric"===F(M)},emptyString:function(M){if(M===void 0||null===M)// null is empty
return!0;// otherwise, we don't know what we've got
return""===M||M.match(/^\s+$/)},nonemptyString:function(M){return M&&$.string(M)&&""!==M&&!M.match(/^\s+$/)},domElement:function(M){return!R&&M instanceof HTMLElement},boundingBox:function(M){return $.plainObject(M)&&$.number(M.x1)&&$.number(M.x2)&&$.number(M.y1)&&$.number(M.y2)},promise:function(M){return $.object(M)&&$.fn(M.then)},touch:function(){return D&&("ontouchstart"in D||D.DocumentTouch&&I instanceof DocumentTouch)},gecko:function(){return D&&("undefined"!=typeof InstallTrigger||"MozAppearance"in I.documentElement.style)},webkit:function(){return D&&("undefined"!=typeof webkitURL||"WebkitAppearance"in I.documentElement.style)},chromium:function(){return D&&"undefined"!=typeof chrome},khtml:function(){return T&&T.vendor.match(/kde/i);// probably a better way to detect this...
},khtmlEtc:function(){return $.khtml()||$.webkit()||$.chromium()},ms:function(){return T&&T.userAgent.match(/msie|trident|edge/i);// probably a better way to detect this...
},windows:function(){return T&&T.appVersion.match(/Win/i)},mac:function(){return T&&T.appVersion.match(/Mac/i)},linux:function(){return T&&T.appVersion.match(/Linux/i)},unix:function(){return T&&T.appVersion.match(/X11/i)}};_.exports=$},{"./window":106}],84:[function(E,_){"use strict";var D={};D.arePositionsSame=function(T,I){return T.x===I.x&&T.y===I.y},D.copyPosition=function(T){return{x:T.x,y:T.y}},D.array2point=function(T){return{x:T[0],y:T[1]}},D.deg2rad=function(T){return Math.PI*T/180},D.log2=Math.log2||function(T){return Math.log(T)/Math.log(2)},D.signum=function(T){if(0<T)return 1;return 0>T?-1:0},D.dist=function(T,I){return Math.sqrt(D.sqdist(T,I))},D.sqdist=function(T,I){var L=I.x-T.x,O=I.y-T.y;return L*L+O*O},D.qbezierAt=function(T,I,L,O){return(1-O)*(1-O)*T+2*(1-O)*O*I+O*O*L},D.qbezierPtAt=function(T,I,L,O){return{x:D.qbezierAt(T.x,I.x,L.x,O),y:D.qbezierAt(T.y,I.y,L.y,O)}},D.lineAt=function(T,I,L,O){var R={x:I.x-T.x,y:I.y-T.y},F=D.dist(T,I),$={x:R.x/F,y:R.y/F};L=null==L?0:L;var O=null==O?L*F:O;return{x:T.x+$.x*O,y:T.y+$.y*O}},D.lineAtDist=function(T,I,L){return D.lineAt(T,I,void 0,L)},D.triangleAngle=function(T,I,L){var O=D.dist(I,L),R=D.dist(T,L),F=D.dist(T,I);return Math.acos((O*O+R*R-F*F)/(2*O*R))},D.bound=function(T,I,L){return Math.max(T,Math.min(L,I))},D.makeBoundingBox=function(T){if(null==T)return{x1:1/0,y1:1/0,x2:-(1/0),y2:-(1/0),w:0,h:0};if(null!=T.x1&&null!=T.y1){if(null!=T.x2&&null!=T.y2&&T.x2>=T.x1&&T.y2>=T.y1)return{x1:T.x1,y1:T.y1,x2:T.x2,y2:T.y2,w:T.x2-T.x1,h:T.y2-T.y1};if(null!=T.w&&null!=T.h&&0<=T.w&&0<=T.h)return{x1:T.x1,y1:T.y1,x2:T.x1+T.w,y2:T.y1+T.h,w:T.w,h:T.h}}},D.updateBoundingBox=function(T,I){T.x1=Math.min(T.x1,I.x1),T.x2=Math.max(T.x2,I.x2),T.w=T.x2-T.x1,T.y1=Math.min(T.y1,I.y1),T.y2=Math.max(T.y2,I.y2),T.h=T.y2-T.y1},D.expandBoundingBox=function(T,I){return T.x1-=I,T.x2+=I,T.y1-=I,T.y2+=I,T.w=T.x2-T.x1,T.h=T.y2-T.y1,T},D.boundingBoxesIntersect=function(T,I){// case: one bb to right of other
// case: one bb to left of other
// case: one bb above other
// case: one bb below other
// otherwise, must have some overlap
return!(T.x1>I.x2)&&!(I.x1>T.x2)&&!(T.x2<I.x1)&&!(I.x2<T.x1)&&!(T.y2<I.y1)&&!(I.y2<T.y1)&&!(T.y1>I.y2)&&!(I.y1>T.y2)},D.inBoundingBox=function(T,I,L){return T.x1<=I&&I<=T.x2&&T.y1<=L&&L<=T.y2},D.pointInBoundingBox=function(T,I){return this.inBoundingBox(T,I.x,I.y)},D.boundingBoxInBoundingBox=function(T,I){return D.inBoundingBox(T,I.x1,I.y1)&&D.inBoundingBox(T,I.x2,I.y2)},D.roundRectangleIntersectLine=function(T,I,L,O,R,F,$){var M=this.getRoundRectangleRadius(R,F),U=R/2,Z=F/2,G;// Check intersections with straight line segments
// Top segment, left to right
{var K=O-Z-$;if(G=this.finiteLinesIntersect(T,I,L,O,L-U+M-$,K,L+U-M+$,K,!1),0<G.length)return G}// Right segment, top to bottom
{var J=L+U+$;if(G=this.finiteLinesIntersect(T,I,L,O,J,O-Z+M-$,J,O+Z-M+$,!1),0<G.length)return G}// Bottom segment, left to right
{var ee=O+Z+$;if(G=this.finiteLinesIntersect(T,I,L,O,L-U+M-$,ee,L+U-M+$,ee,!1),0<G.length)return G}// Left segment, top to bottom
{var te=L-U-$;if(G=this.finiteLinesIntersect(T,I,L,O,te,O-Z+M-$,te,O+Z-M+$,!1),0<G.length)return G}// Check intersections with arc segments
var ae;// Top Left
{var ne=L-U+M,re=O-Z+M;// Ensure the intersection is on the desired quarter of the circle
if(ae=this.intersectLineCircle(T,I,L,O,ne,re,M+$),0<ae.length&&ae[0]<=ne&&ae[1]<=re)return[ae[0],ae[1]]}// Top Right
{var oe=L+U-M,se=O-Z+M;// Ensure the intersection is on the desired quarter of the circle
if(ae=this.intersectLineCircle(T,I,L,O,oe,se,M+$),0<ae.length&&ae[0]>=oe&&ae[1]<=se)return[ae[0],ae[1]]}// Bottom Right
{var le=L+U-M,pe=O+Z-M;// Ensure the intersection is on the desired quarter of the circle
if(ae=this.intersectLineCircle(T,I,L,O,le,pe,M+$),0<ae.length&&ae[0]>=le&&ae[1]>=pe)return[ae[0],ae[1]]}// Bottom Left
{var ue=L-U+M,ge=O+Z-M;// Ensure the intersection is on the desired quarter of the circle
if(ae=this.intersectLineCircle(T,I,L,O,ue,ge,M+$),0<ae.length&&ae[0]<=ue&&ae[1]>=ge)return[ae[0],ae[1]]}return[];// if nothing
},D.inLineVicinity=function(T,I,L,O,R,F,$){var M=$,U=Math.min(L,R),Z=Math.max(L,R),G=Math.min(O,F),K=Math.max(O,F);return U-M<=T&&T<=Z+M&&G-M<=I&&I<=K+M},D.inBezierVicinity=function(T,I,L,O,R,F,$,M,U){var Z={x1:Math.min(L,$,R)-U,x2:Math.max(L,$,R)+U,y1:Math.min(O,M,F)-U,y2:Math.max(O,M,F)+U};// if outside the rough bounding box for the bezier, then it can't be a hit
return T<Z.x1||T>Z.x2||I<Z.y1||I>Z.y2?!1:!0},D.solveCubic=function(T,I,L,O,R){I/=T,L/=T,O/=T;var F,$,M,U,Z,G,K,J;return($=(3*L-I*I)/9,M=-(27*O)+I*(9*L-2*(I*I)),M/=54,F=$*$*$+M*M,R[1]=0,K=I/3,0<F)?(Z=M+Math.sqrt(F),Z=0>Z?-Math.pow(-Z,1/3):Math.pow(Z,1/3),G=M-Math.sqrt(F),G=0>G?-Math.pow(-G,1/3):Math.pow(G,1/3),R[0]=-K+Z+G,K+=(Z+G)/2,R[4]=R[2]=-K,K=Math.sqrt(3)*(-G+Z)/2,R[3]=K,void(R[5]=-K)):(R[5]=R[3]=0,0===F?(J=0>M?-Math.pow(-M,1/3):Math.pow(M,1/3),R[0]=-K+2*J,void(R[4]=R[2]=-(J+K))):void($=-$,U=$*$*$,U=Math.acos(M/Math.sqrt(U)),J=2*Math.sqrt($),R[0]=-K+J*Math.cos(U/3),R[2]=-K+J*Math.cos((U+2*Math.PI)/3),R[4]=-K+J*Math.cos((U+4*Math.PI)/3)))},D.sqdistToQuadraticBezier=function(T,I,L,O,R,F,$,M){// debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);
// Find minimum distance by using the minimum of the distance
// function between the given point and the curve
// This gives the coefficients of the resulting cubic equation
// whose roots tell us where a possible minimum is
// (Coefficients are divided by 4)
var U=[];// Use the cubic solving algorithm
this.solveCubic(1*L*L-4*L*R+2*L*$+4*R*R-4*R*$+$*$+O*O-4*O*F+2*O*M+4*F*F-4*F*M+M*M,9*L*R-3*L*L-3*L*$-6*R*R+3*R*$+9*O*F-3*O*O-3*O*M-6*F*F+3*F*M,3*L*L-6*L*R+L*$-L*T+2*R*R+2*R*T-$*T+3*O*O-6*O*F+O*M-O*I+2*F*F+2*F*I-M*I,1*L*R-L*L+L*T-R*T+O*F-O*O+O*I-F*I,U);var Z=[];for(var G=0;6>G;G+=2)1e-7>Math.abs(U[G+1])&&0<=U[G]&&1>=U[G]&&Z.push(U[G]);Z.push(1),Z.push(0);var K=-1,J,ee,te;for(var ae=0;ae<Z.length;ae++)J=Math.pow(1-Z[ae],2)*L+2*(1-Z[ae])*Z[ae]*R+Z[ae]*Z[ae]*$,ee=Math.pow(1-Z[ae],2)*O+2*(1-Z[ae])*Z[ae]*F+Z[ae]*Z[ae]*M,te=Math.pow(J-T,2)+Math.pow(ee-I,2),0<=K?te<K&&(K=te,Z[ae]):(K=te,Z[ae]);return K},D.sqdistToFiniteLine=function(T,I,L,O,R,F){var $=[T-L,I-O],M=[R-L,F-O],U=M[0]*M[0]+M[1]*M[1],Z=$[0]*$[0]+$[1]*$[1],G=$[0]*M[0]+$[1]*M[1],K=G*G/U;return 0>G?Z:K>U?(T-R)*(T-R)+(I-F)*(I-F):Z-K},D.pointInsidePolygonPoints=function(T,I,L){var O,R,F,$,M,U=0,Z=0;// Intersect with vertical line through (x, y)
for(var G=0;G<L.length/2;G++)if(O=L[2*G],R=L[2*G+1],G+1<L.length/2?(F=L[2*(G+1)],$=L[2*(G+1)+1]):(F=L[2*(G+1-L.length/2)],$=L[2*(G+1-L.length/2)+1]),O==T&&F==T);else if(O>=T&&T>=F||O<=T&&T<=F)M=(T-O)/(F-O)*($-R)+R,M>I&&U++,M<I&&Z++;else continue;return 0!=U%2},D.pointInsidePolygon=function(T,I,L,O,R,F,$,M,U){//var direction = arguments[6];
var Z=Array(L.length),G;// Gives negative angle
null==M[0]?G=M:(G=Math.atan(M[1]/M[0]),G=0>M[0]?G+Math.PI/2:-G-Math.PI/2);var K=Math.cos(-G),J=Math.sin(-G);//    console.log("base: " + basePoints);
for(var ee=0;ee<Z.length/2;ee++)Z[2*ee]=F/2*(L[2*ee]*K-L[2*ee+1]*J),Z[2*ee+1]=$/2*(L[2*ee+1]*K+L[2*ee]*J),Z[2*ee]+=O,Z[2*ee+1]+=R;var te;if(0<U){var ae=this.expandPolygon(Z,-U);te=this.joinLines(ae)}else te=Z;return D.pointInsidePolygonPoints(T,I,te)},D.joinLines=function(T){var I=Array(T.length/2),L,O,R,F,$,M,U,Z;for(var G=0;G<T.length/4;G++){L=T[4*G],O=T[4*G+1],R=T[4*G+2],F=T[4*G+3],G<T.length/4-1?($=T[4*(G+1)],M=T[4*(G+1)+1],U=T[4*(G+1)+2],Z=T[4*(G+1)+3]):($=T[0],M=T[1],U=T[2],Z=T[3]);var K=this.finiteLinesIntersect(L,O,R,F,$,M,U,Z,!0);I[2*G]=K[0],I[2*G+1]=K[1]}return I},D.expandPolygon=function(T,I){var L=Array(2*T.length),O,R,F,$;for(var M=0;M<T.length/2;M++){O=T[2*M],R=T[2*M+1],M<T.length/2-1?(F=T[2*(M+1)],$=T[2*(M+1)+1]):(F=T[0],$=T[1]);// Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]
// Assume CCW polygon winding
var U=$-R,Z=-(F-O),G=Math.sqrt(U*U+Z*Z),K=U/G,J=Z/G;// Normalize
L[4*M]=O+K*I,L[4*M+1]=R+J*I,L[4*M+2]=F+K*I,L[4*M+3]=$+J*I}return L},D.intersectLineEllipse=function(T,I,L,O,R,F){var $=L-T,M=O-I;$/=R,M/=F;var U=Math.sqrt($*$+M*M),Z=U-1;if(0>Z)return[];var G=Z/U;return[(L-T)*G+T,(O-I)*G+I]},D.intersectLineCircle=function(T,I,L,O,R,F,$){// Calculate d, direction vector of line
var M=[L-T,O-I],U=[R,F],Z=[T-R,I-F],G=M[0]*M[0]+M[1]*M[1],K=2*(Z[0]*M[0]+Z[1]*M[1]),U=Z[0]*Z[0]+Z[1]*Z[1]-$*$,J=K*K-4*G*U;// Direction vector of line
// Center of circle
if(0>J)return[];var ee=(-K+Math.sqrt(J))/(2*G),te=(-K-Math.sqrt(J))/(2*G),ae=Math.min(ee,te),ne=Math.max(ee,te),re=[];if(0<=ae&&1>=ae&&re.push(ae),0<=ne&&1>=ne&&re.push(ne),0===re.length)return[];var oe=re[0]*M[0]+T,se=re[0]*M[1]+I;if(1<re.length){if(re[0]==re[1])return[oe,se];var le=re[1]*M[0]+T,pe=re[1]*M[1]+I;return[oe,se,le,pe]}return[oe,se]},D.findCircleNearPoint=function(T,I,L,O,R){var F=O-T,$=R-I,M=Math.sqrt(F*F+$*$);return[T+F/M*L,I+$/M*L]},D.findMaxSqDistanceToOrigin=function(T){var I=0.000001,L;for(var O=0;O<T.length/2;O++)L=T[2*O]*T[2*O]+T[2*O+1]*T[2*O+1],L>I&&(I=L);return I},D.midOfThree=function(T,I,L){if(I<=T&&T<=L||L<=T&&T<=I)return T;return T<=I&&I<=L||L<=I&&I<=T?I:L},D.finiteLinesIntersect=function(T,I,L,O,R,F,$,M,U){var Z=T-R,G=L-T,K=$-R,J=I-F,ee=O-I,te=M-F,ae=K*J-te*Z,ne=G*J-ee*Z,re=te*G-K*ee;if(0!=re){var oe=ae/re,se=ne/re,le=0.001,pe=0-le,ue=1+le;if(pe<=oe&&oe<=ue&&pe<=se&&se<=ue)return[T+oe*G,I+oe*ee];return U?[T+oe*G,I+oe*ee]:[]}return 0==ae||0==ne?this.midOfThree(T,L,$)===$?[$,M]:this.midOfThree(T,L,R)===R?[R,F]:this.midOfThree(R,$,L)===L?[L,O]:[]:[];// Parallel, non-coincident
},D.polygonIntersectLine=function(T,I,L,O,R,F,$,M){var U=[],Z,G=Array(L.length);for(var K=0;K<G.length/2;K++)G[2*K]=L[2*K]*F+O,G[2*K+1]=L[2*K+1]*$+R;var J;if(0<M){var ee=D.expandPolygon(G,-M);J=D.joinLines(ee)}else J=G;// var points = transformedPoints;
var te,ae,ne,re;for(var K=0;K<J.length/2;K++)te=J[2*K],ae=J[2*K+1],K<J.length/2-1?(ne=J[2*(K+1)],re=J[2*(K+1)+1]):(ne=J[0],re=J[1]),Z=this.finiteLinesIntersect(T,I,O,R,te,ae,ne,re),0!==Z.length&&U.push(Z[0],Z[1]);return U},D.shortenIntersection=function(T,I,L){var O=[T[0]-I[0],T[1]-I[1]],R=Math.sqrt(O[0]*O[0]+O[1]*O[1]),F=(R-L)/R;return 0>F&&(F=0.00001),[I[0]+F*O[0],I[1]+F*O[1]]},D.generateUnitNgonPointsFitToSquare=function(T,I){var L=D.generateUnitNgonPoints(T,I);return L=D.fitPolygonToSquare(L),L},D.fitPolygonToSquare=function(T){var I,L,O=T.length/2,R=1/0,F=1/0,$=-(1/0),M=-(1/0);for(var U=0;U<O;U++)I=T[2*U],L=T[2*U+1],R=Math.min(R,I),$=Math.max($,I),F=Math.min(F,L),M=Math.max(M,L);// stretch factors
var Z=2/($-R),G=2/(M-F);for(var U=0;U<O;U++)I=T[2*U]=T[2*U]*Z,L=T[2*U+1]=T[2*U+1]*G,R=Math.min(R,I),$=Math.max($,I),F=Math.min(F,L),M=Math.max(M,L);if(-1>F)for(var U=0;U<O;U++)L=T[2*U+1]=T[2*U+1]+(-1-F);return T},D.generateUnitNgonPoints=function(T,I){var L=2*(1/T)*Math.PI,O=0==T%2?Math.PI/2+L/2:Math.PI/2;//    console.log(nodeShapes['square']);
O+=I;var R=Array(2*T),F;for(var $=0;$<T;$++)F=$*L+O,R[2*$]=Math.cos(F),R[2*$+1]=Math.sin(-F);return R},D.getRoundRectangleRadius=function(T,I){// Set the default radius, unless half of width or height is smaller than default
return Math.min(T/4,I/4,8)},_.exports=D},{}],85:[function(E,_){/*!
Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
Licensed under The MIT License (http://opensource.org/licenses/MIT)
*/"use strict";/*  promise states [Promises/A+ 2.1]  */var D=0,T=1,I=2,L=function(U){/*  optionally support non-constructor/plain-function call  */return this instanceof L?void(this.id="Thenable/1.0.7",this.state=D,this.fulfillValue=void 0,this.rejectReason=void 0,this.onFulfilled=[],this.onRejected=[],this.proxy={then:this.then.bind(this)},"function"==typeof U&&U.call(this,this.fulfill.bind(this),this.reject.bind(this))):new L(U);/*  initialize object  */};/*  [Promises/A+ 2.1.1]  *//*  [Promises/A+ 2.1.2]  *//*  [Promises/A+ 2.1.3]  *//*  promise object constructor  *//*  promise API methods  */L.prototype={/*  promise resolving methods  */fulfill:function(U){return O(this,T,"fulfillValue",U)},reject:function(U){return O(this,I,"rejectReason",U)},/*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */then:function(U,Z){var G=this,K=new L;/*  [Promises/A+ 2.2.7]  */return G.onFulfilled.push($(U,K,"fulfill")),G.onRejected.push($(Z,K,"reject")),R(G),K.proxy;/*  [Promises/A+ 2.2.7, 3.3]  */}};/*  deliver an action  */var O=function(U,Z,G,K){return U.state===D&&(U.state=Z,U[G]=K,R(U)),U},R=function(U){U.state===T?F(U,"onFulfilled",U.fulfillValue):U.state===I&&F(U,"onRejected",U.rejectReason)},F=function(U,Z,G){/* global setImmediate: true *//* global setTimeout: true *//*  short-circuit processing  */if(0!==U[Z].length){/*  iterate over all handlers, exactly once  */var K=U[Z];U[Z]=[];/*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */var J=function(){for(var Ze=0;Ze<K.length;Ze++)K[Ze](G);/*  [Promises/A+ 2.2.5]  */};/*  execute procedure asynchronously  *//*  [Promises/A+ 2.2.4, 3.1]  */"function"==typeof setImmediate?setImmediate(J):setTimeout(J,0)}},$=function(U,Z,G){return function(K){if("function"!=typeof U)/*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */Z[G].call(Z,K);/*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */else{var J;try{J=U(K)}/*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */catch(ee){/*  [Promises/A+ 2.2.7.2]  */return void Z.reject(ee)}M(Z,J)}}},M=function(U,Z){/*  sanity check arguments  *//*  [Promises/A+ 2.3.1]  */if(U===Z||U.proxy===Z)return void U.reject(new TypeError("cannot resolve promise with itself"));/*  surgically check for a "then" method
    (mainly to just call the "getter" of "then" only once)  */var G;if("object"==typeof Z&&null!==Z||"function"==typeof Z)try{G=Z.then}/*  [Promises/A+ 2.3.3.1, 3.5]  */catch(J){/*  [Promises/A+ 2.3.3.2]  */return void U.reject(J)}/*  handle own Thenables    [Promises/A+ 2.3.2]
    and similar "thenables" [Promises/A+ 2.3.3]  */if("function"==typeof G){var K=!1;try{G.call(Z,/*  resolvePromise  *//*  [Promises/A+ 2.3.3.3.1]  */function(J){K||(K=!0,J===Z?U.reject(new TypeError("circular thenable chain")):M(U,J))},/*  rejectPromise  *//*  [Promises/A+ 2.3.3.3.2]  */function(J){K||(K=!0,U.reject(J))})}catch(J){K||U.reject(J)}return}/*  handle other values  */U.fulfill(Z)};/*  execute all handlers  *//*  execute particular set of handlers  *//*  generate a resolver function  *//*  "Promise Resolution Procedure"  *//*  [Promises/A+ 2.3]  */// so we always have Promise.all()
L.all=function(U){return new L(function(Z,G){var K=Array(U.length),J=0,ee=function(ae,ne){K[ae]=ne,J++,J===U.length&&Z(K)};for(var te=0;te<U.length;te++)(function(ae){var ne=U[ae],re=null!=ne&&null!=ne.then;re?ne.then(function(oe){ee(ae,oe)},function(oe){G(oe)}):ee(ae,ne)})(te)})},L.resolve=function(U){return new L(function(Z){Z(U)})},L.reject=function(U){return new L(function(Z,G){G(U)})},_.exports="undefined"==typeof Promise?L:Promise},{}],86:[function(E,_){"use strict";var D=E("./is"),T=E("./util"),I=function(R){if(!(this instanceof I))return new I(R);var F=this;F._private={selectorText:null,invalid:!0};// storage for parsed queries
var $=function(){return{classes:[],colonSelectors:[],data:[],group:null,ids:[],meta:[],// fake selectors
collection:null,// a collection to match against
filter:null,// filter function
// these are defined in the upward direction rather than down (e.g. child)
// because we need to go up in Selector.filter()
parent:null,// parent query obj
ancestor:null,// ancestor query obj
subject:null,// defines subject in compound query (subject query obj; points to self if subject)
// use these only when subject has been defined
child:null,descendant:null}};if(!R||D.string(R)&&R.match(/^\s*$/))F.length=0;else if("*"===R||"edge"===R||"node"===R)F[0]=$(),F[0].group="*"===R?R:R+"s",F[0].groupOnly=!0,F._private.invalid=!1,F._private.selectorText=R,F.length=1;else if(D.elementOrCollection(R)){var M=R.collection();F[0]=$(),F[0].collection=M,F.length=1}else if(D.fn(R))F[0]=$(),F[0].filter=R,F.length=1;else if(D.string(R)){// the current subject in the query
var U=null,Z={metaChar:"[\\!\\\"\\#\\$\\%\\&\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]",// chars we need to escape in var names, etc
comparatorOp:"=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=",// binary comparison op (used in data selectors)
boolOp:"\\?|\\!|\\^",// boolean (unary) operators (used in data selectors)
string:"\"(?:\\\\\"|[^\"])+\"|'(?:\\\\'|[^'])+'",// string literals (used in data selectors) -- doublequotes | singlequotes
number:T.regex.number,// number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
meta:"degree|indegree|outdegree",// allowed metadata fields (i.e. allowed functions to use from Collection)
separator:"\\s*,\\s*",// queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
descendant:"\\s+",child:"\\s+>\\s+",subject:"\\$"};// tokens in the query language
Z.variable="(?:[\\w-]|(?:\\\\"+Z.metaChar+"))+",Z.value=Z.string+"|"+Z.number,Z.className=Z.variable,Z.id=Z.variable;// an element id (follows variable conventions)
// when a token like a variable has escaped meta characters, we need to clean the backslashes out
// so that values get compared properly in Selector.filter()
var G=function(me){return me.replace(new RegExp("\\\\("+Z.metaChar+")","g"),function(fe,xe){return xe})},K=Z.comparatorOp.split("|");// add @ variants to comparatorOp
for(var J=0;J<K.length;J++){var ee=K[J];Z.comparatorOp+="|@"+ee}// add ! variants to comparatorOp
var K=Z.comparatorOp.split("|");for(var J=0;J<K.length;J++){var ee=K[J];0<=ee.indexOf("!")||"="!==ee&&(Z.comparatorOp+="|\\!"+ee)}// NOTE: add new expression syntax here to have it recognised by the parser;
// - a query contains all adjacent (i.e. no separator in between) expressions;
// - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;
// - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
// - when you add something here, also add to Selector.toString()
var te=[{name:"group",query:!0,regex:"(node|edge|\\*)",populate:function(me){this.group="*"===me?me:me+"s"}},{name:"state",query:!0,// NB: if one colon selector is a substring of another from its start, place the longer one first
// e.g. :foobar|:foo
regex:"(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:backgrounding|:nonbackgrounding)",populate:function(me){this.colonSelectors.push(me)}},{name:"id",query:!0,regex:"\\#("+Z.id+")",populate:function(me){this.ids.push(G(me))}},{name:"className",query:!0,regex:"\\.("+Z.className+")",populate:function(me){this.classes.push(G(me))}},{name:"dataExists",query:!0,regex:"\\[\\s*("+Z.variable+")\\s*\\]",populate:function(me){this.data.push({field:G(me)})}},{name:"dataCompare",query:!0,regex:"\\[\\s*("+Z.variable+")\\s*("+Z.comparatorOp+")\\s*("+Z.value+")\\s*\\]",populate:function(me,fe,xe){var ve=null!=new RegExp("^"+Z.string+"$").exec(xe);xe=ve?xe.substring(1,xe.length-1):parseFloat(xe),this.data.push({field:G(me),operator:fe,value:xe})}},{name:"dataBool",query:!0,regex:"\\[\\s*("+Z.boolOp+")\\s*("+Z.variable+")\\s*\\]",populate:function(me,fe){this.data.push({field:G(fe),operator:me})}},{name:"metaCompare",query:!0,regex:"\\[\\[\\s*("+Z.meta+")\\s*("+Z.comparatorOp+")\\s*("+Z.number+")\\s*\\]\\]",populate:function(me,fe,xe){this.meta.push({field:G(me),operator:fe,value:parseFloat(xe)})}},{name:"nextQuery",separator:!0,regex:Z.separator,populate:function(){F[++J]=$(),U=null}},{name:"child",separator:!0,regex:Z.child,populate:function(){// this query is the parent of the following query
var me=$();me.parent=this,me.subject=U,F[J]=me}},{name:"descendant",separator:!0,regex:Z.descendant,populate:function(){// this query is the ancestor of the following query
var me=$();me.ancestor=this,me.subject=U,F[J]=me}},{name:"subject",modifier:!0,regex:Z.subject,populate:function(){return null!=U&&this.subject!=this?(T.error("Redefinition of subject in selector `"+R+"`"),!1):void(U=this,this.subject=this)}}];F._private.selectorText=R;var ae=R,J=0,ne=function(me){var fe,xe,ve;for(var be=0;be<te.length;be++){var we=te[be],Ee=we.name;// ignore this expression if it doesn't meet the expectation function
if(!D.fn(me)||me(Ee,we)){var Se=ae.match(new RegExp("^"+we.regex));if(null!=Se){xe=Se,fe=we,ve=Ee;var _e=Se[0];ae=ae.substring(_e.length);break;// we've consumed one expr, so we can return now
}}}return{expr:fe,match:xe,name:ve}},re=function(){var me=ae.match(/^\s+/);if(me){var fe=me[0];ae=ae.substring(fe.length)}};// of all the expressions, find the first match in the remaining text
// consume all leading whitespace
// get rid of leading whitespace
for(F[0]=$(),re();;){var oe=ne();if(null==oe.expr)return void T.error("The selector `"+R+"`is invalid");// we're done when there's nothing left to parse
var se=[];for(var le=1;le<oe.match.length;le++)se.push(oe.match[le]);// let the token populate the selector object (i.e. in self[i])
var pe=oe.expr.populate.apply(F[J],se);if(!1===pe)return;// exit if population failed
if(ae.match(/^\s*$/))break}F.length=J+1;// adjust references for subject
for(var le=0;le<F.length;le++){var ue=F[le];if(null!=ue.subject){// go up the tree until we reach the subject
for(;;){if(ue.subject==ue)break;// done if subject is self
if(null!=ue.parent){// swap parent/child reference
var ge=ue.parent,ce=ue;ce.parent=null,ge.child=ce,ue=ge}else if(null!=ue.ancestor){// swap ancestor/descendant
var he=ue.ancestor,ye=ue;ye.ancestor=null,he.descendant=ye,ue=he}else{T.error("When adjusting references for the selector `"+ue+"`, neither parent nor ancestor was found");break}}// for
F[le]=ue.subject}// if
}// for
}else return void T.error("A selector must be created from a string; found "+R);F._private.invalid=!1},L=I.prototype;L.size=function(){return this.length},L.eq=function(R){return this[R]};var O=function(R,F){var $=F._private;// make single group-only selectors really cheap to check since they're the most common ones
if(R.groupOnly)return"*"===R.group||R.group===$.group;// check group
if(null!=R.group&&"*"!=R.group&&R.group!=$.group)return!1;var M=F.cy(),U=!0;// check colon selectors
for(var Z=0;Z<R.colonSelectors.length;Z++){var G=R.colonSelectors[Z];if(":selected"===G?U=F.selected():":unselected"===G?U=!F.selected():":selectable"===G?U=F.selectable():":unselectable"===G?U=!F.selectable():":locked"===G?U=F.locked():":unlocked"===G?U=!F.locked():":visible"===G?U=F.visible():":hidden"===G?U=!F.visible():":transparent"===G?U=F.transparent():":grabbed"===G?U=F.grabbed():":free"===G?U=!F.grabbed():":removed"===G?U=F.removed():":inside"===G?U=!F.removed():":grabbable"===G?U=F.grabbable():":ungrabbable"===G?U=!F.grabbable():":animated"===G?U=F.animated():":unanimated"===G?U=!F.animated():":parent"===G?U=F.isNode()&&F.children().nonempty():":child"===G||":nonorphan"===G?U=F.isNode()&&F.parent().nonempty():":orphan"===G?U=F.isNode()&&F.parent().empty():":loop"===G?U=F.isEdge()&&F.data("source")===F.data("target"):":simple"===G?U=F.isEdge()&&F.data("source")!==F.data("target"):":active"===G?U=F.active():":inactive"===G?U=!F.active():":backgrounding"===G?U=F.backgrounding():":nonbackgrounding"===G?U=!F.backgrounding():void 0,!U)break}if(!U)return!1;// check id
var K=!0;for(var Z=0;Z<R.ids.length;Z++){var J=R.ids[Z],ee=$.data.id;if(K=K&&J==ee,!K)break}if(!K)return!1;// check classes
var te=!0;for(var Z=0;Z<R.classes.length;Z++){var ae=R.classes[Z];if(te=te&&F.hasClass(ae),!te)break}if(!te)return!1;// generic checking for data/metadata
var ne=function(pe){var ue=!0;for(var ge=0;ge<R[pe.name].length;ge++){var ce=R[pe.name][ge],he=ce.operator,ye=ce.value,me=ce.field,fe;if(null!=he&&null!=ye){var xe=pe.fieldValue(me),ve=D.string(xe)||D.number(xe)?""+xe:"",be=""+ye,we=!1;0<=he.indexOf("@")&&(ve=ve.toLowerCase(),be=be.toLowerCase(),he=he.replace("@",""),we=!0);var Ee=!1;0<=he.indexOf("!")&&(he=he.replace("!",""),Ee=!0),we&&(ye=be.toLowerCase(),xe=ve.toLowerCase());var Se=!1;switch(he){case"*=":fe=0<=ve.indexOf(be);break;case"$=":fe=0<=ve.indexOf(be,ve.length-be.length);break;case"^=":fe=0===ve.indexOf(be);break;case"=":fe=xe===ye;break;case">":Se=!0,fe=xe>ye;break;case">=":Se=!0,fe=xe>=ye;break;case"<":Se=!0,fe=xe<ye;break;case"<=":Se=!0,fe=xe<=ye;break;default:fe=!1;}// apply the not op, but null vals for inequalities should always stay non-matching
Ee&&(null!=xe||!Se)&&(fe=!fe)}else null==he?fe=!pe.fieldUndefined(me):"?"===he?fe=pe.fieldTruthy(me):"!"===he?fe=!pe.fieldTruthy(me):"^"===he?fe=pe.fieldUndefined(me):void 0;if(!fe){ue=!1;break}}// for
return ue},re=ne({name:"data",fieldValue:function(pe){return $.data[pe]},fieldUndefined:function(pe){return $.data[pe]===void 0},fieldTruthy:function(pe){return!!$.data[pe]}});// operandsMatch
// check data matches
if(!re)return!1;// check metadata matches
var oe=ne({name:"meta",fieldValue:function(pe){return F[pe]()},fieldUndefined:function(pe){return null==F[pe]()},fieldTruthy:function(pe){return!!F[pe]()}});if(!oe)return!1;// check collection
if(null!=R.collection){var se=R.collection.hasElementWithId(F.id());if(!se)return!1}// check filter function
if(null!=R.filter&&0===F.collection().filter(R.filter).size())return!1;// check parent/child relations
var le=function(pe,ue){if(null!=pe){var ge=!1;if(!M.hasCompoundNodes())return!1;ue=ue();// save cycles if query == null
// query must match for at least one element (may be recursive)
for(var ce=0;ce<ue.length;ce++)if(O(pe,ue[ce])){ge=!0;break}return ge}return!0};// we've reached the end, so we've matched everything for this query
return!!le(R.parent,function(){return F.parent()})&&!!le(R.ancestor,function(){return F.parents()})&&!!le(R.child,function(){return F.children()})&&!!le(R.descendant,function(){return F.descendants()})};// queryMatches
// filter an existing collection
L.filter=function(R){var F=this,$=R.cy();// don't bother trying if it's invalid
if(F._private.invalid)return $.collection();var M=function(Z){for(var G=0;G<F.length;G++){var K=F[G];if(O(K,Z))return!0}return!1};null==F._private.selectorText&&(M=function(){return!0});var U=R.filter(M);return U},L.matches=function(R){var F=this;// don't bother trying if it's invalid
if(F._private.invalid)return!1;for(var $=0;$<F.length;$++){var M=F[$];if(O(M,R))return!0}return!1},L.toString=L.selector=function(){var R="",F=function(K){return null==K?"":K},$=function(K){return D.string(K)?"\""+K+"\"":F(K)},M=function(K){return" "+K+" "},U=function(K){var J="";K.subject===K&&(J+="$");var ee=F(K.group);J+=ee.substring(0,ee.length-1);for(var te=0;te<K.data.length;te++){var ae=K.data[te];J+=ae.value?"["+ae.field+M(F(ae.operator))+$(ae.value)+"]":"["+F(ae.operator)+ae.field+"]"}for(var te=0;te<K.meta.length;te++){var ne=K.meta[te];J+="[["+ne.field+M(F(ne.operator))+$(ne.value)+"]]"}for(var te=0;te<K.colonSelectors.length;te++){var re=K.colonSelectors[Z];J+=re}for(var te=0;te<K.ids.length;te++){var re="#"+K.ids[Z];J+=re}for(var te=0;te<K.classes.length;te++){var re="."+K.classes[te];J+=re}return null!=K.parent&&(J=U(K.parent)+" > "+J),null!=K.ancestor&&(J=U(K.ancestor)+" "+J),null!=K.child&&(J+=" > "+U(K.child)),null!=K.descendant&&(J+=" "+U(K.descendant)),J};for(var Z=0;Z<this.length;Z++){var G=this[Z];R+=U(G),1<this.length&&Z<this.length-1&&(R+=", ")}return R},_.exports=I},{"./is":83,"./util":99}],87:[function(E,_){"use strict";var D=E("../util"),T=E("../is"),I={};// (potentially expensive calculation)
// apply the style to the element based on
// - its bypass
// - what selectors match it
I.apply=function(L){var O=this,R=O._private;R.newStyle&&(R.contextStyles={},R.propDiffs={},O.cleanElements(L,!0));for(var F=0;F<L.length;F++){var $=L[F],M=O.getContextMeta($),U=O.getContextStyle(M),Z=O.applyContextStyle(M,U,$);O.updateTransitions($,Z.diffProps),O.updateStyleHints($)}// for elements
R.newStyle=!1},I.getPropertiesDiff=function(L,O){var R=this,F=R._private.propDiffs=R._private.propDiffs||{},$=L+"-"+O,M=F[$];if(M)return M;var U=[],Z={};for(var G=0;G<R.length;G++){var K=R[G],J="t"===L[G],ee="t"===O[G],te=J!==ee,ae=0<K.mappedProperties.length;if(te||ae){var ne;te&&ae?ne=K.properties:te?ne=K.properties:ae&&(ne=K.mappedProperties);for(var re=0;re<ne.length;re++){var oe=ne[re],se=oe.name,le=!1;// if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
// (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
// is cached)
for(var pe=G+1;pe<R.length;pe++){var ue=R[pe],ge="t"===O[pe];// exit early as long as one later context overrides
if(ge&&(le=null!=ue.properties[oe.name],le))break;// can't override unless the context is active
}Z[se]||le||(Z[se]=!0,U.push(se))}// for props
}// if
}// for contexts
return F[$]=U,U},I.getContextMeta=function(L){var O=this,R="",$=L._private.styleCxtKey||"",F;O._private.newStyle&&($="");// get the cxt key
for(var M=0;M<O.length;M++){var U=O[M],Z=U.selector&&U.selector.matches(L);R+=Z?"t":"f"}// for context
return F=O.getPropertiesDiff($,R),L._private.styleCxtKey=R,{key:R,diffPropNames:F}},I.getContextStyle=function(L){var O=L.key,R=this,F=this._private.contextStyles=this._private.contextStyles||{};// if already computed style, returned cached copy
if(F[O])return F[O];var $={_private:{key:O}};for(var M=0;M<R.length;M++){var U=R[M],Z="t"===O[M];if(Z)for(var G=0;G<U.properties.length;G++){var K=U.properties[G],J=$[K.name]=K;J.context=U}}return F[O]=$,$},I.applyContextStyle=function(L,O,R){var F=this,$=L.diffPropNames,M={};for(var U=0;U<$.length;U++){var Z=$[U],G=O[Z],K=R.pstyle(Z);if(!G)// no context prop means delete
if(!K)continue;// no existing prop means nothing needs to be removed
// nb affects initial application on mapped values like control-point-distances
else G=K.bypass?{name:Z,deleteBypassed:!0}:{name:Z,delete:!0};// save cycles when the context prop doesn't need to be applied
if(K!==G){var J=M[Z]={prev:K};F.applyParsedProperty(R,G),J.next=R.pstyle(Z),J.next&&J.next.bypass&&(J.next=J.next.bypassed)}}return{diffProps:M}},I.updateStyleHints=function(L){var O=L._private,R=this;if(!L.removed()){// set whether has pie or not; for greater efficiency
var F=!1;if("nodes"===O.group)for(var $=1;$<=R.pieBackgroundN;$++){// 1..N
var M=L.pstyle("pie-"+$+"-background-size").value;if(0<M){F=!0;break}}O.hasPie=F;var U=L.pstyle("text-transform").strValue,Z=L.pstyle("label").strValue,G=L.pstyle("source-label").strValue,K=L.pstyle("target-label").strValue,J=L.pstyle("font-style").strValue,M=L.pstyle("font-size").pfValue+"px",ee=L.pstyle("font-family").strValue,te=L.pstyle("font-weight").strValue,ae=L.pstyle("text-valign").strValue,ne=L.pstyle("text-valign").strValue,re=L.pstyle("text-outline-width").pfValue,oe=L.pstyle("text-wrap").strValue,se=L.pstyle("text-max-width").pfValue,le=J+"$"+M+"$"+ee+"$"+te+"$"+U+"$"+ae+"$"+ne+"$"+re+"$"+oe+"$"+se;// var variant = style['font-variant'].strValue;
O.labelStyleKey=le,O.sourceLabelKey=le+"$"+G,O.targetLabelKey=le+"$"+K,O.labelKey=le+"$"+Z,O.fontKey=J+"$"+te+"$"+M+"$"+ee,O.styleKey=Date.now()}},I.applyParsedProperty=function(L,O){var R=this,F=O,$=L._private.style,Z=R.types,G=R.properties[F.name].type,K=F.bypass,J=$[F.name],ee=J&&J.bypass,te=L._private,M,U;// edges connected to compound nodes can not be haystacks
if("curve-style"===O.name&&"haystack"===O.value&&L.isEdge()&&(L.isLoop()||L.source().isParent()||L.target().isParent())&&(F=O=this.parse(O.name,"bezier",K)),F.delete)return $[F.name]=void 0,!0;if(F.deleteBypassed)// delete the property that the
return!J||!!J.bypass&&(J.bypassed=void 0,!0);// we're unsuccessful deleting the bypassed
// check if we need to delete the current bypass
if(F.deleteBypass)// then this property is just here to indicate we need to delete
return!J||!!J.bypass&&($[F.name]=J.bypassed,!0);// we're unsuccessful deleting the bypass
var ae=function(){D.error("Do not assign mappings to elements without corresponding data (e.g. ele `"+L.id()+"` for property `"+F.name+"` with data field `"+F.field+"`); try a `["+F.field+"]` selector to limit scope to elements with `"+F.field+"` defined")};// put the property in the style objects
switch(F.mapped){// flatten the property if mapped
case Z.mapData:// flatten the field (e.g. data.foo.bar)
var ne=F.field.split("."),M=te.data;for(var re=0;re<ne.length&&M;re++){var oe=ne[re];M=M[oe]}var se;se=T.number(M)?(M-F.fieldMin)/(F.fieldMax-F.fieldMin):0,0>se?se=0:1<se&&(se=1);let Ee=F.valueMin,Se=F.valueMax;if(G.color){var le=Ee[0],pe=Se[0],ue=Ee[1],ge=Se[1],ce=Ee[2],he=Se[2],ye=null===Ee[3]?1:Ee[3],me=null===Se[3]?1:Se[3],fe=[Math.round(le+(pe-le)*se),Math.round(ue+(ge-ue)*se),Math.round(ce+(he-ce)*se),Math.round(ye+(me-ye)*se)];U={// colours are simple, so just create the flat property instead of expensive string parsing
bypass:F.bypass,// we're a bypass if the mapping property is a bypass
name:F.name,value:fe,strValue:"rgb("+fe[0]+", "+fe[1]+", "+fe[2]+")"}}else if(G.number){var xe=Ee+(Se-Ee)*se;U=this.parse(F.name,xe,F.bypass,!0)}else return!1;// can only map to colours and numbers
U||(U=this.parse(F.name,J.strValue,F.bypass,!0)),U||ae(),U.mapping=F,F=U;// the flattened (mapped) property is the one we want
break;// direct mapping
case Z.data:// flatten the field (e.g. data.foo.bar)
var ne=F.field.split("."),M=te.data;if(M)for(var re=0;re<ne.length;re++)M=M[ne[re]];if(U=this.parse(F.name,M,F.bypass,!0),!U){// if we can't flatten the property, then use the origProp so we still keep the mapping itself
var ve=J?J.strValue:"";U=this.parse(F.name,ve,F.bypass,!0)}U||ae(),U.mapping=F,F=U;// the flattened (mapped) property is the one we want
break;case Z.fn:var be=F.value,we=be(L);U=this.parse(F.name,we,F.bypass,!0),U.mapping=F,F=U;// the flattened (mapped) property is the one we want
break;case void 0:break;// just set the property
default:return!1;// not a valid mapping
}// if the property is a bypass property, then link the resultant property to the original one
return K?(F.bypassed=ee?J.bypassed:J,$[F.name]=F):ee?J.bypassed=F:$[F.name]=F,!0},I.cleanElements=function(L,O){var R=this,F=R.properties;for(var $=0;$<L.length;$++){var M=L[$];if(!O)M._private.style={};else{var U=M._private.style;for(var Z=0;Z<F.length;Z++){var G=F[Z],K=U[G.name];K&&(K.bypass?K.bypassed=null:U[G.name]=null)}}}},I.update=function(){var L=this._private.cy,O=L.mutableElements();O.updateStyle()},I.updateMappers=function(L){var O=this;for(var R=0;R<L.length;R++){// for each ele
var F=L[R],$=F._private.style;for(var M=0;M<O.properties.length;M++){// for each prop
var U=O.properties[M],Z=$[U.name];if(Z&&Z.mapping){var G=Z.mapping;this.applyParsedProperty(F,G)}}this.updateStyleHints(F)}},I.updateTransitions=function(L,O,R){var F=this,$=L._private,M=L.pstyle("transition-property").value,U=L.pstyle("transition-duration").pfValue,Z=L.pstyle("transition-delay").pfValue;if(0<M.length&&0<U){var G={},K=!1;// build up the style to animate towards
for(var J=0;J<M.length;J++){var ee=M[J],te=L.pstyle(ee),ae=O[ee];// consider px values
if(ae){var ne=ae.prev,re=ne,oe=null==ae.next?te:ae.next,se=!1,pe=0.000001,le;re&&(T.number(re.pfValue)&&T.number(oe.pfValue)?(se=oe.pfValue-re.pfValue,le=re.pfValue+pe*se):T.number(re.value)&&T.number(oe.value)?(se=oe.value-re.value,le=re.value+pe*se):T.array(re.value)&&T.array(oe.value)&&(se=re.value[0]!==oe.value[0]||re.value[1]!==oe.value[1]||re.value[2]!==oe.value[2],le=re.strValue),se&&(G[ee]=oe.strValue,this.applyBypass(L,ee,le),K=!0))}// delta time % value for initVal (allows animating out of init zero opacity)
}// end if props allow ani
// can't transition if there's nothing previous to transition from
if(!K)return;$.transitioning=!0,L.stop(),0<Z&&L.delay(Z),L.animate({css:G},{duration:U,easing:L.pstyle("transition-timing-function").value,queue:!1,complete:function(){R||F.removeBypasses(L,M),$.transitioning=!1}})}else $.transitioning&&(L.stop(),this.removeBypasses(L,M),$.transitioning=!1)},_.exports=I},{"../is":83,"../util":99}],88:[function(E,_){"use strict";var D=E("../is"),T=E("../util"),I={};// bypasses are applied to an existing style on an element, and just tacked on temporarily
// returns true iff application was successful for at least 1 specified property
I.applyBypass=function(L,O,R,F){var $=this,M=[];// put all the properties (can specify one or many) in an array after parsing them
if("*"===O||"**"===O){// apply to all property names
if(void 0!==R)for(var U=0;U<$.properties.length;U++){var Z=$.properties[U],O=Z.name,G=this.parse(O,R,!0);G&&M.push(G)}}else if(D.string(O)){// then parse the single property
var G=this.parse(O,R,!0);G&&M.push(G)}else if(D.plainObject(O)){// then parse each property
var K=O;F=R;for(var U=0;U<$.properties.length;U++){var Z=$.properties[U],O=Z.name,R=K[O];if(void 0===R&&(R=K[T.dash2camel(O)]),void 0!==R){var G=this.parse(O,R,!0);G&&M.push(G)}}}else// can't do anything without well defined properties
return!1;// we've failed if there are no valid properties
if(0===M.length)return!1;// now, apply the bypass properties on the elements
var J=!1;// return true if at least one succesful bypass applied
for(var U=0;U<L.length;U++){// for each ele
var ee=L[U],te={},ae;for(var ne=0;ne<M.length;ne++){// for each prop
var Z=M[ne];if(F){var re=ee.pstyle(Z.name);ae=te[Z.name]={prev:re}}J=this.applyParsedProperty(ee,Z)||J,F&&(ae.next=ee.pstyle(Z.name))}// for props
J&&this.updateStyleHints(ee),F&&this.updateTransitions(ee,te,!0)}// for eles
return J},I.overrideBypass=function(L,O,R){O=T.camel2dash(O);for(var F=0;F<L.length;F++){var $=L[F],M=$._private.style[O],U=this.properties[O].type,Z=U.color,G=U.mutiple;if(!M||!M.bypass){this.applyBypass($,O,R);continue}M.value=R,null!==M.pfValue&&(M.pfValue=R),M.strValue=Z?"rgb("+R.join(",")+")":G?R.join(" "):""+R}},I.removeAllBypasses=function(L,O){return this.removeBypasses(L,this.propertyNames,O)},I.removeBypasses=function(L,O,R){for(var F=0;F<L.length;F++){var $=L[F],M={};for(const J of O){//for( var i = 0; i < props.length; i++ ){
//var name = props[ i ];
var U=this.properties[J];const ee=U.name;var Z=$.pstyle(ee);if(Z&&Z.bypass){// empty => remove bypass
var G=this.parse(J,"",!0),K=M[ee]={prev:Z};this.applyParsedProperty($,G),K.next=$.pstyle(ee)}}// for props
this.updateStyleHints($),R&&this.updateTransitions($,M,!0)}// for eles
},_.exports=I},{"../is":83,"../util":99}],89:[function(E,_){"use strict";var D=E("../window"),T={};// gets what an em size corresponds to in pixels relative to a dom element
T.getEmSizeInPixels=function(){var I=this.containerCss("font-size");return null==I?1:parseFloat(I)},T.containerCss=function(I){var L=this._private.cy,O=L.container();if(D&&O&&D.getComputedStyle)return D.getComputedStyle(O).getPropertyValue(I)},_.exports=T},{"../window":106}],90:[function(E,_){"use strict";var D=E("../util"),T=E("../is"),I={};// gets the rendered style for an element
I.getRenderedStyle=function(L){return this.getRawStyle(L,!0)},I.getRawStyle=function(L,O){var R=this,L=L[0];// insure it's an element
if(L){var F={};for(var $=0;$<R.properties.length;$++){var M=R.properties[$],U=R.getStylePropertyValue(L,M.name,O);U&&(F[M.name]=U,F[D.dash2camel(M.name)]=U)}return F}},I.getStylePropertyValue=function(L,O,R){var F=this,L=L[0];// insure it's an element
if(L){var $=F.properties[O],M=$.type,U=L.pstyle($.name),Z=L.cy().zoom();if(U){var G=U.units?M.implicitUnits||"px":null,K=G?[].concat(U.pfValue).map(function(J){return J*(R?Z:1)+G}).join(" "):U.strValue;return K}}},I.getAnimationStartStyle=function(L,O){var R={};for(var F=0;F<O.length;F++){var $=O[F],M=$.name,U=L.pstyle(M);U!==void 0&&(T.plainObject(U)?U=this.parse(M,U.strValue):U=this.parse(M,U)),U&&(R[M]=U)}return R},I.getPropsList=function(L){var O=this,R=[],F=L,$=O.properties;if(F){var M=Object.keys(F);for(var U=0;U<M.length;U++){var Z=M[U],G=F[Z],K=$[Z]||$[D.camel2dash(Z)],J=this.parse(K.name,G);R.push(J)}}return R},_.exports=I},{"../is":83,"../util":99}],91:[function(E,_){"use strict";var D=E("../is"),T=E("../util"),I=E("../selector"),L=function(R){return this instanceof L?D.core(R)?void(this._private={cy:R,coreStyle:{}},this.length=0,this.resetToDefault()):void T.error("A style must have a core reference"):new L(R)},O=L.prototype;O.instanceString=function(){return"style"},O.clear=function(){for(var R=0;R<this.length;R++)this[R]=void 0;this.length=0;var F=this._private;return F.newStyle=!0,this;// chaining
},O.resetToDefault=function(){return this.clear(),this.addDefaultStylesheet(),this},O.core=function(){return this._private.coreStyle},O.selector=function(R){// 'core' is a special case and does not need a selector
var F="core"===R?null:new I(R),$=this.length++;// new context means new index
return this[$]={selector:F,properties:[],mappedProperties:[],index:$},this;// chaining
},O.css=function(){var R=this,F=arguments;switch(F.length){case 1:var $=F[0];for(var M=0;M<R.properties.length;M++){var U=R.properties[M],Z=$[U.name];Z===void 0&&(Z=$[T.dash2camel(U.name)]),Z!==void 0&&this.cssRule(U.name,Z)}break;case 2:this.cssRule(F[0],F[1]);break;default:// do nothing if args are invalid
}return this;// chaining
},O.style=O.css,O.cssRule=function(R,F){// name-value pair
var $=this.parse(R,F);// add property to current context if valid
if($){var M=this.length-1;this[M].properties.push($),this[M].properties[$.name]=$,$.name.match(/pie-(\d+)-background-size/)&&$.value&&(this._private.hasPie=!0),$.mapped&&this[M].mappedProperties.push($);// add to core style if necessary
var U=!this[M].selector;U&&(this._private.coreStyle[$.name]=$)}return this;// chaining
},L.fromJson=function(R,F){var $=new L(R);return $.fromJson(F),$},L.fromString=function(R,F){return new L(R).fromString(F)},[E("./apply"),E("./bypass"),E("./container"),E("./get-for-ele"),E("./json"),E("./string-sheet"),E("./properties"),E("./parse")].forEach(function(R){T.extend(O,R)}),L.types=O.types,L.properties=O.properties,_.exports=L},{"../is":83,"../selector":86,"../util":99,"./apply":87,"./bypass":88,"./container":89,"./get-for-ele":90,"./json":92,"./parse":93,"./properties":94,"./string-sheet":95}],92:[function(E,_){"use strict";var D={};D.applyFromJson=function(T){var I=this;for(var L=0;L<T.length;L++){var O=T[L],R=O.selector,F=O.style||O.css,$=Object.keys(F);I.selector(R);// apply selector
for(var M=0;M<$.length;M++){var U=$[M],Z=F[U];I.css(U,Z)}}return I},D.fromJson=function(T){var I=this;return I.resetToDefault(),I.applyFromJson(T),I},D.json=function(){var T=[];for(var I=this.defaultLength;I<this.length;I++){var L=this[I],O=L.selector,R=L.properties,F={};for(var $=0;$<R.length;$++){var M=R[$];F[M.name]=M.strValue}T.push({selector:O?O.toString():"core",style:F})}return T},_.exports=D},{}],93:[function(E,_){"use strict";var D=E("../util"),T=E("../is"),I=E("../math"),L={};// a caching layer for property parsing
L.parse=function(O,R,F,$){var M=this;// function values can't be cached in all cases, and there isn't much benefit of caching them anyway
if(T.fn(R))return M.parseImpl(O,R,F,$);var U=[O,R,F,$].join("$"),Z=M.propCache=M.propCache||{},G;return(G=Z[U])||(G=Z[U]=M.parseImpl(O,R,F,$)),G=D.copy(G),G&&(G.value=D.copy(G.value)),G},L.parseImpl=function(O,R,F,$){var M=this;O=D.camel2dash(O);// make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')
var U=M.properties[O],Z=R,G=M.types;if(!U)return null;// return null on property of unknown name
if(void 0===R||null===R)return null;// can't assign null
// the property may be an alias
U.alias&&(U=U.pointsTo,O=U.name);var K=T.string(R);K&&(R=R.trim());var J=U.type;if(!J)return null;// no type, no luck
// check if bypass is null or empty string (i.e. indication to delete bypass property)
if(F&&(""===R||null===R))return{name:O,value:R,bypass:!0,deleteBypass:!0};// check if value is a function used as a mapper
if(T.fn(R))return{name:O,value:R,strValue:"fn",mapped:G.fn,bypass:F};// check if value is mapped
var ee,te;if(!K||$);else{if(ee=new RegExp(G.data.regex).exec(R)){if(F)return!1;// mappers not allowed in bypass
var ae=G.data;return{name:O,value:ee,strValue:""+R,mapped:ae,field:ee[1],bypass:F}}if(te=new RegExp(G.mapData.regex).exec(R)){if(F)return!1;// mappers not allowed in bypass
if(J.multiple)return!1;// impossible to map to num
var ae=G.mapData;// we can map only if the type is a colour or a number
if(!(J.color||J.number))return!1;var ne=this.parse(O,te[4]);// parse to validate
if(!ne||ne.mapped)return!1;// can't be invalid or mapped
var re=this.parse(O,te[5]);// parse to validate
if(!re||re.mapped)return!1;// can't be invalid or mapped
// check if valueMin and valueMax are the same
if(ne.value===re.value)return!1;// can't make much of a mapper without a range
if(J.color){var oe=ne.value,se=re.value,le=oe[0]===se[0]// red
&&oe[1]===se[1]// green
&&oe[2]===se[2]// blue
&&(// optional alpha
oe[3]===se[3]// same alpha outright
||(null==oe[3]||1===oe[3])&&(// full opacity for colour 1?
null==se[3]||1===se[3])// full opacity for colour 2?
);if(le)return!1;// can't make a mapper without a range
}return{name:O,value:te,strValue:""+R,mapped:ae,field:te[1],fieldMin:parseFloat(te[2]),// min & max are numeric
fieldMax:parseFloat(te[3]),valueMin:ne.value,valueMax:re.value,bypass:F}}}if(J.multiple&&"multiple"!==$){var pe;if(pe=K?R.split(/\s+/):T.array(R)?R:[R],J.evenMultiple&&0!=pe.length%2)return null;var ue=pe.map(function(Te){var ke=M.parse(O,Te,F,"multiple");return null==ke.pfValue?ke.value:ke.pfValue});return{name:O,value:ue,pfValue:ue,strValue:ue.join(" "),bypass:F,units:J.number&&!J.unitless?J.implicitUnits||"px":void 0}}// several types also allow enums
var ge=function(){for(var Te=0;Te<J.enums.length;Te++){var ke=J.enums[Te];if(ke===R)return{name:O,value:R,strValue:""+R,bypass:F}}return null};// check the type and return the appropriate object
if(J.number){var he="px",ce;// not set => px
if(J.units&&(ce=J.units),J.implicitUnits&&(he=J.implicitUnits),!J.unitless)if(K){var ye="px|em"+(J.allowPercent?"|\\%":"");ce&&(ye=ce);// only allow explicit units if so set
var me=R.match("^("+D.regex.number+")("+ye+")?$");me&&(R=me[1],ce=me[2]||he)}else(!ce||J.implicitUnits)&&(ce=he);// if not a number and enums not allowed, then the value is invalid
if(R=parseFloat(R),isNaN(R)&&void 0===J.enums)return null;// check if this number type also accepts special keywords in place of numbers
// (i.e. `left`, `auto`, etc)
if(isNaN(R)&&void 0!==J.enums)return R=Z,ge();// check if value must be an integer
if(J.integer&&!T.integer(R))return null;// check value is within range
if(void 0!==J.min&&R<J.min||void 0!==J.max&&R>J.max)return null;var fe={name:O,value:R,strValue:""+R+(ce?ce:""),units:ce,bypass:F};// normalise value in pixels
return fe.pfValue=J.unitless||"px"!==ce&&"em"!==ce?R:"px"!==ce&&ce?this.getEmSizeInPixels()*R:R,("ms"===ce||"s"===ce)&&(fe.pfValue="ms"===ce?R:1000*R),("deg"===ce||"rad"===ce)&&(fe.pfValue="rad"===ce?R:I.deg2rad(R)),fe}if(J.propList){var xe=[],ve=""+R;if("none"!=ve){// go over each prop
var be=ve.split(",");for(var we=0;we<be.length;we++){var Ee=be[we].trim();M.properties[Ee]&&xe.push(Ee)}if(0===xe.length)return null}return{name:O,value:xe,strValue:0===xe.length?"none":xe.join(", "),bypass:F}}if(J.color){var Se=D.color2tuple(R);return Se?{name:O,value:Se,strValue:""+R,bypass:F,roundValue:!0}:null}if(J.regex||J.regexes){// first check enums
if(J.enums){var _e=ge();if(_e)return _e}var Pe=J.regexes?J.regexes:[J.regex];for(var we=0;i<Pe.length;we++){var Ce=new RegExp(Pe[i]),De=Ce.exec(R);// make a regex from the type string
if(De)// regex matches
return{name:O,value:De,strValue:""+R,bypass:F}}return null;// didn't match any
}return J.string?{name:O,value:R,strValue:""+R,bypass:F}:J.enums?ge():null;// not a type we can handle
},_.exports=L},{"../is":83,"../math":84,"../util":99}],94:[function(E,_){"use strict";var D=E("../util"),T={};(function(){var I=D.regex.number,L=D.regex.rgbaNoBackRefs,O=D.regex.hslaNoBackRefs,R=D.regex.hex3,F=D.regex.hex6,$=function(re){return"^"+re+"\\s*\\(\\s*([\\w\\.]+)\\s*\\)$"},M=function(re){var oe=I+"|\\w+|"+L+"|"+O+"|"+R+"|"+F;return"^"+re+"\\s*\\(([\\w\\.]+)\\s*\\,\\s*("+I+")\\s*\\,\\s*("+I+")\\s*,\\s*("+oe+")\\s*\\,\\s*("+oe+")\\)$"};// each visual style property has a type and needs to be validated according to it
T.types={time:{number:!0,min:0,units:"s|ms",implicitUnits:"ms"},percent:{number:!0,min:0,max:100,units:"%",implicitUnits:"%"},zeroOneNumber:{number:!0,min:0,max:1,unitless:!0},nOneOneNumber:{number:!0,min:-1,max:1,unitless:!0},nonNegativeInt:{number:!0,min:0,integer:!0,unitless:!0},position:{enums:["parent","origin"]},nodeSize:{number:!0,min:0,enums:["label"]},number:{number:!0,unitless:!0},numbers:{number:!0,unitless:!0,multiple:!0},size:{number:!0,min:0},bidirectionalSize:{number:!0},// allows negative
bidirectionalSizes:{number:!0,multiple:!0},// allows negative
bgSize:{number:!0,min:0,allowPercent:!0},bgWH:{number:!0,min:0,allowPercent:!0,enums:["auto"]},bgPos:{number:!0,allowPercent:!0},bgRepeat:{enums:["repeat","repeat-x","repeat-y","no-repeat"]},bgFit:{enums:["none","contain","cover"]},bgClip:{enums:["none","node"]},color:{color:!0},bool:{enums:["yes","no"]},lineStyle:{enums:["solid","dotted","dashed"]},borderStyle:{enums:["solid","dotted","dashed","double"]},curveStyle:{enums:["bezier","unbundled-bezier","haystack","segments"]},fontFamily:{regex:"^([\\w- \\\"]+(?:\\s*,\\s*[\\w- \\\"]+)*)$"},fontVariant:{enums:["small-caps","normal"]},fontStyle:{enums:["italic","normal","oblique"]},fontWeight:{enums:["normal","bold","bolder","lighter","100","200","300","400","500","600","800","900",100,200,300,400,500,600,700,800,900]},textDecoration:{enums:["none","underline","overline","line-through"]},textTransform:{enums:["none","uppercase","lowercase"]},textWrap:{enums:["none","wrap"]},textBackgroundShape:{enums:["rectangle","roundrectangle"]},nodeShape:{enums:["rectangle","roundrectangle","ellipse","triangle","square","pentagon","hexagon","heptagon","octagon","star","diamond","vee","rhomboid","polygon"]},compoundIncludeLabels:{enums:["include","exclude"]},arrowShape:{enums:["tee","triangle","triangle-tee","triangle-backcurve","half-triangle-overshot","vee","square","circle","diamond","none"]},arrowFill:{enums:["filled","hollow"]},display:{enums:["element","none"]},visibility:{enums:["hidden","visible"]},valign:{enums:["top","center","bottom"]},halign:{enums:["left","center","right"]},text:{string:!0},data:{mapping:!0,regex:$("data")},layoutData:{mapping:!0,regex:$("layoutData")},scratch:{mapping:!0,regex:$("scratch")},mapData:{mapping:!0,regex:M("mapData")},mapLayoutData:{mapping:!0,regex:M("mapLayoutData")},mapScratch:{mapping:!0,regex:M("mapScratch")},fn:{mapping:!0,fn:!0},url:{regex:"url\\s*\\(\\s*['\"]?(.+?)['\"]?\\s*\\)|none|(.+)$"},propList:{propList:!0},angle:{number:!0,units:"deg|rad",implicitUnits:"rad"},textRotation:{number:!0,units:"deg|rad",implicitUnits:"rad",enums:["none","autorotate"]},polygonPointList:{number:!0,multiple:!0,evenMultiple:!0,min:-1,max:1,unitless:!0},edgeDistances:{enums:["intersection","node-position"]},easing:{regexes:["^(spring)\\s*\\(\\s*("+I+")\\s*,\\s*("+I+")\\s*\\)$","^(cubic-bezier)\\s*\\(\\s*("+I+")\\s*,\\s*("+I+")\\s*,\\s*("+I+")\\s*,\\s*("+I+")\\s*\\)$"],enums:["linear","ease","ease-in","ease-out","ease-in-out","ease-in-sine","ease-out-sine","ease-in-out-sine","ease-in-quad","ease-out-quad","ease-in-out-quad","ease-in-cubic","ease-out-cubic","ease-in-out-cubic","ease-in-quart","ease-out-quart","ease-in-out-quart","ease-in-quint","ease-out-quint","ease-in-out-quint","ease-in-expo","ease-out-expo","ease-in-out-expo","ease-in-circ","ease-out-circ","ease-in-out-circ"]}};// define visual style properties
var U=T.types,Z=T.properties=[// main label
{name:"label",type:U.text},{name:"text-rotation",type:U.textRotation},{name:"text-margin-x",type:U.bidirectionalSize},{name:"text-margin-y",type:U.bidirectionalSize},// source label
{name:"source-label",type:U.text},{name:"source-text-rotation",type:U.textRotation},{name:"source-text-margin-x",type:U.bidirectionalSize},{name:"source-text-margin-y",type:U.bidirectionalSize},{name:"source-text-offset",type:U.size},// target label
{name:"target-label",type:U.text},{name:"target-text-rotation",type:U.textRotation},{name:"target-text-margin-x",type:U.bidirectionalSize},{name:"target-text-margin-y",type:U.bidirectionalSize},{name:"target-text-offset",type:U.size},// common label style
{name:"text-valign",type:U.valign},{name:"text-halign",type:U.halign},{name:"color",type:U.color},{name:"text-outline-color",type:U.color},{name:"text-outline-width",type:U.size},{name:"text-outline-opacity",type:U.zeroOneNumber},{name:"text-opacity",type:U.zeroOneNumber},{name:"text-background-color",type:U.color},{name:"text-background-margin",type:U.size},{name:"text-background-opacity",type:U.zeroOneNumber},{name:"text-border-opacity",type:U.zeroOneNumber},{name:"text-border-color",type:U.color},{name:"text-border-width",type:U.size},{name:"text-border-style",type:U.borderStyle},{name:"text-background-shape",type:U.textBackgroundShape},// { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
{name:"text-transform",type:U.textTransform},{name:"text-wrap",type:U.textWrap},{name:"text-max-width",type:U.size},{name:"text-events",type:U.bool},{name:"font-family",type:U.fontFamily},{name:"font-style",type:U.fontStyle},// { name: 'font-variant', type: t.fontVariant }, // not useful
{name:"font-weight",type:U.fontWeight},{name:"font-size",type:U.size},{name:"min-zoomed-font-size",type:U.size},// behaviour
{name:"events",type:U.bool},// visibility
{name:"display",type:U.display},{name:"visibility",type:U.visibility},{name:"opacity",type:U.zeroOneNumber},{name:"z-index",type:U.nonNegativeInt},// overlays
{name:"overlay-padding",type:U.size},{name:"overlay-color",type:U.color},{name:"overlay-opacity",type:U.zeroOneNumber},// shadows
{name:"shadow-blur",type:U.size},{name:"shadow-color",type:U.color},{name:"shadow-opacity",type:U.zeroOneNumber},{name:"shadow-offset-x",type:U.bidirectionalSize},{name:"shadow-offset-y",type:U.bidirectionalSize},// label shadows
{name:"text-shadow-blur",type:U.size},{name:"text-shadow-color",type:U.color},{name:"text-shadow-opacity",type:U.zeroOneNumber},{name:"text-shadow-offset-x",type:U.bidirectionalSize},{name:"text-shadow-offset-y",type:U.bidirectionalSize},// transition anis
{name:"transition-property",type:U.propList},{name:"transition-duration",type:U.time},{name:"transition-delay",type:U.time},{name:"transition-timing-function",type:U.easing},// node body
{name:"height",type:U.nodeSize},{name:"width",type:U.nodeSize},{name:"shape",type:U.nodeShape},{name:"shape-polygon-points",type:U.polygonPointList},{name:"background-color",type:U.color},{name:"background-opacity",type:U.zeroOneNumber},{name:"background-blacken",type:U.nOneOneNumber},{name:"padding-left",type:U.size},{name:"padding-right",type:U.size},{name:"padding-top",type:U.size},{name:"padding-bottom",type:U.size},// node border
{name:"border-color",type:U.color},{name:"border-opacity",type:U.zeroOneNumber},{name:"border-width",type:U.size},{name:"border-style",type:U.borderStyle},// node background images
{name:"background-image",type:U.url},{name:"background-image-opacity",type:U.zeroOneNumber},{name:"background-position-x",type:U.bgPos},{name:"background-position-y",type:U.bgPos},{name:"background-repeat",type:U.bgRepeat},{name:"background-fit",type:U.bgFit},{name:"background-clip",type:U.bgClip},{name:"background-width",type:U.bgWH},{name:"background-height",type:U.bgWH},// compound props
{name:"position",type:U.position},{name:"compound-sizing-wrt-labels",type:U.compoundIncludeLabels},// edge line
{name:"line-style",type:U.lineStyle},{name:"line-color",type:U.color},{name:"curve-style",type:U.curveStyle},{name:"haystack-radius",type:U.zeroOneNumber},{name:"control-point-step-size",type:U.size},{name:"control-point-distances",type:U.bidirectionalSizes},{name:"control-point-weights",type:U.numbers},{name:"segment-distances",type:U.bidirectionalSizes},{name:"segment-weights",type:U.numbers},{name:"edge-distances",type:U.edgeDistances},// these are just for the core
{name:"selection-box-color",type:U.color},{name:"selection-box-opacity",type:U.zeroOneNumber},{name:"selection-box-border-color",type:U.color},{name:"selection-box-border-width",type:U.size},{name:"active-bg-color",type:U.color},{name:"active-bg-opacity",type:U.zeroOneNumber},{name:"active-bg-size",type:U.size},{name:"outside-texture-bg-color",type:U.color},{name:"outside-texture-bg-opacity",type:U.zeroOneNumber}],G=T.aliases=[{name:"content",pointsTo:"label"},{name:"control-point-distance",pointsTo:"control-point-distances"},{name:"control-point-weight",pointsTo:"control-point-weights"},{name:"edge-text-rotation",pointsTo:"text-rotation"}];// define aliases
// pie backgrounds for nodes
T.pieBackgroundN=16,Z.push({name:"pie-size",type:U.bgSize});for(var K=1;K<=T.pieBackgroundN;K++)Z.push({name:"pie-"+K+"-background-color",type:U.color}),Z.push({name:"pie-"+K+"-background-size",type:U.percent}),Z.push({name:"pie-"+K+"-background-opacity",type:U.zeroOneNumber});// edge arrows
var J=T.arrowPrefixes=["source","mid-source","target","mid-target"];[{name:"arrow-shape",type:U.arrowShape},{name:"arrow-color",type:U.color},{name:"arrow-fill",type:U.arrowFill}].forEach(function(re){J.forEach(function(oe){var se=oe+"-"+re.name,le=re.type;Z.push({name:se,type:le})})},{}),T.propertyNames=Z.map(function(re){return re.name});// allow access of properties by name ( e.g. style.properties.height )
for(var K=0;K<Z.length;K++){var ee=Z[K];Z[ee.name]=ee}// map aliases
for(var K=0;K<G.length;K++){var te=G[K],ae=Z[te.pointsTo],ne={name:te.name,alias:!0,pointsTo:ae};// add alias prop for parsing
Z.push(ne),Z[te.name]=ne}})(),T.getDefaultProperty=function(I){return this.getDefaultProperties()[I]},T.getDefaultProperties=D.memoize(function(){var I=D.extend({events:"yes","text-events":"no","text-valign":"top","text-halign":"center",color:"#000","text-outline-color":"#000","text-outline-width":0,"text-outline-opacity":1,"text-opacity":1,"text-decoration":"none","text-transform":"none","text-wrap":"none","text-max-width":9999,"text-background-color":"#000","text-background-opacity":0,"text-background-margin":0,"text-border-opacity":0,"text-border-width":0,"text-border-style":"solid","text-border-color":"#000","text-background-shape":"rectangle","font-family":"Helvetica Neue, Helvetica, sans-serif","font-style":"normal","font-weight":"normal","font-size":16,"min-zoomed-font-size":0,"text-rotation":"none","source-text-rotation":"none","target-text-rotation":"none",visibility:"visible",display:"element",opacity:1,"z-index":0,label:"","text-margin-x":0,"text-margin-y":0,"source-label":"","source-text-offset":0,"source-text-margin-x":0,"source-text-margin-y":0,"target-label":"","target-text-offset":0,"target-text-margin-x":0,"target-text-margin-y":0,"overlay-opacity":0,"overlay-color":"#000","overlay-padding":10,"shadow-opacity":0,"shadow-color":"#000","shadow-blur":10,"shadow-offset-x":0,"shadow-offset-y":0,"text-shadow-opacity":0,"text-shadow-color":"#000","text-shadow-blur":5,"text-shadow-offset-x":0,"text-shadow-offset-y":0,"transition-property":"none","transition-duration":0,"transition-delay":0,"transition-timing-function":"linear","background-blacken":0,"background-color":"#999","background-opacity":1,"background-image":"none","background-image-opacity":1,"background-position-x":"50%","background-position-y":"50%","background-repeat":"no-repeat","background-fit":"none","background-clip":"node","background-width":"auto","background-height":"auto","border-color":"#000","border-opacity":1,"border-width":0,"border-style":"solid",height:30,width:30,shape:"ellipse","shape-polygon-points":"-1, -1,   1, -1,   1, 1,   -1, 1","padding-top":0,"padding-bottom":0,"padding-left":0,"padding-right":0,position:"origin","compound-sizing-wrt-labels":"include"},{"pie-size":"100%"},[{name:"pie-{{i}}-background-color",value:"black"},{name:"pie-{{i}}-background-size",value:"0%"},{name:"pie-{{i}}-background-opacity",value:1}].reduce(function(U,Z){for(var G=1;G<=T.pieBackgroundN;G++){var K=Z.name.replace("{{i}}",G),J=Z.value;U[K]=J}return U},{}),{"line-style":"solid","line-color":"#999","control-point-step-size":40,"control-point-weights":0.5,"segment-weights":0.5,"segment-distances":20,"edge-distances":"intersection","curve-style":"bezier","haystack-radius":0},[{name:"arrow-shape",value:"none"},{name:"arrow-color",value:"#999"},{name:"arrow-fill",value:"filled"}].reduce(function(U,Z){return T.arrowPrefixes.forEach(function(G){var K=G+"-"+Z.name,J=Z.value;U[K]=J}),U},{})),L={};for(var O=0;O<this.properties.length;O++){var R=this.properties[O];if(!R.pointsTo){var F=R.name,$=I[F],M=this.parse(F,$);L[F]=M}}return L}),T.addDefaultStylesheet=function(){this.selector("$node > node")// compound (parent) node properties
.css({shape:"rectangle","padding-top":10,"padding-right":10,"padding-left":10,"padding-bottom":10,"background-color":"#eee","border-color":"#ccc","border-width":1}).selector("edge")// just edge properties
.css({width:3,"curve-style":"haystack"}).selector(":selected").css({"background-color":"#0169D9","line-color":"#0169D9","source-arrow-color":"#0169D9","target-arrow-color":"#0169D9","mid-source-arrow-color":"#0169D9","mid-target-arrow-color":"#0169D9"}).selector("node:parent:selected").css({"background-color":"#CCE1F9","border-color":"#aec8e5"}).selector(":active").css({"overlay-color":"black","overlay-padding":10,"overlay-opacity":0.25}).selector("core")// just core properties
.css({"selection-box-color":"#ddd","selection-box-opacity":0.65,"selection-box-border-color":"#aaa","selection-box-border-width":1,"active-bg-color":"black","active-bg-opacity":0.15,"active-bg-size":30,"outside-texture-bg-color":"#000","outside-texture-bg-opacity":0.125}),this.defaultLength=this.length},_.exports=T},{"../util":99}],95:[function(E,_){"use strict";var D=E("../util"),T=E("../selector"),I={};I.applyFromString=function(L){function O(){M=M.length>U.length?M.substr(U.length):""}function R(){Z=Z.length>G.length?Z.substr(G.length):""}var F=this,$=this,M=""+L,U,Z,G;// remove comments from the style string
for(M=M.replace(/[/][*](\s|.)+?[*][/]/g,"");!0;){var K=M.match(/^\s*$/);if(K)break;var J=M.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);if(!J){D.error("Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: "+M);break}U=J[0];// parse the selector
var ee=J[1];if("core"!==ee){var te=new T(ee);if(te._private.invalid){D.error("Skipping parsing of block: Invalid selector found in string stylesheet: "+ee),O();continue}}// parse the block of properties and values
var ae=J[2],ne=!1;Z=ae;for(var re=[];!0;){var K=Z.match(/^\s*$/);if(K)break;var oe=Z.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);if(!oe){D.error("Skipping parsing of block: Invalid formatting of style property and value definitions found in:"+ae),ne=!0;break}G=oe[0];var se=oe[1],le=oe[2],pe=F.properties[se];if(!pe){D.error("Skipping property: Invalid property name in: "+G),R();continue}var ue=$.parse(se,le);if(!ue){D.error("Skipping property: Invalid property definition in: "+G),R();continue}re.push({name:se,val:le}),R()}if(ne){O();break}// put the parsed block in the style
$.selector(ee);for(var ge=0;ge<re.length;ge++){var pe=re[ge];$.css(pe.name,pe.val)}O()}return $},I.fromString=function(L){var O=this;return O.resetToDefault(),O.applyFromString(L),O},_.exports=I},{"../selector":86,"../util":99}],96:[function(E,_){"use strict";var D=E("./is"),T=E("./util"),I=E("./style"),L=function(){return this instanceof L?void(this.length=0):new L},O=L.prototype;// a dummy stylesheet object that doesn't need a reference to the core
// (useful for init)
O.instanceString=function(){return"stylesheet"},O.selector=function(R){var F=this.length++;return this[F]={selector:R,properties:[]},this;// chaining
},O.css=function(R,F){var $=this.length-1;if(D.string(R))this[$].properties.push({name:R,value:F});else if(D.plainObject(R)){var M=R;for(var U=0;U<I.properties.length;U++){var Z=I.properties[U],G=M[Z.name];if(void 0===G&&(G=M[T.dash2camel(Z.name)]),void 0!==G){var R=Z.name,F=G;this[$].properties.push({name:R,value:F})}}}return this;// chaining
},O.style=O.css,O.generateStyle=function(R){var F=new I(R);for(var $=0;$<this.length;$++){var M=this[$],U=M.selector,Z=M.properties;F.selector(U);// apply selector
for(var G=0;G<Z.length;G++){var K=Z[G];F.css(K.name,K.value)}}return F},_.exports=L},{"./is":83,"./style":91,"./util":99}],97:[function(require,module){/*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */// cross-env thread/worker
// NB : uses (heavyweight) processes on nodejs so best not to create too many threads
"use strict";var window=require("./window"),util=require("./util"),Promise=require("./promise"),Event=require("./event"),define=require("./define"),is=require("./is"),Thread=function(E){if(!(this instanceof Thread))return new Thread(E);var _=this._private={requires:[],files:[],queue:null,pass:[],disabled:!1};is.plainObject(E)&&null!=E.disabled&&(_.disabled=!!E.disabled)},thdfn=Thread.prototype,stringifyFieldVal=function(E){var _=is.fn(E)?E.toString():"JSON.parse('"+JSON.stringify(E)+"')";return _},fnAsRequire=function(E){var _,D;is.object(E)&&E.fn?(_=fnAs(E.fn,E.name),D=E.name,E=E.fn):is.fn(E)?(_=E.toString(),D=E.name):is.string(E)?_=E:is.object(E)&&(_=E.proto?"":E.name+" = {};",D=E.name,E=E.obj),_+="\n";var T=function(M,U){if(M.prototype){var Z=!1;for(var G in M.prototype){Z=!0;break}// jshint ignore:line
Z&&(_+=fnAsRequire({name:U,obj:M,proto:!0},M))}};// pull in prototype
if(E.prototype&&null!=D)for(var I in E.prototype){var L="",O=E.prototype[I],R=stringifyFieldVal(O),F=D+".prototype."+I;L+=F+" = "+R+";\n",L&&(_+=L),T(O,F)}// pull in properties for obj/fns
if(!is.string(E))for(var I in E){var $="";if(E.hasOwnProperty(I)){var O=E[I],R=stringifyFieldVal(O),F=D+"[\""+I+"\"]";$+=F+" = "+R+";\n"}$&&(_+=$),T(O,F)}return _},isPathStr=function(E){return is.string(E)&&E.match(/\.js$/)};// short alias
// allows for requires with prototypes and subobjs etc
util.extend(thdfn,{instanceString:function(){return"thread"},require:function(E,_){var D=this._private.requires;if(isPathStr(E))return this._private.files.push(E),this;if(_)E=is.fn(E)?{name:_,fn:E}:{name:_,obj:E};else if(is.fn(E)){if(!E.name)throw"The function name could not be automatically determined.  Use thread.require( someFunction, \"someFunction\" )";E={name:E.name,fn:E}}return D.push(E),this;// chaining
},pass:function(E){return this._private.pass.push(E),this;// chaining
},run:function(fn,pass){// fn used like main()
var self=this,_p=this._private;if(pass=pass||_p.pass.shift(),_p.stopped)throw"Attempted to run a stopped thread!  Start a new thread or do not stop the existing thread and reuse it.";if(_p.running)return _p.queue=_p.queue.then(function(){// inductive step
return self.run(fn,pass)});var useWW=null!=window&&!_p.disabled,useNode=!window&&"undefined"!=typeof module&&!_p.disabled;self.trigger("run");var runP=new Promise(function(resolve,reject){_p.running=!0;var threadTechAlreadyExists=_p.ran,fnImplStr=is.string(fn)?fn:fn.toString(),fnStr="\n"+_p.requires.map(function(E){return fnAsRequire(E)}).concat(_p.files.map(function(E){if(useWW){var _=function(D){return D.match(/^\.\//)||D.match(/^\.\./)?window.location.origin+window.location.pathname+D:D.match(/^\//)?window.location.origin+"/"+D:D};return"importScripts(\""+_(E)+"\");"}if(useNode)return"eval( require(\"fs\").readFileSync(\""+E+"\", { encoding: \"utf8\" }) );";throw"External file `"+E+"` can not be required without any threading technology."})).concat(["( function(){","var ret = ("+fnImplStr+")("+JSON.stringify(pass)+");","if( ret !== undefined ){ resolve(ret); }",// assume if ran fn returns defined value (incl. null), that we want to resolve to it
"} )()\n"]).join("\n");// worker code to exec
// because we've now consumed the requires, empty the list so we don't dupe on next run()
if(_p.requires=[],_p.files=[],useWW){var fnBlob,fnUrl;// add normalised thread api functions
if(!threadTechAlreadyExists){var fnPre=fnStr+"";fnStr=["function _ref_(o){ return eval(o); };","function broadcast(m){ return message(m); };","function message(m){ postMessage(m); };","function listen(fn){","  self.addEventListener(\"message\", function(m){ ","    if( typeof m === \"object\" && (m.data.$$eval || m.data === \"$$start\") ){","    } else { ","      fn( m.data );","    }","  });","};","self.addEventListener(\"message\", function(m){  if( m.data.$$eval ){ eval( m.data.$$eval ); }  });","function resolve(v){ postMessage({ $$resolve: v }); };","function reject(v){ postMessage({ $$reject: v }); };"].join("\n"),fnStr+=fnPre,fnBlob=new Blob([fnStr],{type:"application/javascript"}),fnUrl=window.URL.createObjectURL(fnBlob)}// create webworker and let it exec the serialised code
var ww=_p.webworker=_p.webworker||new Worker(fnUrl);threadTechAlreadyExists&&ww.postMessage({$$eval:fnStr});// worker messages => events
var cb;ww.addEventListener("message",cb=function(E){var _=is.object(E)&&is.object(E.data);_&&"$$resolve"in E.data?(ww.removeEventListener("message",cb),resolve(E.data.$$resolve)):_&&"$$reject"in E.data?(ww.removeEventListener("message",cb),reject(E.data.$$reject)):self.trigger(new Event(E,{type:"message",message:E.data}))},!1),threadTechAlreadyExists||ww.postMessage("$$start")}else if(useNode){_p.child||(_p.child=require("child_process").fork(require("path").join(__dirname,"thread-node-fork")));var child=_p.child,cb;// child process messages => events
child.on("message",cb=function(E){is.object(E)&&"$$resolve"in E?(child.removeListener("message",cb),resolve(E.$$resolve)):is.object(E)&&"$$reject"in E?(child.removeListener("message",cb),reject(E.$$reject)):self.trigger(new Event({},{type:"message",message:E}))}),child.send({$$eval:fnStr})}else{// use a fallback mechanism using a timeout
var timer=_p.timer=_p.timer||{listeners:[],exec:function(){fnStr=["function _ref_(o){ return eval(o); };","function broadcast(m){ return message(m); };","function message(m){ self.trigger( new Event({}, { type: \"message\", message: m }) ); };","function listen(fn){ timer.listeners.push( fn ); };","function resolve(v){ promiseResolve(v); };","function reject(v){ promiseReject(v); };"].join("\n")+fnStr,eval(fnStr)},message:function(E){var _=timer.listeners;for(var D=0;D<_.length;D++){var T=_[D];T(E)}}};timer.exec()}}).then(function(E){return _p.running=!1,_p.ran=!0,self.trigger("ran"),E});return null==_p.queue&&(_p.queue=runP),runP},// send the thread a message
message:function(E){var _=this._private;return _.webworker&&_.webworker.postMessage(E),_.child&&_.child.send(E),_.timer&&_.timer.message(E),this;// chaining
},stop:function(){var E=this._private;return E.webworker&&E.webworker.terminate(),E.child&&E.child.kill(),E.timer,E.stopped=!0,this.trigger("stop");// chaining
},stopped:function(){return this._private.stopped}});// turns a stringified function into a (re)named function
var fnAs=function(E,_){var D=E.toString();return D=D.replace(/function\s*?\S*?\s*?\(/,"function "+_+"("),D},defineFnal=function(E){return E=E||{},function(D,T){var I=fnAs(D,"_$_$_"+E.name);return this.require(I),this.run(["function( data ){","  var origResolve = resolve;","  var res = [];","  ","  resolve = function( val ){","    res.push( val );","  };","  ","  var ret = data."+E.name+"( _$_$_"+E.name+(1<arguments.length?", "+JSON.stringify(T):"")+" );","  ","  resolve = origResolve;","  resolve( res.length > 0 ? res : ret );","}"].join("\n"))}};util.extend(thdfn,{reduce:defineFnal({name:"reduce"}),reduceRight:defineFnal({name:"reduceRight"}),map:defineFnal({name:"map"})});// aliases
var fn=thdfn;fn.promise=fn.run,fn.terminate=fn.halt=fn.stop,fn.include=fn.require,util.extend(thdfn,{on:define.on(),one:define.on({unbindSelfOnTrigger:!0}),off:define.off(),trigger:define.trigger()}),define.eventAliasesOn(thdfn),module.exports=Thread},{"./define":44,"./event":45,"./is":83,"./promise":85,"./util":99,"./window":106,child_process:void 0,path:void 0}],98:[function(E,_){"use strict";var D=E("../is");_.exports={// get [r, g, b] from #abc or #aabbcc
hex2tuple:function(T){if((4===T.length||7===T.length)&&"#"===T[0]){var I=4===T.length,F=16,L,O,R;return I?(L=parseInt(T[1]+T[1],F),O=parseInt(T[2]+T[2],F),R=parseInt(T[3]+T[3],F)):(L=parseInt(T[1]+T[2],F),O=parseInt(T[3]+T[4],F),R=parseInt(T[5]+T[6],F)),[L,O,R]}},// get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
hsl2tuple:function(T){function I(ee,te,ae){return 0>ae&&(ae+=1),1<ae&&(ae-=1),ae<1/6?ee+6*(te-ee)*ae:ae<1/2?te:ae<2/3?ee+6*((te-ee)*(2/3-ae)):ee}var L,O,R,F,$,M,U,Z,G=new RegExp("^"+this.regex.hsla+"$").exec(T);if(G){if(O=parseInt(G[1]),0>O?O=(360- -1*O%360)%360:360<O&&(O=O%360),O/=360,R=parseFloat(G[2]),0>R||100<R)return;// saturation is [0, 100]
if(R=R/100,F=parseFloat(G[3]),0>F||100<F)return;// lightness is [0, 100]
if(F=F/100,$=G[4],void 0!=$&&($=parseFloat($),0>$||1<$))return;// now, convert to rgb
// code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
if(0===R)M=U=Z=Math.round(255*F);else{var K=0.5>F?F*(1+R):F+R-F*R,J=2*F-K;M=Math.round(255*I(J,K,O+1/3)),U=Math.round(255*I(J,K,O)),Z=Math.round(255*I(J,K,O-1/3))}L=[M,U,Z,$]}return L},// get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
rgb2tuple:function(T){var I,L=new RegExp("^"+this.regex.rgba+"$").exec(T);if(L){I=[];var O=[];for(var R=1;3>=R;R++){var F=L[R];if("%"===F[F.length-1]&&(O[R]=!0),F=parseFloat(F),O[R]&&(F=255*(F/100)),0>F||255<F)return;// invalid channel value
I.push(Math.floor(F))}var $=O[1]||O[2]||O[3],M=O[1]&&O[2]&&O[3];if($&&!M)return;// must all be percent values if one is
var U=L[4];if(void 0!==U){if(U=parseFloat(U),0>U||1<U)return;// invalid alpha value
I.push(U)}}return I},colorname2tuple:function(T){return this.colors[T.toLowerCase()]},color2tuple:function(T){return(D.array(T)?T:null)||this.colorname2tuple(T)||this.hex2tuple(T)||this.rgb2tuple(T)||this.hsl2tuple(T)},colors:{// special colour names
transparent:[0,0,0,0],// NB alpha === 0
// regular colours
aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],grey:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]}}},{"../is":83}],99:[function(E,_){"use strict";/*global console */var D=E("../is"),T=E("../math"),I={trueify:function(){return!0},falsify:function(){return!1},zeroify:function(){return 0},noop:function(){},error:function(){console.error?(console.error.apply(console,arguments),console.trace&&console.trace()):(console.log.apply(console,arguments),console.trace&&console.trace())},clone:function(L){return this.extend({},L)},// gets a shallow copy of the argument
copy:function(L){if(null==L)return L;return D.array(L)?L.slice():D.plainObject(L)?this.clone(L):L},uuid:function(L,O// placeholders
){for(// loop :)
O=L="";// b - result , a - numeric variable
36>L++;//
O+=52&51*L// if "a" is not 9 or 14 or 19 or 24
?//  return a random number or 4
(15^L// if "a" is not 15
?// genetate a random number from 0 to 15
8^Math.random()*(20^L?16:4)// unless "a" is 20, in which case a random number from 8 to 11
:4//  otherwise 4
).toString(16):"-"//  in other cases (if "a" is 9,14,19,24) insert "-"
);return O}};I.makeBoundingBox=T.makeBoundingBox.bind(T),I._staticEmptyObject={},I.staticEmptyObject=function(){return I._staticEmptyObject},I.extend=null==Object.assign?function(L){var O=arguments;for(var R=1;R<O.length;R++){var F=O[R];if(F){var $=Object.keys(F);for(var M=0;M<$.length;M++){var U=$[M];L[U]=F[U]}}}return L}:Object.assign,I.default=function(L,O){return L===void 0?O:L},I.removeFromArray=function(L,O,R){for(var F=L.length;0<=F&&!(L[F]===O&&(L.splice(F,1),!R));F--);},I.clearArray=function(L){L.splice(0,L.length)},I.getPrefixedProperty=function(L,O,R){// e.g. (labelWidth, source) => sourceLabelWidth
return L[R?this.prependCamel(R,O):O]},I.setPrefixedProperty=function(L,O,R,F){L[R?this.prependCamel(R,O):O]=F},[E("./colors"),E("./maps"),{memoize:E("./memoize")},E("./regex"),E("./strings"),E("./timing")].forEach(function(L){I.extend(I,L)}),_.exports=I},{"../is":83,"../math":84,"./colors":98,"./maps":100,"./memoize":101,"./regex":102,"./strings":103,"./timing":104}],100:[function(E,_){"use strict";var D=E("../is");_.exports={// has anything been set in the map
mapEmpty:function(T){return!(null!=T)||0===Object.keys(T).length},// pushes to the array at the end of a map (map may not be built)
pushMap:function(T){var I=this.getMap(T);null==I?this.setMap(this.extend({},T,{value:[T.value]})):I.push(T.value)},// sets the value in a map (map may not be built)
setMap:function(T){var I=T.map,L,O=T.keys,R=O.length;for(var F=0;F<R;F++){var L=O[F];D.plainObject(L)&&this.error("Tried to set map with object key"),F<O.length-1?(null==I[L]&&(I[L]={}),I=I[L]):I[L]=T.value}},// gets the value in a map even if it's not built in places
getMap:function(T){var I=T.map,L=T.keys,O=L.length;for(var R=0;R<O;R++){var F=L[R];if(D.plainObject(F)&&this.error("Tried to get map with object key"),I=I[F],null==I)return I}return I},// deletes the entry in the map
deleteMap:function(T){var I=T.map,L=T.keys,O=L.length,R=T.keepChildren;for(var F=0;F<O;F++){var $=L[F];D.plainObject($)&&this.error("Tried to delete map with object key");var M=F===T.keys.length-1;if(!M)I=I[$];else if(R){// then only delete child fields not in keepChildren
var U=Object.keys(I);for(var Z=0;Z<U.length;Z++){var G=U[Z];R[G]||(I[G]=void 0)}}else I[$]=void 0}}}},{"../is":83}],101:[function(E,_){"use strict";_.exports=function(T,I){I||(I=function(){if(1===arguments.length)return arguments[0];if(0===arguments.length)return"undefined";var O=[];for(var R=0;R<arguments.length;R++)O.push(arguments[R]);return O.join("$")});var L=function(){var O=this,R=arguments,$=I.apply(O,R),M=L.cache,F;return(F=M[$])||(F=M[$]=T.apply(O,R)),F};return L.cache={},L}},{}],102:[function(E,_){"use strict";var D="(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))";_.exports={regex:{number:D,rgba:"rgb[a]?\\(("+D+"[%]?)\\s*,\\s*("+D+"[%]?)\\s*,\\s*("+D+"[%]?)(?:\\s*,\\s*("+D+"))?\\)",rgbaNoBackRefs:"rgb[a]?\\((?:"+D+"[%]?)\\s*,\\s*(?:"+D+"[%]?)\\s*,\\s*(?:"+D+"[%]?)(?:\\s*,\\s*(?:"+D+"))?\\)",hsla:"hsl[a]?\\(("+D+")\\s*,\\s*("+D+"[%])\\s*,\\s*("+D+"[%])(?:\\s*,\\s*("+D+"))?\\)",hslaNoBackRefs:"hsl[a]?\\((?:"+D+")\\s*,\\s*(?:"+D+"[%])\\s*,\\s*(?:"+D+"[%])(?:\\s*,\\s*(?:"+D+"))?\\)",hex3:"\\#[0-9a-fA-F]{3}",hex6:"\\#[0-9a-fA-F]{6}"}}},{}],103:[function(E,_){"use strict";var D=E("./memoize"),T=E("../is");_.exports={camel2dash:D(function(I){return I.replace(/([A-Z])/g,function(L){return"-"+L.toLowerCase()})}),dash2camel:D(function(I){return I.replace(/(-\w)/g,function(L){return L[1].toUpperCase()})}),prependCamel:D(function(I,L){return I+L[0].toUpperCase()+L.substring(1)},function(I,L){return I+"$"+L}),capitalize:function(I){return T.emptyString(I)?I:I.charAt(0).toUpperCase()+I.substring(1)}}},{"../is":83,"./memoize":101}],104:[function(E,_){"use strict";var D=E("../window"),T=E("../is"),I=D?D.performance:null,L={},O=D?D.requestAnimationFrame||D.mozRequestAnimationFrame||D.webkitRequestAnimationFrame||D.msRequestAnimationFrame:null;O=O||function(F){F&&setTimeout(function(){F(R())},1000/60)},L.requestAnimationFrame=function(F){O(F)};var R=I&&I.now?function(){return I.now()}:function(){return Date.now()};L.performanceNow=R,L.throttle=function(F,$,M){var U=!0,Z=!0;return!1===M?U=!1:T.plainObject(M)&&(U="leading"in M?M.leading:U,Z="trailing"in M?M.trailing:Z),M=M||{},M.leading=U,M.maxWait=$,M.trailing=Z,L.debounce(F,$,M)},L.now=function(){return Date.now()},L.debounce=function(F,$,M){// ported lodash debounce function
var U=this,ne=0,re=!1,oe=!0,Z,G,K,J,ee,te,ae;if(T.fn(F)){if($=Math.max(0,$)||0,!0===M){var se=!0;oe=!1}else T.plainObject(M)&&(se=M.leading,re="maxWait"in M&&(Math.max($,M.maxWait)||0),oe="trailing"in M?M.trailing:oe);var le=function(){var ue=$-(U.now()-J);if(0>=ue){G&&clearTimeout(G);var ge=ae;G=te=ae=void 0,ge&&(ne=U.now(),K=F.apply(ee,Z),!te&&!G&&(Z=ee=null))}else te=setTimeout(le,ue)},pe=function(){te&&clearTimeout(te),G=te=ae=void 0,(oe||re!==$)&&(ne=U.now(),K=F.apply(ee,Z),!te&&!G&&(Z=ee=null))};return function(){if(Z=arguments,J=U.now(),ee=this,ae=oe&&(te||!se),!1===re)var ue=se&&!te;else{G||se||(ne=J);var ge=re-(J-ne),ce=0>=ge;ce?(G&&(G=clearTimeout(G)),ne=J,K=F.apply(ee,Z)):!G&&(G=setTimeout(pe,ge))}return ce&&te?te=clearTimeout(te):!te&&$!==re&&(te=setTimeout(le,$)),ue&&(ce=!0,K=F.apply(ee,Z)),!ce||te||G||(Z=ee=null),K}}},_.exports=L},{"../is":83,"../window":106}],105:[function(E,_){_.exports="snapshot-60051ffa47-1478888798152"},{}],106:[function(E,_){_.exports="undefined"==typeof window?null:window},{}]},{},[82])(82)});